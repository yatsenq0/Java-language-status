## ГЛАВА 9: Наследование

### 9.1. Введение
В предыдущих разделах я уже несколько раз упоминал наследование. Настало время подробно разобрать эту вещь (рис. 9.1).

Java класс может наследоваться от другого класса, получая его методы и поля. Этот родительский класс, в свою очередь, может наследоваться от еще одного класса и т. д. В Java нет множественного наследования классов: один класс может наследоваться напрямую только от одного другого класса.

Класс, который наследуется от другого класса, называется:
- Подклассом (subclass)
- Дочерним классом (child class)
- Потомком
- Расширенным классом (extended class)

Класс, от которого наследуется дочерний класс, называется:
- Родительским классом (parent class)
- Предком
- Суперклассом (superclass)
- Базовым классом (base class)

В самой вершине иерархии наследования находится класс `Object`, от которого наследуются все классы, для которых явно не указан предок. Таким образом, все классы (кроме самого `Object`) напрямую или через какое-либо количество уровней наследования происходят от этого класса.

Идея наследования классов состоит в том, что, когда вы хотите создать новый класс, например `Goblin`, и уже существует какой-нибудь класс, который реализует часть функциональности, необходимой нашему классу, например `Monster`, вы можете указать этот класс в качестве родительского, унаследовав таким образом все его члены (поля, вложенные классы и методы экземпляров). Конструкторы не наследуются и не являются членами классов, но можно вызвать конструктор базового класса из конструктора дочернего.

Рис. 9.1. Пример иерархии классов в Java

Дочерний класс наследует все `public` и `protected` члены своего родителя независимо от пакета, в котором расположен родительский класс. Если дочерний и родительский классы находятся в одном пакете, то дочерний наследует также `package-private` члены своего родителя.

#### Основные правила наследования:
- Унаследованные поля можно использовать напрямую.
- Можно объявить в дочернем классе поле с таким же именем, как и поле в родительском классе; тогда это поле скроет поле родительского класса (не рекомендуется так делать).
- В дочернем классе можно объявлять поля, которых нет в родительском классе.
- Унаследованные методы можно использовать напрямую.
- Можно объявить метод экземпляров в дочернем классе с точно такой же сигнатурой, что и метод экземпляров в родительском классе; тогда этот метод переопределит метод суперкласса.
- Можно объявить в дочернем классе статический метод с точно такой же сигнатурой, что и статический метод в родительском классе; тогда этот метод скроет метод родительского класса.
- В дочернем классе можно объявлять новые методы, которых нет в родительском классе.
- В дочернем классе можно объявить конструктор, который будет явно (с помощью ключевого слова `super`) или неявно вызывать конструктор базового класса.

Дочерний класс не наследует `private` члены родительского класса; однако если в родительском классе есть `protected`, `public` или `package-private` методы для доступа к `private` полям, они могут использоваться дочерним классом.

### 9.2. Приведение типов
Посмотрите на создание экземпляра объекта `Goblin`:

```java
Goblin obj = new Goblin();
```

Мы знаем, что `Goblin` наследуется от `Monster`, который, в свою очередь, наследуется от `Object`. Таким образом, `Goblin` является и `Monster`, и `Object`. Экземпляр класса `Goblin` можно использовать в любом месте, где ожидается экземпляр класса `Monster` или `Object`.

Но `Monster` необязательно должен являться `Goblin`. Экземпляр класса `Monster` может быть экземпляром класса `Goblin`, а может быть экземпляром самого `Monster` или любого другого дочернего класса.

Неявное приведение типов используется, когда мы приводим дочерний класс к классу выше по наследованию:

```java
Object obj1 = new Goblin();
Monster obj2 = new Goblin();
```

При обратном приведении типов нужно указывать явное приведение типов:

```java
Goblin goblin = (Goblin) obj;
```

Компилятор вставит проверку на соответствие типа в эту операцию. Если объект не является экземпляром класса `Goblin`, то возникнет исключение `java.lang.ClassCastException`.

### 9.3. Переопределение (overriding) и скрытие (hiding) методов
Если метод экземпляров в дочернем классе имеет ту же сигнатуру и тот же тип результата, что и метод в родительском классе, то он переопределяет этот метод. Эта возможность позволяет указать в качестве родительского класса наиболее подходящий вариант и затем изменить его поведение.

Можно поставить аннотацию `@Override` у метода дочернего класса для указания компилятору на переопределение метода базового класса.

Переопределяющий метод может вернуть тип-потомок типа возвращаемого переопределяемым методом; этот дочерний тип называется ковариантным возвращаемым типом.

Если дочерний класс определяет статический метод с той же сигнатурой, что и метод в родительском классе, то этот метод скрывает метод родительского класса.

Сравнение методов переопределения и скрытия:
- При вызове переопределенного метода экземпляра будет вызван метод дочернего класса.
- Версия скрытого статического метода зависит от того, откуда будет производиться вызов: из суперкласса или дочернего класса.

### Пример кода

```java
class Monster {
    void instanceMethod() {
        System.out.println("Monster instance method");
    }
    static void staticMethod() {
        System.out.println("Monster static method");
    }
}

public class Goblin extends Monster {
    @Override
    void instanceMethod() {
        System.out.println("Goblin instance method");
    }
    static void staticMethod() {
        System.out.println("Goblin static method");
    }
}

public class OverridingHiding {
    public static void main(String[] args) {
        System.out.println("Begin test:");
        Monster monster = new Monster();
        Monster goblin = new Goblin();
        
        monster.instanceMethod(); // Вывод: Monster instance method
        goblin.instanceMethod();   // Вывод: Goblin instance method
        
        Monster.staticMethod();    // Вывод: Monster static method
        Goblin.staticMethod();     // Вывод: Goblin static method
    }
}
```

Этот код демонстрирует разницу между переопределением методов экземпляров и скрытием статических методов.

### 9.4. Использование ключевого слова super
Если ваш метод переопределяет метод базового класса, то вы не можете вызвать его напрямую по имени; необходимо использовать ключевое слово `super`. 

Пример:

```java
class Monster {
    double gold = 10.0;
    
    void walk() {
        System.out.println("Monster walk");
        System.out.println("Monster gold = " + gold);
    }
}

public class Goblin extends Monster {
    double gold = 20.0;

    void walk() {
        System.out.println("Goblin walk");
        System.out.println("Goblin gold = " + gold);
        System.out.println("Monster gold = " + super.gold);
        super.walk();
    }
}

public class SuperExample {
    public static void main(String[] args) {
        Goblin goblin = new Goblin();
        goblin.walk();
    }
}
```

### 9.5. Общий предок Object и его методы
Класс java.lang.Object является суперклассом для всех других классов в Java и имеет несколько методов экземпляров:

1. **Метод clone():** Создает копию объекта.
2. **Метод equals(Object obj):** Проверяет равенство двух объектов.
3. **Метод finalize():** Вызывается сборщиком мусора.
4. **Метод getClass():** Возвращает объект java.lang.Class.
5. **Метод hashCode():** Возвращает хеш-код для объекта.
6. **Метод toString():** Возвращает строковое представление объекта.

### 9.6. Ключевое слово final и неизменяемые классы
Используйте модификатор final для методов или классов для предотвращения их переопределения или наследования соответственно.

### 9.7. Абстрактные методы и классы
Абстрактный класс может содержать абстрактные методы без реализации. Классы-потомки должны реализовать все абстрактные методы или также быть абстрактными.

#### Пример абстрактного класса:

```java
abstract class BaseMonster {
    abstract void myAbstractMethod(int myParam1, double myParam2);
}
```

Используйте абстрактные классы для общего кода между близкородственными классами или если вам нужны поля экземпляров с доступом отличным от public.

Используйте интерфейсы для определения поведения различных несвязанных классов или когда требуется множественное наследование типов.

---
