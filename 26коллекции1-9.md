отформатируй текст: ГЛАВА 26  Коллекции 26.1. Введение Все коллекции в Java реализуют какой-нибудь основной интерфейс. 
Списки реализуют интерфейс java.util.List, множества реализуют интерфейс java.util.Set или java.util.SortedSet и т. д. 
На моем сайте https://urvanov.ru есть диаграмма интерфейсов для Java Collections Framework, которая может облегчить вам понимание этой главы. 
26.2. Интерфейс Collection Интерфейс java.util.Collection содержит наиболее общие свойства всех коллек-ций. Он используется в качестве параметра в тех методах, где нужно принимать любой тип коллекций. Например, по соглашению все коллекции имеют конструк-тор, который принимает интерфейс Collection в качестве параметра. Такой конст-руктор инициализирует новую коллекцию всеми элементами из указанной коллек-ции, т. е. позволяет вам конвертировать один тип коллекций в другой. 
Предположим, что у вас есть Collection<String> c, который может быть List, Set или другим типом Collection. Следующий код создает новый экземпляр ArrayList (реализацию интерфейса List), который содержит все элементы из c: 
List<String> list = new ArrayList<>(c); 
Интерфейс java.util.Collection содержит методы для осуществления базовых операций: 
  Глава 26. Коллекции 279 int size() Возвращает количество элементов в коллекции. 
 boolean isEmpty() Возвращает true, если в коллекции нет ни одного элемента. 
 boolean contains(Object element) Возвращает true, если коллекция содержит элемент element. 
 boolean add(E element) Добавляет элемент в коллекцию. Возвращает true, если элемент был добавлен. 
Возвращает false, если коллекция не может содержать дублирующихся элементов и такой элемент уже в ней есть. 
 boolean remove(Object element) Удаляет одно вхождение element из коллекции. Возвращает true, если элемент был удален, false — коллекция не была изменена. 
 Iterator<E> iterator() Возвращает итератор, позволяющий пройтись по элементам коллекции и удалить некоторые элементы. Iterator представляет собой вот такой интерфейс: 
public interface Iterator<E> {  boolean hasNext(); 
 E next(); 
 void remove(); //optional } Метод hasNext() возвращает true, если остались еще элементы. Метод next() воз-вращает следующий элемент. Метод remove() позволяет удалить последний воз-вращенный методом next() элемент. Внимание! Во время использования итератора нельзя изменять коллекцию любым другим способом, кроме метода remove() этого итератора, иначе возникнет исключение. 
Также есть методы, которые оперируют целыми коллекциями: 
 boolean containsAll(Collection<?> c) Возвращает true, если коллекция содержит все элементы из c. 
 boolean addAll(Collection<? extends E> c) Добавляет все элементы из c в коллекцию. 
 boolean removeAll(Collection<?> c) Удаляет из коллекции все элементы, которые присутствуют в c. 
280 Глава 26. Коллекции boolean retainAll(Collection<?> c) Оставляет в коллекции только те элементы, которые также присутствуют в коллек-ции c, удаляя все остальные. 
 void clear() Удаляет все элементы из коллекции. 
 Есть также методы, позволяющие преобразовать коллекцию в массив: 
Object[] toArray() <T> T[] toArray(T[] a) Рекомендуется использовать второй метод, т. к. он позволяет преобразовать в массив определенного типа. Пример: String[] array = collection.toArray(new String[0]);. 
Начиная с JDK 8, интерфейс Collection также поставляет методы: 
Stream<E> stream() Stream<E> parallelStream() которые используются для получения последовательных потоков и параллельных потоков из коллекции. Для прохода по элементам коллекции можно использовать for-each: 
for (Object o : collection)  System.out.println(o); 
26.3. Интерфейс Set java.util.Set — это коллекция уникальных элементов. Интерфейс Set содержит только методы, унаследованные от java.util.Collection. Set накладывает более строгие соглашения на методы equals и hashCode, что позволяет сравнивать экземп-ляры Set, даже если они различных реализаций. Два экземпляра Set равны, если у них одинаковое количество элементов и они содержат одинаковые элементы. 
Платформа Java предоставляет три реализации интерфейса java.util.Set общего назначения: 
? java.util.HashSet. 
? java.util.TreeSet. 
? java.util.LinkedHashSet. 
HashSet — реализация на основе хеш-таблицы. Это наиболее эффективная реализа-ция, но она не гарантирует сохранение порядка элементов при обходе. 
TreeSet — реализация на основе красно-черных деревьев. Она упорядочивает эле-менты в соответствии с их значениями, но работает значительно медленнее HashSet. 
LinkedHashSet — реализация на основе хеш-таблицы, но дополнительно пролинко-ванная связанным списком. Эта реализация избавляет от хаотичного порядка эле-ментов и лишь незначительно хуже HashSet-а по эффективности. 
Глава 26. Коллекции 281 Также есть две реализации java.util.Set специального назначения: java.util.EnumSet и java.util.concurrent.CopyOnWriteArraySet. Реализация java.util.EnumSet предна-значена специально для перечислений, всегда используйте ее, когда нужно создать Set, содержащий значения одного и того же перечисления. EnumSet внутренне пред-ставляет собой битовый вектор, он очень компактный и быстрый. Реализация CopyOnWriteArraySet хранит свои элементы в массиве и создает новый массив при выполнении любой операции добавления, удаления или замены элемента. Она по-токобезопасна, при изменении CopyOnWriteArraySet все созданные до этого итера-торы остаются в рабочем состоянии. CopyOnWriteArraySet подходит для множеств, которые редко меняются, но по которым часто проходит операция итерации. 
С помощью Set можно удалить из любой коллекции дублирующиеся элементы. 
Например, мы хотим удалить дублирующиеся элементы из коллекции c: 
Collection<Type> noDups = new HashSet<Type>(c); 
26.4. Интерфейс List Интерфейс java.util.List представляет собой упорядоченную коллекцию элемен-тов. 
Java содержит два класса, реализующих интерфейсы List: java.util.ArrayList и java.util.LinkedList. 
Есть реализация специального назначения java.util.concurrent.CopyOnWriteArrayList. 
Она работает аналогично CopyOnWriteArraySet, т. е. для каждой операции добавле-ния, замены или удаления элемента создается новый массив, хранящий элементы списка. Итерация по CopyOnWriteArrayList никогда не приводит к java.util. 
ConcurrentModificationException. Есть еще синхронизированная реализация java.util.Vector. Существует также класс java.util.Stack, расширяющий класс Vector. Класс Stack можно использовать в качестве стека, но рекомендуется ис-пользовать интерфейс Deque и его реализацию ArrayDeque. 
Методы интерфейса java.util.Collection работают так, как от них ожидается. Метод remove для списка всегда удаляет первое вхождение элемента, а методы add и addAll добавляют элементы в конец. 
Так же как и интерфейс Set, интерфейс List предполагает более строгую реализа-цию equals и hashCode, так что два списка могут сравниваться, даже если они име-ют разные реализации. Два списка равны, если они содержат одинаковые элементы в одинаковом порядке. 
Ниже описаны операции, работающие с позициями элементов. Все операции, кото-рые принимают индекс элемента в качестве параметра, бросают исключение java.lang.IndexOutOfBoundsException, если индекс выходит за границы списка. 
 E get(int index) Возвращает элемент по индексу. 
282 Глава 26. Коллекции E set(int index,  E element) Заменяет элемент по указанному индексу. Возвращает старый элемент. 
 void add(int index,  E element) Вставляет элемент в позицию по указанному индексу. 
 E remove(int index) Удаляет элемент по указанному индексу. 
 boolean addAll(int index,  Collection<? extends E> c) Вставляет все элементы из коллекции c в позицию по указанному индексу. 
 int indexOf(Object o) Возвращает индекс элемента o либо –1, если нет элемента с таким индексом. 
 В List также присутствует метод получения итератора для списков: 
ListIterator<E> listIterator() Этот итератор наследуется от обычного итератора, но также имеет метод previous(), позволяющий вернуться к предыдущему элементу, и метод hasPrevious(), позво-ляющий проверить наличие предыдущего элемента для текущей позиции итерации. 
Вызовы next() и previous() можно чередовать, но нужно быть осторожным, т. к. 
первый вызов previous() после череды вызовов next() вернет то же значение, что и последний вызов next(), а первый вызов next() после череды previous() вернет то же значение, что и последний вызов previous(). Методы previousIndex() и nextIndex() используются для получения индекса элемента, который будет возвра-щен следующим вызовом previous() и next() соответственно. Если мы находимся в самом начале списка, т. е. следующий вызов next() вернет первый элемент, то вызов previousIndex() вернет –1. Если же мы находимся в конце списка, т. е. 
hasNext() возвращает false, то nextIndex() вернет значение list.size(). Он также имеет дополнительные методы set и add, которые позволяют заменить последний возвращенный элемент и добавить новый элемент соответственно. 
Метод subList: 
List<E> subList(int fromIndex,  int toIndex) возвращает часть списка между fromIndex (включая) и toIndex (исключая). Измене-ния в возвращаемом списке отражаются в исходном списке. Например, с помощью кода list.subList(from, to).clear() можно удалить элементы из исходного спи-ска. Поведение возвращенного списка становится непредсказуемым, если элементы в этом диапазоне будут удалены или добавлены в исходный список; все изменения нужно делать через возвращенный список, будьте внимательны. 
Глава 26. Коллекции 283 26.5. Интерфейс Queue Интерфейс java.util.Queue представляет собой очередь. 
Каждый метод в Queue существует в двух вариантах: первый бросает исключение, если операцию выполнить не удается, а второй возвращает специальное значение (null или false). Вариант, возвращающий значение, используется в основном для очередей с ограничением на количество элементов. 
Методы, бросающие исключение: 
? add(e) — добавление элемента; 
? remove() — удаление элемента; 
? element() — проверка элемента. 
Методы, возвращающие специальное значение: 
? offer(e) — добавление элемента; 
? poll() — удаление элемента; 
? peek() — проверка элемента. 
Основные реализации: java.util.LinkedList, java.util.PriorityQueue. 
Пакет java.util.concurrent содержит интерфейс java.util.concurrent.BlockingQueue, который расширяет интерфейс Queue и добавляет методы, ожидающие появления элемента при получении элемента, и методы, ожидающие появления свободного места при добавлении элемента. 
Классы, реализующие BlockingQueue: 
? java.util.concurrent.LinkedBlockingQueue; 
? java.util.concurrent.ArrayBlockingQueue; 
? java.util.concurrent.PriorityBlockingQueue; 
? java.util.concurrent.DelayQueue; 
? java.util.concurrent.SynchronousQueue; 
? java.util.concurrent.TransferQueue. 
По названию, как видно, определить тип метода невозможно. Можно либо запом-нить, либо добавить эту страницу в закладки и все время сверяться с ней. 
Методы add и offer добавляют элементы в хвост очереди. 
Методы remove() и poll() удаляют головной элемент из очереди и возвращают удаленный элемент. 
Методы element() и peek() возвращают головной элемент, но не удаляют его. 
Queue обычно реализует FIFO (first-in-first-out), но это необязательно. Некоторые реализации могут использовать очередь на основе приоритетов и другие. Некото-рые реализации ограничивают количество элементов в очереди, тогда add бросает исключение java.lang.IllegalStateException при превышении предела, а offer возвращает false. 
284 Глава 26. Коллекции Метод remove() бросает исключение java.util.NoSuchElementException, если оче-редь пуста, а метод poll() возвращает в этом случае null. 
Обычно Queue не позволяет хранить элементы со значением null, т. к. null исполь-зуется в качестве специального возвращаемого значения некоторых методов. Ис-ключением является LinkedList, который позволяет хранить null по историческим причинам. 
Реализации Queue обычно не предлагают методов hashCode() и equals(), основан-ных на элементах. Вместо этого они обычно наследуют стандартные реализации этих методов от Object. 
 26.6. Интерфейс Deque Интерфейс java.util.Deque представляет собой очередь с двумя концами, т. е. это линейная коллекция элементов с возможностью добавления и удаления элементов с обоих концов. 
ПРИМЕЧАНИЕ Deque можно использовать и в качестве очереди, и в качестве стека. 
Стандартные реализации: java.util.ArrayDeque, java.util.LinkedList. 
Специальная реализация: java.util.concurrent.LinkedBlockingDeque. 
Как и для Queue, методы существуют в двух экземплярах. 
Методы, бросающие исключение: 
? addFirst(e) — добавляет элемент в начало очереди; 
? addLast(e) — добавляет элемент в конец очереди; 
? removeFirst() — удаляет первый элемент и возвращает его; 
? removeLast() — удаляет последний элемент и возвращает его; 
? getFirst() — возвращает первый элемент; 
? getLast() — возвращает последний элемент. 
Методы, возвращающие специальное значение: 
? offerFirst(e) — добавляет элемент в начало очереди; 
? offerLast(e) — добавляет элемент в конец очереди; 
? pollFirst() — удаляет первый элемент и возвращает его; 
? pollLast() — удаляет последний элемент и возвращает его; 
? peekFirst() — возвращает первый элемент; 
? peekLast() — возвращает последний элемент. 
Глава 26. Коллекции 285 26.7. Интерфейс Map Интерфейс java.util.Map представляет собой карту/отображение/справочник — вариантов перевода много. Он отображает ключи на значения. Map не может содер-жать дублирующиеся ключи. Каждый ключ отображается не более чем на одно значение. В отличие от других интерфейсов коллекций, этот НЕ наследуется от ин-терфейса java.util.Collection. 
В платформе Java есть три стандартные реализации Map: HashMap, TreeMap, LinkedHashMap. Их производительность и особенности аналогичны реализациям Set: 
HashSet, TreeSet, LinkedHashSet. Также есть устаревший потокобезопасный Hashtable, но вместо него рекомендуется использовать реализации интерфейса ConcurrentMap. 
Есть реализации специального назначения: java.util.EnumMap, java.util.WeakHashMap, java.util.IdentityHashMap. Реализация EnumMap предназначена специально для карт со значениями перечисления одного вида в качестве ключей. WeakHashMap использу-ет слабые ссылки на свои ключи, что позволяет сборщику мусора удалить пару ключ-значение, если на них нет больше ссылок, кроме как внутри самого WeakHashMap. IdentityHashMap — реализация на основе хеш-таблицы. При сравнении ключей и значений он использует сравнение ссылок, а не сравнение объектов, в отличие от остальных реализаций. 
 V put(K key,  V value) Связывает значение value с ключом key. Возвращает предыдущее связанное значе-ние либо null. Метод также может вернуть null, если предыдущее связанное зна-чение было null (некоторые реализации карт поддерживают значения null). Используйте метод boolean containsKey(Object key), чтобы различать подобные ситуации. 
 V get(Object key) Возвращает значение, которое связано с ключом key. Возвращает null, если нет ас-социации с ключом key. Может также вернуть null, если key связан со значением null (некоторые реализации карт поддерживают значения null). Используйте метод boolean containsKey(Object key), чтобы различать подобные ситуации. 
 V remove(Object key) Удаляет связку ключ-значение для ключа key. Возвращает значение, которое было связано с этим ключом, или null, если не было связки с таким ключом. Может так-же вернуть null, если key был связан со значением null (некоторые реализации карт поддерживают значения null). Используйте метод boolean containsKey(Object key), чтобы различать подобные ситуации. 
 boolean containsKey(Object key) Возвращает true, если карта содержит связку со значением для ключа key. 
286 Глава 26. Коллекции boolean containsValue(Object value) Возвращает true, если карта содержит хотя бы одну связку со значением value. Для большинства реализаций этот метод может потребовать линейное относительно размера карты время. 
 int size() Возвращает количество связок ключ-значение в карте. 
 void putAll(Map<? extends K,? extends V> m) Копирует все связки из m в карту. 
 void clear() Удаляет все связки из карты. 
 Set<K> keySet() Возвращает Set, содержащий ключи из Map. Последующие изменения в Map отра-жаются в возвращенном Set. Удаление элемента из Set удаляет связку из Map. 
 Set<Map.Entry<K,V>> entrySet() Возвращает Set, содержащий все связки из карты. Изменения в возвращенном Set отражаются на исходном Map, так же как и изменения в исходном Map отражаются в этом Set. Этот возвращенный Set поддерживает удаление элементов, но не под-держивает добавление. 
 Collection<V> values() Возвращает коллекцию, содержащую значения из Map. Изменения в исходном Map отражаются в возвращенной коллекции и наоборот. Коллекция поддерживает уда-ление элементов, что удаляет связку из карты, но не поддерживает операции добав-ления. 
26.8. Интерфейс ConcurrentMap Интерфейс ConcurrentMap гарантирует атомарность и потокобезопасность своих методов. Он наследуется от интерфейса Map и получает все его методы. 
Одна из основных реализаций — java.util.concurrent.ConcurrentHashMap. Класс ConcurrentHashMap является основной заменой устаревшему Hashtable. 
ПРИМЕЧАНИЕ Класс ConcurrentHashMap, как и Hashtable, не поддерживают null в качестве ключа или значения. Однако в HashMap можно использовать null как в качестве ключа, так и в качестве привязанного к этому ключу значения. 
Методы получения значения из него в основном не накладывают блокировок и воз-вращают самое последнее успешно записанное значение. Методы записи не накла-Глава 26. Коллекции 287 дывают блокировку на всю коллекцию "ключ-значение", а лишь на ее часть, что обеспечивает высокий уровень параллелизма. 
В плане производительности ConcurrentHashMap лучше, чем Collections. 
synchronizedMap(myMap), т. к. второй вариант просто делает все методы synchronized. 
26.9. Класс Dictionary и его наследник Hashtable Абстрактный класс java.util.Dictionary раньше выполнял ту же роль, что сейчас выполняет интерфейс Map и ConcurrentMap. Сейчас он устарел, как и его единствен-ный наследник java.util.Hashtable. Однако Hashtable теперь реализует интерфейс Map, так что потенциально может использоваться как его реализация, но это не рекомендуется. 
26.10. Сортировка объектов Список List может быть отсортирован с помощью метода: 
Collections.sort(l); 
Если List состоит из элементов String, то они будут отсортированы в алфавитном порядке. Если он состоит из элементов Date, то список будет отсортирован в хро-нологическом порядке. Но как это происходит? String и Date реализуют интерфейс java.lang.Comparable. Реализации интерфейса java.lang.Comparable предоставляют естественный порядок сортировки для класса, который позволяет сортировать объ-екты автоматически. 
Многие стандартные классы платформы Java уже реализуют интерфейс: 
? Byte; 
? Character; 
? Long; 
? Integer; 
? Short; 
? Double; 
? Float; 
? BigInteger; 
? BigDecimal; 
? Boolean (Boolean.FALSE < Boolean.TRUE); 
? File (зависимый от системы лексикографический порядок от пути к файлу); 
? String (лексикографический без учета региональных настроек); 
? Date. 
Если вы пытаетесь сортировать список, элементы которого не реализуют интер-фейс Comparable, то Collections.sort(list) бросит исключение java.lang. 
ClassCastException. Также Collections.sort(list, comparator) бросит исключение 288 Глава 26. Коллекции java.lang.ClassCastException, если вы попытаетесь отсортировать список, элемен-ты которого не могут сравниваться посредством этого comparator-а. Элементы, ко-торые могут сравниваться друг с другом, называются взаимно сравнимыми. Не-смотря на то что элементы разных типов могут быть взаимно сравнимыми, ни один из классов, перечисленных здесь, не допускает межклассового сравнения. 
Интерфейс java.lang.Comparable состоит из следующего метода: 
public interface Comparable<T> {  public int compareTo(T o); 
} Метод compareTo сравнивает текущий объект с указанным объектом и возвращает отрицательное или положительное число либо ноль, если наш объект меньше, или больше переданного, или равен ему в параметрах соответственно. Если переданный объект не может сравниваться с нашим объектом, то метод бросает исключение java.lang.ClassCastException. 
StudentScore.java package ru.urvanov.javaindynamics2022.collection; 
 import java.util.Objects; 
 public final class StudentScore implements Comparable<StudentScore> {  private final String name; 
 private final int math; 
 private final int physics; 
 private final int philosophy; 
  public StudentScore(  String name,  int math,  int physics,  int philosophy) {  if (name == null) {  throw new NullPointerException(); 
 }  this.name = name; 
 this.math = math; 
 this.physics = physics; 
 this.philosophy = philosophy; 
 }   private double averageScore() {  return ((double) math + physics + philosophy) / 3.0; 
 }  Глава 26. Коллекции 289  @Override  public boolean equals(Object o) {  if (this == o) return true; 
 if (o == null || getClass() != o.getClass()) return false; 
 StudentScore that = (StudentScore) o; 
 return math == that.math  && physics == that.physics  && philosophy == that.philosophy  && Objects.equals(name, that.name); 
 }   @Override  public int hashCode() {  return Objects.hash(name, math, physics, philosophy); 
 }   @Override  public int compareTo(StudentScore otherStudentScore) {  if (otherStudentScore == null) {  throw new NullPointerException(); 
 }  double averageScoreThis = averageScore(); 
 double averageScoreOther = otherStudentScore.averageScore(); 
 return Double.compare(averageScoreThis, averageScoreOther); 
 }   @Override  public String toString() {  return "StudentScore{" +  "name='" + name + '\'' +  ", math=" + math +  ", physics=" + physics +  ", philosophy=" + philosophy +  '}'; 
 } }  Этот пример показывает следующее: 
? Объекты StudentScore неизменяемые. Неизменяемые объекты очень полезны, особенно при использовании объектов в качестве элементов Set или ключей Map. 
Эти коллекции будут работать некорректно, если вы будете изменять содержи-мое их элементов или ключей во время выполнения. 
? Поля, участвующие в сортировке, не могут быть null, т. к. являются примитив-ными типами, а поле name проверяется на null, поэтому никогда не возникнет java.lang.NullPointerException при использовании методов StudentScore. 
290 Глава 26. Коллекции ? Метод hashCode переопределен. Важно переопределять этот метод для любого класса, который переопределяет метод equals. (Равные объекты должны иметь одинаковые хеш-коды.) ? Метод equals возвращает false, если переданный объект равен null или отно-сится к неподходящему типу. Метод compareTo бросает исключение в подобных ситуациях. Оба этих поведения требуются согласно контракту этих методов. 
? Метод toString переопределен так, чтобы он выводил объект StudentScore в по-нятном для человека формате. Старайтесь всегда переопределять метод toString, особенно если объекты планируется помещать в коллекции. Многие коллекции имеют toString, использующий методы toString у своих элементов, ключей и значений. 
? Метод compareTo объекта StudentScore реализует сортировку по среднему баллу. 
Пример программы, создающей массив элементов класса StudentScore и сорти-рующей их: 
StudentSort.java package ru.urvanov.javaindynamics2022.collection; 
 import java.util.Arrays; 
import java.util.Collections; 
import java.util.List; 
 public class StudentSort {  public static void main(String[] args) {  StudentScore[] studentScoreArray = new StudentScore[] {  new StudentScore("Mary", 2, 5, 1),  new StudentScore("John", 5, 5, 5),  new StudentScore("Tom", 2, 2, 2)  }; 
 List<StudentScore> studentScoreList  = Arrays.asList(studentScoreArray); 
 Collections.sort(studentScoreList); 
 System.out.println(studentScoreList); 
 } }  Если запустить эту программу, то она выведет в консоль: 
[StudentScore{name='Tom', math=2, physics=2, philosophy=2}, StudentScore{name='Mary', math=2, physics=5, philosophy=1}, StudentScore{name='John', math=5, physics=5, philosophy=5}] Метод compareTo должен следовать четырем важным правилам (здесь sgn(expression) означает знак выражения): 
Глава 26. Коллекции 291 ? Для всех x и y должно выполняться равенство sgn(x.compareTo(y)) == -sgn(y.compareTo(x)). (Если x.compareTo(y) бросает исключение, то y.compareTo(x) также должно бросать исключение.) ? Сравнение должно быть транзитивным (x.compareTo(y)>0 && y.compareTo(z)>0 означает, что x.compareTo(z)>0). 
? x.compareTo(y)==0 означает, что sgn(x.compareTo(z)) == sgn(y.compareTo(z)) для любых z. 
? Очень рекомендуется, чтобы (x.compareTo(y)==0) == (x.equals(y)), т. е. 
compareTo не должен работать вразнобой с equals. 
При необходимости сортировать объекты в отличном от естественного порядке, нужно использовать интерфейс java.util.Comparator: 
public interface Comparator<T> {  int compare(T o1, T o2); 
} Метод compare сравнивает два аргумента, возвращая отрицательное или положи-тельное число либо ноль, если первый аргумент меньше или больше второго либо равен ему соответственно. Если типы переданных аргументов не подходят для это-го Comparator-а, то метод compare бросает исключение java.lang.ClassCastException. 
Большая часть сказанного про java.lang.Comparable относится и к java.util. 
Comparator. Метод compare должен придерживаться тех же четырех правил, что и метод compareTo у Comparable. 
Предположим, что у нас есть класс LadyMidday: 
LadyMidday.java package ru.urvanov.javaindynamics2022.collection; 
 public class LadyMidday implements Comparable<LadyMidday> {  private String name; 
 private int level; 
 private int money; 
 ... 
}  Давайте предположим, что естественный порядок сортировки экземпляров LadyMidday — это их сортировка по level (уровню монстра). К сожалению, требует-ся вывести их по имени. Это означает, что нам нужно сделать немного дополни-тельной работы: 
LadyMiddaySort.java package ru.urvanov.javaindynamics2022.collection; 
 import java.util.*; 
292 Глава 26. Коллекции public class LadyMiddaySort {  static final Comparator<LadyMidday> NAME_ORDER  = (o1, o2) -> {  return o1.getName().compareTo(o2.getName()); 
 }; 
  public static void main(String[] args) {  LadyMidday[] ladyMiddayArray = {  new LadyMidday("Monster1", 10, 3),  new LadyMidday("Midday killer", 34, 300),  new LadyMidday("poor", 99, 10),  }; 
 List<LadyMidday> ladyMiddays = Arrays.asList(ladyMiddayArray); 
 Collections.sort(ladyMiddays, NAME_ORDER); 
 System.out.println(ladyMiddays); 
 } }  При написании компараторов нужно быть аккуратным. Если нужно получить обратный порядок, чтобы вначале шло большее значение, а затем меньшее, то НЕЛЬЗЯ сначала вычислить значение compareTo для обычного порядка, а затем применить к нему знак "минус". Есть одно отрицательное значение для int, которое остается отрицательным, если к нему применять унарный минус: 
-Integer.MIN_VALUE == Integer.MIN_VALUE Comparator, который мы написали выше, может сортировать List, но он не может использоваться в сортированных коллекциях, например TreeSet, т. к. он генерирует порядок сортировки, несовместимый с equals. Это означает, что этот Comparator указывает равными те объекты, которые методы equals указывают как разные. На-пример, две LadyMidday с одинаковыми именами будут равны. При сортировке в списке List это не имеет значения, но при использовании Comparator-а для упоря-доченной коллекции это будет не очень хорошо. Если вы будете использовать этот Comparator в TreeSet, то TreeSet будет работать, как ожидается, но при этом будет нарушена договоренность о самом интерфейcе Set, потому что он спроектирован именно на основе метода equals. 
Если нужно чтобы TreeSet с вашим компаратором работал в соответствии с мето-дом equals, как и ожидается, то нужно писать компаратор таким образом, чтобы он считал отличающимися объекты, считающиеся отличающимися с точки зрения equals, и равными те, которые равны с точки зрения equals

## Глава 26. Коллекции

### 26.1. Введение
Все коллекции в Java реализуют какой-либо основной интерфейс. Списки реализуют интерфейс `java.util.List`, множества — `java.util.Set` или `java.util.SortedSet` и т.д. На сайте [urvanov.ru](https://urvanov.ru) представлена диаграмма интерфейсов для Java Collections Framework, которая может помочь в понимании этой главы.

### 26.2. Интерфейс Collection
Интерфейс `java.util.Collection` содержит общие свойства всех коллекций и используется как параметр в методах, принимающих любой тип коллекций. Например, все коллекции имеют конструктор, принимающий `Collection` в качестве параметра, что позволяет конвертировать один тип коллекций в другой.

Пример создания нового экземпляра `ArrayList` из `Collection<String> c`:
```java
List<String> list = new ArrayList<>(c);
```

Методы интерфейса `Collection`:
- `int size()` — возвращает количество элементов.
- `boolean isEmpty()` — возвращает true, если коллекция пуста.
- `boolean contains(Object element)` — возвращает true, если элемент присутствует.
- `boolean add(E element)` — добавляет элемент; возвращает true, если добавлен.
- `boolean remove(Object element)` — удаляет элемент; возвращает true, если удален.
- `Iterator<E> iterator()` — возвращает итератор для прохода по элементам.

Методы для работы с целыми коллекциями:
- `boolean containsAll(Collection<?> c)`
- `boolean addAll(Collection<? extends E> c)`
- `boolean removeAll(Collection<?> c)`
- `boolean retainAll(Collection<?> c)`
- `void clear()`

Методы для преобразования коллекции в массив:
```java
Object[] toArray();
<T> T[] toArray(T[] a);
```

### 26.3. Интерфейс Set
`java.util.Set` — это коллекция уникальных элементов, содержащая методы от `java.util.Collection`. Платформа Java предоставляет три реализации: 
- `java.util.HashSet`
- `java.util.TreeSet`
- `java.util.LinkedHashSet`

### 26.4. Интерфейс List
Интерфейс `java.util.List` представляет собой упорядоченную коллекцию элементов. Реализации включают:
- `java.util.ArrayList`
- `java.util.LinkedList`
- Специальная реализация: `java.util.concurrent.CopyOnWriteArrayList`

Методы для работы с позициями элементов:
- `E get(int index)`
- `E set(int index, E element)`
- `void add(int index, E element)`
- `E remove(int index)`

### 26.5. Интерфейс Queue
Интерфейс `java.util.Queue` представляет собой очередь с двумя вариантами методов: бросающие исключение и возвращающие специальное значение.

Основные реализации:
- `java.util.LinkedList`
- `java.util.PriorityQueue`

### 26.6. Интерфейс Deque
Интерфейс `java.util.Deque` представляет собой очередь с двумя концами и может использоваться как очередь или стек.

### 26.7. Интерфейс Map
Интерфейс `java.util.Map` представляет собой отображение ключей на значения и не может содержать дублирующиеся ключи. Основные реализации:
- `HashMap`
- `TreeMap`
- `LinkedHashMap`

### 26.8. Интерфейс ConcurrentMap
Гарантирует атомарность и потокобезопасность методов.

### 26.9. Класс Dictionary и его наследник Hashtable
Устаревший класс, который выполнял ту же роль, что и интерфейсы Map и ConcurrentMap.

### 26.10. Сортировка объектов
Список можно отсортировать с помощью метода:
```java
Collections.sort(list);
```
Для сортировки необходимо, чтобы элементы реализовывали интерфейс Comparable.

Объекты должны следовать правилам сравнения для корректной работы методов сортировки и equals.

Цитаты:
[1] Java | Типы коллекций. Интерфейс Collection https://metanit.com/java/tutorial/5.1.php
[2] Коротко о главном — Java Collections Framework https://javarush.com/groups/posts/2308-korotko-o-glavnom---java-collections-framework
[3] Справочник по Java Collections Framework / Хабр https://habr.com/ru/articles/237043/
[4] Ответы на вопросы на собеседование Java Collections ... https://jsehelper.blogspot.com/2016/01/java-collections-framework-1.html
[5] Java collection. Basics https://habr.com/ru/sandbox/166787/
[6] Уровень 26. Ответы на вопросы к собеседованию по ... https://javarush.com/groups/posts/1580-urovenjh-26-otvetih-na-voprosih-k-sobesedovaniju-po-teme-urovnja-chastjh-1-voprosih-1-5-10
[7] Лекция: Java Collections Framework https://javarush.com/quests/lectures/jru.module1.lecture18
[8] Введение в коллекции Java / Хабр https://habr.com/ru/articles/794178/
[9] Java Collection Framework: Полное руководство для ... https://struchkov.dev/blog/ru/java-collection-framework/

By Perplexity at https://www.perplexity.ai/search/7ec6d154-cc4b-4f42-aa37-69f50b7942cd?s=m