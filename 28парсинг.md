отформатируй текст: ГЛАВА 28  Форматирование и парсинг 28.1. Введение В мире огромное количество различных языков, религий, культур и стран. В каж-дой стране и в каждом языке зачастую приняты свои формы записи чисел, дат и денежных единиц. Локализация приложения в конкретной стране — это далеко не самый тривиальный процесс, подразумевающий не только перевод на язык страны, но и запись чисел и дат в формате, принятом в этой стране, удаление иконок и изо-бражений, нарушающих законодательство этой страны и т. д. 
Locale locale = Locale.getDefault()   Например, в русском языке принята следующая запись дат: 
12.01.2016 — двенадцатое января две тысячи шестнадцатого года; 
10 июня 2016 — 10 июня 2016 года. 
Но если мы локализуем приложение в США, то даты будут выглядеть так: 
01/12/2016 — the twelfth of January year twenty sixteen; 
June 10, 2016 — the tenth of June year twenty sixteen. 
С записью чисел тоже все далеко не так просто. Вот числа для русского языка: 
10 000 000,34; 
3 454,456. 
А вот те же числа для США: 
10,000,000.34; 
3,454.456. 
Все современные языки поддерживают конвертацию дат и числовых переменных в строку и обратно в соответствии с указанными региональными настройками (локалью) или региональными настройками по умолчанию. 
Для понимания дальнейшего текста главы рекомендуется ознакомиться с классом java.util.Locale, представляющим собой локаль (региональные настройки). 
Вы можете получить экземпляр текущей локали с помощью кода: 
Глава 28. Форматирование и парсинг 323 28.2. Класс NumberFormat Класс java.text.NumberFormat предназначен для форматирования и парсинга чисел. 
Это абстрактный класс, экземпляры которого можно получить с помощью методов getInstance(): 
public static final NumberFormat getInstance() public static NumberFormat getInstance(Locale inLocale) Полученный экземпляр NumberFormat можно использовать для форматирования чисел с помощью метода format и парсинга чисел с помощью метода parse: 
public final String format(double number)  public final String format(long number)  public Number parse(String source)  throws ParseException Пример: 
String str1 = java.text.NumberFormat.getInstance()  .format(10_000_000.34); 
String str2 = java.text.NumberFormat.getInstance().format(8000); 
String str3 = java.text.NumberFormat.getInstance()  .format(new java.math.BigDecimal("34000.56")); 
System.out.println(str1); 
System.out.println(str2); 
System.out.println(str3); 
try {  Number var1 = java.text.NumberFormat.getInstance().parse(str1); 
 Number var2 = java.text.NumberFormat.getInstance().parse(str2); 
 Number var3 = java.text.NumberFormat.getInstance().parse(str3); 
 System.out.println(var1); 
 System.out.println(var2); 
 System.out.println(var3); 
} catch (java.text.ParseException pe) {  pe.printStackTrace(); 
} Результат: 
10 000 000,34 8 000 34 000,56 1.000000034E7 8000 34000.56 324 Глава 28. Форматирование и парсинг 28.3. Класс DecimalFormat Класс java.text.DecimalFormat расширяет класс java.text.NumberFormat. Класс DecimalFormat предназначен специально для работы с десятичными числами. Он поддерживает различные типы чисел: проценты, денежные единицы и т. д. 
Все методы format и parse, а также способ создания аналогичны NumberFormat. 
Класс DecimalFormat дополнительно содержит настройку: 
public void setParseBigDecimal(boolean newValue) позволяющую методу parse возвращать экземпляры BigDecimal. 
Класс java.text.DecimalFormat содержит два дополнительных конструктора, при-нимающих строку с форматом числа: 
public DecimalFormat(String pattern)  public DecimalFormat(String pattern,  DecimalFormatSymbols symbols) Метод, принимающий DecimalFormatSymbols, позволяет полностью настроить фор-матирование числа. Строка pattern содержит шаблон вида "0.00" и может содер-жать следующие специальные символы (табл. 28.1). 
Таблица 28.1. Значения символов Специальный символ Значение 0 Число # Число, незначащие нули не показываются . (символ точки) Разделитель дробной и целой части - Знак "минус" , Разделитель групп E Разделяет мантиссу и экспоненту в научной записи. В префиксе или в суффиксе нужно заключать в кавычки ; Разделяет положительный шаблон числа и отрицательный шаблон числа % Умножается на 100 и показывается в процентах \u2030 Умножается на 1000 и показывается как в милях ¤ (\u00A4) Денежный знак. Заменяется денежным символом локали. Если задвоен, то указывается международный денежный символ. Если указан, то используется разделитель денег вместо разделителя дробной и целой части ' Кавычки. "'#'#" преобразует 123 в "#123" . Чтобы записать саму одинарную кавычку, используйте две одинарные кавычки  Пример: 
System.out.println(new java.text.DecimalFormat("0000.000").format(10)); 
Глава 28. Форматирование и парсинг 325 Результат: 
0010,000 28.4. Класс DateFormat Класс java.text.DateFormat предназначен для форматирования дат. Получить экземпляр этого класса можно с помощью одного из методов: 
public static final DateFormat getInstance() Если нужно форматировать/парсить только дату без времени, то можно использо-вать один из следующих методов: 
public static final DateFormat getDateInstance()  public static final DateFormat getDateInstance(int style)  public static final DateFormat getDateInstance(int style,  Locale aLocale) Здесь style может быть одно из значений: DateFormat.FULL, DateFormat.LONG, DateFormat.SHORT, DateFormat.MEDIUM, DateFormat.DEFAULT. 
Если нужно форматировать/парсить только время, то можно использовать один из методов: 
public static final DateFormat getTimeInstance()  public static final DateFormat getTimeInstance(int style)  public static final DateFormat getTimeInstance(int style,  Locale aLocale) Здесь style может быть одно из значений: DateFormat.FULL, DateFormat.LONG, DateFormat.SHORT, DateFormat.MEDIUM, DateFormat.DEFAULT. 
Если нужно форматировать/парсить дату с временем, то можно использовать один из методов: 
public static final DateFormat getDateTimeInstance()  public static final DateFormat getDateTimeInstance(int dateStyle,  int timeStyle)  public static final DateFormat getDateTimeInstance(int dateStyle,  int timeStyle,  Locale aLocale) Форматирование и парсинг также происходят с помощью методов format и parse. 
Пример: 
System.out.println(java.text.DateFormat.getInstance()  .format(new java.util.Date()); 
326 Глава 28. Форматирование и парсинг 28.5. Класс DateTimeFormatter Класс java.time.format.DateTimeFormatter используется совместно с классами даты и времени из пакета java.time. Он был подробно описан в главе 27 "Дата и время". 
28.6. Класс SimpleDateFormat Класс java.text.SimpleDateFormat наследуется от java.text.DateFormat и позволяет указать пользовательский шаблон форматирования. 
Конструкторы: 
public SimpleDateFormat(String pattern)  public SimpleDateFormat(String pattern,  Locale locale)  public SimpleDateFormat(String pattern,  DateFormatSymbols formatSymbols) Конструктор с DateFormatSymbols позволяет создать форматировщик, используя особые правила. 
Шаблон pattern может содержать следующие специальные символы, приведенные в табл. 28.2. 
Таблица 28.2. Значения символов Буква Компонент даты и времени Представление Примеры G Эра Text AD y Год Year 1996; 96 Y Год Year 2009; 09 M Месяц в году (зависит от контекста) Month July; Jul; 07 L Месяц в году (самостоятельная форма) Month July; Jul; 07 w Неделя в году Number 27 W Неделя в месяце Number 2 D День в году Number 189 d День в месяце Number 10 F День недели в месяце Number 2 E Название дня недели Text Tuesday; Tue u Номер дня недели (1 = Понедельник, ..., 7 = Воскресенье) Number 1 a am/pm Text PM H Час в дне (0-23) Number 0 Глава 28. Форматирование и парсинг 327 Таблица 28.2 (окончание) Буква Компонент даты и времени Представление Примеры k Час в дне (1–24) Number 24 K Час в дне am/pm (0–11) Number 0 h Час в дне am/pm (1–12) Number 12 m Минуты Number 30 S Секунды Number 55 S Миллисекунды Number 978 z Часовой пояс General time zone Pacific Standard Time; 
PST; GMT-08:00 Z Часовой пояс RFC 822 time zone -0800 X Часовой пояс ISO 8601 time zone -08; -0800; -08:00  Описание столбца "Представление": 
? Text: если в шаблоне 4 буквы или более, то используется полная форма, в про-тивном случае — сокращенная. При парсинге принимаются обе формы, незави-симо от количества букв в шаблоне. 
? Number: количество букв в шаблоне — это минимальное количество цифр, более короткие числа добиваются нулями. При парсинге количество букв игно-рируется, если только оно не требуется для разделения соседних полей. 
? Year: если Calendar форматировщика является григорианским календарем, то применяются следующие правила. При форматировании, если количество букв равно двум, год усекается до двух цифр, в противном случае интерпретируется как число. При парсинге, если количество букв больше двух, год интерпретиру-ется буквально, независимо от количества цифр. Поэтому при использовании шаблона "MM/dd/yyyy" и строки "01/11/12" получается 11 января 12 года нашей эры. При парсинге с сокращенной формой года ("y" или "yy") SimpleDateFormat интерпретирует сокращенный год относительно какого-либо века. Он выравни-вает даты так, чтобы они были в диапазоне от 80 лет до даты создания SimpleDateFormat и до 20 лет после даты создания SimpleDateFormat. Во время парсинга только строки, состоящие строго из двух цифр, интерпретируются в текущий век. Любые другие числовые строки, состоящие из одной цифры или трех и более, интерпретируются как полный год. 
? Month: если количество букв в шаблоне равно 3 или более, то месяц интерпре-тируется как текст, в противном случае интерпретируется как число. Буква M создает имена месяцев, зависимые от контекста. Если в конструктор был пере-дан DateFormatSymbols или был использован метод setDateFormatSymbols, то име-на месяцев берутся из DateFormatSymbols. Буква L создает самостоятельную фор-му имен месяцев. 
328 Глава 28. Форматирование и парсинг ? General time zone: часовые пояса интерпретируются по текстовым именам. При использовании смещения часовой пояс указывается в виде GMT +01:30 или GMT-12:33. 
? RFC 822 time zone: используются четыре цифры: -0800 или +1200. 
? ISO 8601 time zone: используются две цифры, четыре цифры или с разделением часов и минут двоеточием: -08; -0800; -08:00. 
28.7. Класс PrintStream Класс java.io.PrintStream позволяет писать форматированные данные в любой по-ток. Вам вряд ли когда-нибудь придется создавать экземпляры этого класса вруч-ную, гораздо чаще вы будете использовать готовые классы, вроде возвращаемых System.out. PrintStream имеет методы print и println, перегруженные для любого примитивного типа и для класса Object (в этом случае используется его метод toString()). 
Класс PrintStream никогда не бросает IOException, вместо этого он устанавливает свой внутренний флаг, который может быть проверен с помощью метода public boolean checkError(). 
Особого внимания заслуживают методы: 
public PrintStream format(String format,  Object... args)  public PrintStream format(Locale l,  String format,  Object... args)  public PrintStream printf(Locale l,  String format,  Object... args)  public PrintStream printf(String format,  Object... args) Эти методы позволяют писать в поток форматированные данные. Здесь format — это шаблон строки, который подробно описывается в разделе 28.8 "Класс Formatter". 
28.8. Класс Formatter Класс java.util.Formatter используется во всех методах, принимающих строку форматирования: java.io.PrintStream.format, System.out.format, String.format и т. д. 
Каждый метод, принимающий строку форматирования, нуждается в шаблоне и списке аргументов. Пример: 
Глава 28. Форматирование и парсинг 329 FormatterExample.java Calendar c = Calendar.getInstance(); 
c.set(2000, Calendar.FEBRUARY, 12, 10,0, 0); 
String s = String.format("Джонни родился: %1$te.%1$tm.%1$tY", c); 
System.out.println(s); 
 Строка форматирования является первым аргументом метода format. Она содержит три спецификатора формата: "%1$tm", "%1$te" и "%1$tY", которые указывают на спо-соб обработки аргументов и на то, как они будут вставлены в текст. Остальные час-ти строки содержат фиксированный текст, включающий в себя "Джонни родился: " и любые другие пробелы и знаки препинания. Список аргументов состоит из всех аргументов, переданных в метод после строки форматирования. В примере выше список аргументов содержит только один объект java.util.Calendar. 
Спецификаторы формата для общих, символьных и числовых типов имеют сле-дующий синтаксис: 
%[argument_index$][flags][width][.precision]conversion Необязательный argument_index показывает позицию аргумента в списке. К перво-му аргументу ссылаются "1$", ко второму — "2$", нумерация аргументов начинает-ся с единицы. 
? Необязательный flags — это набор символов, модифицирующих выходной формат. Допустимый набор символов зависит от conversion. 
? Необязательный width — это положительное десятичное число, указывающее минимальное количество символов, которое будет записано в выходную строку. 
? Необязательный precision — это неотрицательное десятичное число, обычно используемое для ограничения количества символов. Поведение precision зави-сит от conversion. 
? Обязательное conversion — это символ, указывающий на способ форматирова-ния аргумента. Допустимый набор символов зависит от типа аргумента. 
Спецификаторы форматов, используемые для дат и времени, имеют следующий синтаксис: 
%[flags][width]conversion Бывают следующие виды conversion: 
? General — может быть применен к любому типу аргумента. 
? Character — может быть применен к базовым типам, представляющим символы Юникода: char, Character, byte, Byte, short, Short. Этот тип conversion может быть также применен к типам int и Integer, если Character. 
isValidCodePoint(int) возвращает true. 
? Integral — может быть применен к любому целочисленному типу Java: byte, Byte, short, Short, int, Integer, long, Long, BigInteger (но не к char или Character). 
330 Глава 28. Форматирование и парсинг ? Floating point — может быть применен к типам с плавающей точкой: float, Float, double, Double и BigDecimal. 
? Date/Time — применяется к типам Java, которые могут содержать дату или вре-мя: long, Long, Calendar, Date или TemporalAccessor. 
? Percent — создает литеру '%' ('\u0025'). 
? Line separator — специфичный для платформы разделитель строк. 
Следующая таблица (табл. 28.3) содержит поддерживаемые conversion. Заглавные буквы имеют то же значение, что и прописные, но результат преобразуется в верх-нем регистре с помощью String.toUpperCase(). 
Таблица 28.3. Результаты форматирования Conversion Категория аргумента Описание 'b', 'B' general Если аргумент null, то результат false. Если аргумент boolean или Boolean, то результатом будет результат вызова String.valueOf(arg). В противном случае результат "true" 'h', 'H' general Если аргумент null, то результатом будет "null". 
В противном случае результат получается вызовом Integer.toHexString(arg.hashCode()) 's', 'S' general Если аргумент null, то результат "null". Если аргумент реализует интерфейс java.util.Formattable, то вызывается метод arg.formatTo. В противном случае результат получается вызовом arg.toString() 'c', 'C' character Результатом будет символ Юникода 'd' integral Результат форматируется как десятичное целое 'o' integral Результат форматируется как восьмеричное целое 'x', 'X' integral Результат форматируется как шестнадцатеричное целое 'e', 'E' floating point Результат форматируется как десятичное число в научной записи 'f' floating point Результат форматируется как десятичное число 'g', 'G' floating point Результат форматируется, используя научную запись или десятичный формат, в зависимости от точности и значения после округления 'a', 'A' floating point Результат форматируется в шестнадцатеричное число с плавающей точкой, мантиссой и показателем степени. 
Не поддерживается для java.math.BigDecimal 't', 'T' date/time Префикс для даты и времени '%' percent Результатом будет символ '%' ('\u0025') 'n' line separator Разделитель линий, принятый в текущей платформе  Следующие символы используются в качестве суффиксов к 't' и 'T' и применяются для дат и времени (табл. 28.4). 
Глава 28. Форматирование и парсинг 331 Таблица 28.4. Значения символов 'H' Час в 24-часовом дне. Форматируется как две цифры с предваряющим нулем, если нужно, т. е. 00–23 'I' Час от единицы до двенадцати. Форматируется как две цифры с предваряющим нулем, если нужно, т. е. 01–12 'k' Час в 24-часовом дне, 0–23 'l' Час от единицы до двенадцати, 1–12 'M' Минуты в часе. Форматируются как две цифры с предваряющим нулем, если нужно, т. е. 00–59 'S' Секунды в минуте, форматируются как две цифры с предваряющим нулем, если нужно, т. е. 00–60 ("60" — специальное значение, необходимое для поддержки секунды координации) 'L' Миллисекунды в секунде. Форматируются как три цифры с предваряющими нулями, если нужно, т. е. 000–999 'N' Наносекунды в секунде. Форматируются как девять цифр с предваряющими нулями, если нужно, т. е. 000000000–999999999 'p' До обеда или после обеда ("am" или "pm"). Используйте префикс 'T', чтобы результат был в верхнем регистре 'z' RFC 822 смещение часовой зоны от GMT, например –0800. Это значение выравнива-ется для учета перехода на зимнее/летнее время. Для long, Long, Date используется часовой пояс по умолчанию для текущего экземпляра виртуальной машины Java 'Z' Строка, содержащая аббревиатуру часового пояса. Это значение выравнивается, чтобы учесть переход на зимнее/летнее время. Для long, Long, Date используется часовой пояс по умолчанию для текущего экземпляра виртуальной машины Java 's' Секунды с начала эпохи от 1 января 1970 года 00:00:00 UTC. От Long.MIN_VALUE/1000 до Long.MAX_VALUE/1000 'Q' Миллисекунды с начала эпохи 1 января 1970 года 00:00:00 UTC. От Long.MIN_VALUE до Long.MAX_VALUE  Символы для форматирования дат — табл. 28.5. 
Таблица 28.5. Значения символов 'B' Полное имя месяца в соответствии с региональными настройками, например "январь", "февраль", "January", "February" 'b' Сокращенное имя месяца в соответствии с региональными настройками, например "янв", "фев", "Jan", "Feb" 'h' То же, что и 'b' 'A' Полное имя дня недели в соответствии с региональными настройками, например "воскресенье", "понедельник", "Sunday", "Monday" 'a' Короткое название дня недели в соответствии с региональными настройками, например, "Пн", "Вт", "Sun", "Mon" 'C' Четыре цифры года, поделенные на 100 и форматированные как две цифры с предваряющим нулем, если нужно, т. е. 00–99 332 Глава 28. Форматирование и парсинг Таблица 28.5 (окончание) 'Y' Год, форматированный как минимум четырьмя цифрами с предваряющим нулем, если нужно, т. е. 0092 равен 92 CE для григорианского календаря 'y' Последние две цифры года, форматированные с предваряющим нулем, если необходимо, т. е. 00–99 'j' День года, форматированный как три цифры с предваряющими нулями, если необходимо, т. е. 001–366 для григорианского календаря 'm' Месяц, форматированный двумя цифрами с предваряющим нулем, если необходимо, т. е. 01–13 'd' День месяца, форматированный как две цифры с предваряющими нулями, если необходимо, т. е. 01–31 'e' День в месяце, форматированный как две цифры, т. е. 1–31  Символы для форматирования наиболее часто используемых сочетаний дат и вре-мени см. в табл. 28.6. 
Таблица 28.6. Значения символов 'R' Время 24-часовой день "%tH:%tM" 'T' Время в формате "%tH:%tM:%tS" 'r' Время в формате "%tI:%tM:%tS %Tp" 'D' Дата в формате "%tm/%td/%ty" 'F' ISO 8601 форматированная дата "%tY-%tm-%td" 'c' Дата и время в формате "%ta %tb %td %tT %tZ %tY"  Поддерживаемые флаги — табл. 28.7. 
Таблица 28.7. Флаги Флаг General Character Integral Floating Point Date/Time Описание '-' Да Да Да Да Да Результат будет выровнен по левому краю '#' Да(1) Нет Да(3) Да Нет Результат должен использо-вать альтернативную форму, зависимую от conversion '+' Нет Нет Да(4) Да Нет Результат всегда будет содержать знак ' ' Нет Нет Да(4) Да Нет Результат будет содержать лидирующий пробел для положительных значений '0' Нет Нет Да Да Нет Результат будет выровнен нулями Глава 28. Форматирование и парсинг 333 Таблица 28.7 (окончание) Флаг General Character Integral Floating Point Date/Time Описание ',' Нет Нет Да(2) Да(5) Нет Результат будет содержать разделители групп указанной локали '(' Нет Нет Да(4) Да(5) Нет Результат будет заключать отрицательные значения в скобки  1 — зависит от определения Formattable. 
2 — только для conversion 'd'. 
3 — только для conversion 'o', 'x' и 'X'. 
4 — для conversion 'd', 'o', 'x' и 'X', примененных к java.math.BigInteger, или 'd', примененной к byte, Byte, short, Short, int, Integer, long, Long. 
5 — только для conversion 'e', 'E', 'f' , 'g' и 'G'. 
 width указывает минимальное количество символов, которые будут записаны в вы-ходную строку. Для разделителя линий width не применяется. 
precision указывает максимальное количество символов, которые будут записаны в выходную строку. Для conversion 'a', 'A', 'e', 'E', 'f' precision — количество симво-лов после точки. Если conversion равен 'g' или 'G', то precision указывает общее количество значимых чисел после округления. Для character, integral, date/time, percent, line separator этот параметр не указывается. 
argument index — десятичное число, указывающее позицию аргумента в списке аргументов. Первый аргумент "1$", второй — "2$" и т. д. Можно использовать флаг '<' ('\u003c'), который использует еще раз предыдущий аргумент. 
28.9. Класс Scanner Класс java.util.Scanner предназначен для разбиения форматированного ввода на токены и конвертирования токенов в соответствующий тип данных. 
По умолчанию сканер использует пробельные символы (пробелы, табуляторы, раз-делители линий) для разделения токенов. Рассмотрите следующий код: 
ScannerExample.java package ru.urvanov.javaindynamics2022.formatparse; 
import java.io.*; 
import java.nio.charset.StandardCharsets; 
import java.util.Scanner; 
 public class ScannerExample {  public static void main(String[] args) throws IOException { 334 Глава 28. Форматирование и парсинг  Scanner s = null; 
  try {  s = new Scanner(new BufferedReader(  new FileReader(  "scanner-data.txt",  StandardCharsets.UTF_8))); 
  while (s.hasNext()) {  System.out.println(s.next()); 
 }  } finally {  if (s != null) {  s.close(); 
 }  }  } }  Если файл scanner-data.txt содержит следующий текст: 
scanner-data.txt За ужином объелся я, А Яков запер дверь оплошно - Так было мне, мои друзья, И кюхельбекерно и тошно. 
 То результатом работы программы будет вывод: 
За ужином объелся я, А Яков запер дверь оплошно - Так было мне, мои друзья, И кюхельбекерно и тошно. 
Глава 28. Форматирование и парсинг 335 Чтобы использовать другой разделитель токенов, примените метод useDelimiter, в который передается регулярное выражение. Например, предположим, что мы хотим использовать в качестве разделителя запятую, после которой может идти, а может не идти пробел: 
s.useDelimiter(",\\s*"); 
Класс java.util.Scanner поддерживает все примитивные типы Java, java.math. 
BigInteger и java.math.BigDecimal. Scanner использует экземпляр java.util.Locale для преобразования строк в эти типы данных. 
Пример: 
ScannerNumber.java package ru.urvanov.javaindynamics2022.formatparse; 
 import java.util.Scanner; 
 public class ScannerNumber {  public static void main(String[] args) {  Scanner scanner = new Scanner(System.in); 
 // Ожидаем ввод с консоли сначала числа,  // а затем вещественного числа  int i = scanner.nextInt(); 
 double d = scanner.nextDouble(); 
 } }

## ГЛАВА 28. Форматирование и парсинг

### 28.1. Введение

В мире огромное количество различных языков, религий, культур и стран. В каждой стране и в каждом языке зачастую приняты свои формы записи чисел, дат и денежных единиц. Локализация приложения в конкретной стране — это далеко не самый тривиальный процесс, подразумевающий не только перевод на язык страны, но и запись чисел и дат в формате, принятом в этой стране, удаление иконок и изображений, нарушающих законодательство этой страны и т. д.

```java
Locale locale = Locale.getDefault();
```

Например, в русском языке принята следующая запись дат:
- **12.01.2016** — двенадцатое января две тысячи шестнадцатого года;
- **10 июня 2016** — 10 июня 2016 года.

Но если мы локализуем приложение в США, то даты будут выглядеть так:
- **01/12/2016** — the twelfth of January year twenty sixteen;
- **June 10, 2016** — the tenth of June year twenty sixteen.

С записью чисел тоже все далеко не так просто. Вот числа для русского языка:
- **10 000 000,34**;
- **3 454,456**.

А вот те же числа для США:
- **10,000,000.34**;
- **3,454.456**.

Все современные языки поддерживают конвертацию дат и числовых переменных в строку и обратно в соответствии с указанными региональными настройками (локалью) или региональными настройками по умолчанию. Для понимания дальнейшего текста главы рекомендуется ознакомиться с классом `java.util.Locale`, представляющим собой локаль (региональные настройки).

Вы можете получить экземпляр текущей локали с помощью кода:

```java
Locale locale = Locale.getDefault();
```

### 28.2. Класс NumberFormat

Класс `java.text.NumberFormat` предназначен для форматирования и парсинга чисел. Это абстрактный класс, экземпляры которого можно получить с помощью методов `getInstance()`:

```java
public static final NumberFormat getInstance();
public static NumberFormat getInstance(Locale inLocale);
```

Полученный экземпляр `NumberFormat` можно использовать для форматирования чисел с помощью метода `format` и парсинга чисел с помощью метода `parse`:

```java
public final String format(double number);
public final String format(long number);
public Number parse(String source) throws ParseException;
```

Пример:

```java
String str1 = java.text.NumberFormat.getInstance().format(10_000_000.34);
String str2 = java.text.NumberFormat.getInstance().format(8000);
String str3 = java.text.NumberFormat.getInstance().format(new java.math.BigDecimal("34000.56"));

System.out.println(str1);
System.out.println(str2);
System.out.println(str3);

try {
    Number var1 = java.text.NumberFormat.getInstance().parse(str1);
    Number var2 = java.text.NumberFormat.getInstance().parse(str2);
    Number var3 = java.text.NumberFormat.getInstance().parse(str3);
    
    System.out.println(var1);
    System.out.println(var2);
    System.out.println(var3);
} catch (java.text.ParseException pe) {
    pe.printStackTrace();
}
```

Результат:
```
10 000 000,34
8 000
34 000,56
1.000000034E7
8000
34000.56
```

### 28.3. Класс DecimalFormat

Класс `java.text.DecimalFormat` расширяет класс `java.text.NumberFormat`. Он предназначен специально для работы с десятичными числами и поддерживает различные типы чисел: проценты, денежные единицы и т. д.

Все методы `format` и `parse`, а также способ создания аналогичны `NumberFormat`. Класс `DecimalFormat` дополнительно содержит настройку:

```java
public void setParseBigDecimal(boolean newValue);
```

Класс `java.text.DecimalFormat` содержит два дополнительных конструктора, принимающих строку с форматом числа:

```java
public DecimalFormat(String pattern);
public DecimalFormat(String pattern, DecimalFormatSymbols symbols);
```

Метод, принимающий `DecimalFormatSymbols`, позволяет полностью настроить форматирование числа. Строка `pattern` содержит шаблон вида "0.00" и может содержать следующие специальные символы (табл. 28.1).

#### Таблица 28.1. Значения символов

| Специальный символ | Значение |
|--------------------|----------|
| 0                  | Число   |
| #                  | Число, незначащие нули не показываются |
| . (символ точки)   | Разделитель дробной и целой части |
| -                  | Знак "минус" |
| ,                  | Разделитель групп |
| E                  | Разделяет мантиссу и экспоненту в научной записи |
| ;                  | Разделяет положительный шаблон числа и отрицательный шаблон числа |
| %                  | Умножается на 100 и показывается в процентах |
| \u2030             | Умножается на 1000 и показывается как в милях |
| ¤ (\u00A4)        | Денежный знак; заменяется денежным символом локали |

Пример:

```java
System.out.println(new java.text.DecimalFormat("0000.000").format(10));
```

Результат:
```
0010,000
```

### 28.4. Класс DateFormat

Класс `java.text.DateFormat` предназначен для форматирования дат. Получить экземпляр этого класса можно с помощью одного из методов:

```java
public static final DateFormat getInstance();
```

Если нужно форматировать/парсить только дату без времени, то можно использовать один из следующих методов:

```java
public static final DateFormat getDateInstance();
public static final DateFormat getDateInstance(int style);
public static final DateFormat getDateInstance(int style, Locale aLocale);
```

Здесь `style` может быть одно из значений: `DateFormat.FULL`, `DateFormat.LONG`, `DateFormat.SHORT`, `DateFormat.MEDIUM`, `DateFormat.DEFAULT`.

Если нужно форматировать/парсить только время, то можно использовать один из методов:

```java
public static final DateFormat getTimeInstance();
public static final DateFormat getTimeInstance(int style);
public static final DateFormat getTimeInstance(int style, Locale aLocale);
```

Если нужно форматировать/парсить дату с временем, то можно использовать один из методов:

```java
public static final DateFormat getDateTimeInstance();
public static final DateFormat getDateTimeInstance(int dateStyle, int timeStyle);
public static final DateFormat getDateTimeInstance(int dateStyle, int timeStyle, Locale aLocale);
```

Форматирование и парсинг также происходят с помощью методов `format` и `parse`. Пример:

```java
System.out.println(java.text.DateFormat.getInstance().format(new java.util.Date()));
```

### 28.5. Класс DateTimeFormatter

Класс `java.time.format.DateTimeFormatter` используется совместно с классами даты и времени из пакета `java.time`. Он был подробно описан в главе 27 "Дата и время".

### 28.6. Класс SimpleDateFormat

Класс `java.text.SimpleDateFormat` наследуется от класса `java.text.DateFormat` и позволяет указать пользовательский шаблон форматирования.

Конструкторы:
```java
public SimpleDateFormat(String pattern);
public SimpleDateFormat(String pattern, Locale locale);
public SimpleDateFormat(String pattern, DateFormatSymbols formatSymbols);
```

Шаблон `pattern` может содержать следующие специальные символы (табл. 28.2).

#### Таблица 28.2. Значения символов

| Буква | Компонент даты и времени | Представление            | Примеры           |
|-------|--------------------------|--------------------------|-------------------|
| G     | Эра                      | Text                     | AD                |
| y     | Год                      | Year                     | 1996; 96          |
| M     | Месяц в году            | Month                    | July; Jul; 07     |
| w     | Неделя в году           | Number                   | 27                |
| D     | День в году             | Number                   | 189               |
| d     | День в месяце           | Number                   | 10                |
| E     | Название дня недели      | Text                     | Tuesday; Tue      |
| H     | Час в дне (0-23)        | Number                   | 0                 |

*... (продолжение таблицы)*

### Заключение

Форматирование данных является важной частью разработки программного обеспечения для обеспечения правильного отображения информации пользователям из разных культурных контекстов. Использование классов Java для работы с форматированием чисел и дат поможет вам создавать более удобные для пользователя приложения.

*... (продолжение текста)*

