ГЛАВА 22  Файлы (NIO.2) 22.1. Path Path представляет собой путь в файловой системе. Он содержит имя файла и спи-сок каталогов, определяющих путь к файлу. 
Экземпляры Path отражают путь в конкретной платформе (например /home/ fedor/foo для Linux или C:\home\fedor\foo для Windows). Экземпляры Path зависят от платформы. Нельзя сравнивать Path из Linux с путем из Windows, даже если струк-тура их каталогов одинаковая и оба этих экземпляра указывают на один и тот же относительный файл. 
Path может указывать на файл или каталог, которых не существует. Методы Path работают только с представлением пути. Они не проверяют существование пути. 
Создавать экземпляры Path можно разными способами. 
Можно использовать методы java.nio.file.Paths.get(): 
public static Path get(String first,  String... more)  public static Path get(URI uri) Примеры: 
Path p1 = Paths.get(URI.create("file:///Users/fedor/Test.java")); 
Path p2 = Paths.get("/home/fedor/temp.txt"); 
  Глава 22. Файлы (NIO.2) 217 Эти методы являются сокращенной формой для следующего кода: 
Path p3 = java.nio.file.FileSystems.getDefault()  .getPath("/home/fedor/temp.txt"); 
Можно рассматривать Path как класс, сохраняющий имена каталогов в пути и имя файла в виде последовательности. Наивысший (ближний к корневому) элемент на-ходится по индексу 0, самый нижний элемент находится по индексу n - 1, где n — количество элементов в пути. 
Получить конкретный элемент пути можно с помощью метода getName(): 
String element0 = path.getName(0) // Для пути /home/fedor/foo (Linux) вернется home // Для пути C:\home\fedor\foo (Windows) вернется home. 
Узнать количество элементов в пути можно с помощью метода getNameCount(): 
int nameCount = path.getNameCount(); 
// Для /home/fedor/foo (Linux) вернет 3 // Для C:\home\fedor\foo (Windows) вернет 3 Можно получить путь родительской директории с помощью метода getParent(): 
Path parentPath = path.getParent(); 
// Для /home/fedor/foo (Linux) вернется /home/jho // Для C:\home\fedor\foo Windows вернется C:\home\jho // Вернет null, если родительского элемента нет. 
Можно получить корень пути с помощью метода getRoot(): 
Path rootPath = path.getRoot(); 
// Для /home/fedor/foo (Linux) вернет / // Для C:\home\fedor\foo (Windos) вернет C:\ // Вернет null, если путь относительный и корня нет. 
С помощью метода toString() можно получить путь в виде строки: 
String str1 = path.toString() // Вернет строку "/home/fedor/foo" для пути /home/fedor/foo (Linux). 
// Вернет строку "C:\home\fedor\foo" для // пути C:\home\fedor\foo (Windows). 
Многие файловые системы используют символ точки "." для обозначения текущего каталога и две точки ".." для обозначения родительского каталога. Например: 
/home/./fedor/foo  /home/maria/../fedor/foo Метод normalize() удаляет все подобные элементы и приводит к нормализованно-му пути /home/fedor/foo/. Этот метод не проверяет файловую систему. Это чисто синтетическая операция, работающая с элементами Path. Если maria является сим-волической ссылкой, то удаление maria/.. может привести к тому, что Path больше не указывает на предыдущий файл. 
218 Глава 22. Файлы (NIO.2) Если вам нужно преобразовать Path к строке, с помощью которой можно открыть файл в браузере, то используйте метод toUri(): 
Path p1 = Paths.get("/home/logfile"); 
// Result is file:///home/logfile System.out.format("%s%n", p1.toUri()); 
Метод toAbsolutePath() преобразует путь к абсолютному. Способ преобразования зависит от системы. Если переданный путь уже является абсолютным, то возвра-щается тот же самый объект Path. 
Метод toRealPath() возвращает реальный путь существующего файла. В качестве параметра в метод можно передать константу перечисления java.nio.file. 
LinkOption с единственным возможным значением NOFOLLOW_LINKS. Метод бросает исключение, если файл не существует, либо к нему нет доступа. Этот метод убира-ет все элементы "." и ".." и возвращает всегда абсолютный путь. 
try {  Path fp = path.toRealPath(); 
} catch (NoSuchFileException x) {  System.err.format("%s: no such file or directory%n", path); 
} catch (IOException x) {  System.err.format("%s%n", x); 
} Можно объединять пути с помощью метода resolve(), в который передается часть пути, которую нужно добавить к исходному: 
// Linux Path p1 = Paths.get("/home/fedor/temp"); 
 // Получим /home/fedor/temp/bar System.out.format("%s%n", p1.resolve("bar")); 
Или для Windows: 
// Microsoft Windows Path p1 = Paths.get("C:\\home\\fedor\\temp"); 
// Результат C:\home\fedor\temp System.out.format("%s%n", p1.resolve("bar")); 
С помощью метода relativize() можно создать относительный путь от одного пути к другому: 
Path p1 = Paths.get("fedor"); 
Path p2 = Paths.get("yana"); 
// Так как нет другой информации, то считается, что // fedor и yana находятся в одном каталоге. 
// Результат ../yana Path p1_relativize_p2 = p1.relativize(p2); 
// Result is ../fedor Path p2_relativize_p1 = p2.relativize(p1); 
Глава 22. Файлы (NIO.2) 219 Относительный путь не может быть получен только в том случае, когда только один из путей имеет корневой элемент. Если оба пути имеют корневой элемент, то возможность построения относительного пути зависит от системы. 
Path поддерживает метод equals(), что позволяет сравнивать пути. Также есть методы startsWith(Path other), startsWith(String other), endsWith(Path other), endsWith(String other), позволяющие проверять начало и конец пути на совпаде-ние с указанной строкой или частью пути. Path реализует интерфейс Comparable, что позволяет сортировать строки. 
Вы можете найти примеры использования Path в проекте niofilecommander на сайте https://urvanov.ru. 
22.2. Что такое Glob? 
Некоторые методы класса java.nio.file.Files принимают аргумент glob. Шаблон glob использует следующие правила: 
? Символ * обозначает любое количество символов или их отсутствие. 
? Две звездочки ** работают так же, как и одна, но переходят за границы катало-гов. 
? Для того чтобы избавиться от специального значения символов (* или ?), нужно предварять его символом \. 
? Символ вопроса ? обозначает ровно один символ. 
? Квадратные скобки позволяют указать набор символов либо диапазон символов: 
• [abc] обозначает a, b или c. 
• [A-Z] обозначает любую прописную букву. 
• [a-z,A-Z] обозначает любую строчную или прописную букву. 
• Внутри квадратных скобок *, ? и / обозначают самих себя. 
• [4-7] обозначает цифру от 4 до 7. 
? Фигурные скобки указывают коллекцию паттернов. Например {fedor,yana,temp} совпадает с "fedor" , "yana" или "temp". {Sir*, Sire*} совпадает со всеми стро-ками, начинающимися с "Sir" или "Sire". 
22.3. Класс Files Класс java.nio.file.Files содержит статические методы для работы с файлами, каталогами и другими типами файлов. 
22.4. Проверка существования файла или каталога Проверить существование пути Path можно с помощью методов класса Files: 
public static boolean exists(Path path,  LinkOption... options) 220 Глава 22. Файлы (NIO.2) public static boolean notExists(Path path,  LinkOption... options) Если передать константу LinkOption.NOFOLLOW_LINKS, то метод не будет проходить по символическим ссылкам. Если оба метода exists() и notExists() возвращают false, то существование файла не может быть проверено (например, нет доступа). 
22.5. Проверка прав доступа к файлу или каталогу Проверка доступа к файлу осуществляется с помощью методов класса Files: 
// Проверяет, что файл доступен для чтения public static boolean isReadable(Path path)  // Проверяет, что файл доступен для записи public static boolean isWritable(Path path)  // Проверяет, что файл доступен для выполнения public static boolean isExecutable(Path path) 22.6. Один и тот же файл Можно проверить, что два пути указывают на один и тот же файл на одной и той же файловой системе: 
public static boolean isSameFile(Path path,  Path path2)  throws IOException 22.7. Удаление файла или каталога Метод delete(Path) удаляет файл или бросает исключение, если удалить файл не удалось. Можно удалять каталог, но только если он пустой. 
try {  Files.delete(path); 
} catch (NoSuchFileException x) {  System.err.format("No such file or directory: %s.%n", path); 
} catch (DirectoryNotEmptyException x) {  System.err.format("%s not empty%n", path); 
} catch (IOException x) {  // Ошибка удаления файла (например, недостаточно прав). 
 System.err.println(x); 
} Метод public static boolean deleteIfExists(Path path)  throws IOExceptio Глава 22. Файлы (NIO.2) 221 тоже удаляет файл, но не бросает никаких исключений, если файл не существует. 
Это может быть полезно, если два потока удаляют файл, и вы не хотите получать исключение из-за того, что другой поток уже удалил файл до этого. 
Пример использования можно найти в проекте niofilecommander на сайте https://urvanov.ru. 
22.8. Копирование файла или каталога Можно копировать файл или каталог с помощью метода copy(Path, Path, CopyOption...), но имейте в виду, что файлы внутри каталога не копируются этим методом. Метод принимает константы CopyOption: 
? StandardCopyOption.REPLACE_EXISTING заменяет существующие файлы. 
? StandardCopyOption.COPY_ATTRIBUTES копирует атрибуты файла. 
? LinkOption.NOFOLLOW_LINKS нельзя переходить по символическим ссылкам. 
Пример использования можно найти в проекте niofilecommander на сайте https://urvanov.ru. 
22.9. Перемещение файла или каталога Можно переместить файл или каталог с помощью метода move(Path, Path, CopyOption...). Можно перемещать пустые каталоги. Возможность перемещения каталогов с содержимым зависит от платформы. Метод принимает CopyOption: 
? StandardCopyOption.REPLACE_EXISTING — заменяет существующий файл, если он существует. 
? StandardCopyOption.ATOMIC_MOVE — попытка осуществить перемещение файла как единую атомарную операцию. Все остальные опции игнорируются. 
Пример использования можно найти в проекте niofilecommander на сайте https:// urvanov.ru. 
22.10. Управление метаданными Метаданные файлов — это размер, дата создания, дата последнего изменения, вла-делец, права доступа и прочее. 
Метаданные файлов и каталогов часто называют атрибутами файлов. 
Методы для работы с метаданными: 
 public static long size(Path path)  throws IOException Возвращает размер файла в байтах. 
222 Глава 22. Файлы (NIO.2) public static boolean isDirectory(Path path,  LinkOption... options) Проверяет, что path указывает на каталог. Можно указать LinkOption.NOFOLLOW_ LINKS, чтобы метод не переходил по символическим ссылкам. 
 public static boolean isRegularFile(Path path,  LinkOption... options) Возвращает true, если path указывает на обычный файл. Можно передать LinkOption.NOFOLLOW_LINKS, чтобы метод не переходил по символическим ссылкам. 
 public static boolean isSymbolicLink(Path path) Возвращает true, если path указывает на символическую ссылку. 
 public static boolean isHidden(Path path)  throws IOException Возвращает true, если файл является скрытым. Для Linux файл является скрытым, если его имя начинается с точки. Для Windows файл является скрытым, если уста-новлен соответствующий атрибут. 
 public static FileTime getLastModifiedTime(Path path,  LinkOption... options)  throws IOException Возвращает FileTime с датой последнего изменения файла. Можно передать LinkOption.NOFOLLOW_LINKS, чтобы метод не переходил по символическим ссылкам. 
 public static Path setLastModifiedTime(Path path,  FileTime time)  throws IOException Устанавливает дату последнего изменения файла. Смотрите описание класса FileTime в документации Oracle. 
 public static UserPrincipal getOwner(Path path,  LinkOption... options)  throws IOException Возвращает владельца файла. Можно использовать метод String getName() у воз-вращенного объекта, чтобы получить имя пользователя. 
 public static Path setOwner(Path path,  UserPrincipal owner)  throws IOException Меняет владельца файла. 
 Различные файловые системы имеют различные атрибуты файлов. Можно считы-вать группы атрибутов: 
Глава 22. Файлы (NIO.2) 223 ? BasicFileAttributeView — базовые атрибуты файлов, которые должны поддер-живаться всеми реализациями файловых систем. 
? DosFileAttributeView — расширяет стандартные атрибуты 4 битами (скрытый, архивный, только чтение, системный). 
? PosixFileAttributeView — расширяет базовые атрибуты атрибутами системы Linux. 
? FileOwnerAttributeView — поддерживается всеми файловыми системами, кото-рые поддерживают владельцев файлов. 
? AclFileAttributeView — права доступа к файлу, которые реализованы в Win-dows. 
? UserDefinedFileAttributeView — пользовательские метаданные. 
Получение конкретной группы атрибутов происходит с помощью метода public static <V extends FileAttributeView> V getFileAttributeView(  Path path,  Class<V> type,  LinkOption... options) Пример: 
Path path = ... 
AclFileAttributeView view = Files.getFileAttributeView(path,  AclFileAttributeView.class); 
if (view != null) {  List<AclEntry> acl = view.getAcl(); 
 // ... 
} Работа с конкретными группами метаданных/атрибутов очень зависит от платфор-мы. Вам вряд ли когда-нибудь придется столкнуться с этим. Но если интересно, то рекомендую рассмотреть мой проект niofilecommander (https://urvanov.ru/2016/ 01/08/niofilecommander/), который использует все группы атрибутов, описанные здесь. 
22.11. OpenOption Многие методы, описанные в этом разделе, используют OpenOption в качестве сво-их параметров. В этом случае в метод можно передавать следующие значения: 
? LinkOption.NOFOLLOW_LINKS — не переходить по символическим ссылкам. 
? StandardOpenOption.APPEND — если файл открыт для записи, то байты будут до-бавляться в конец файла, а не в начало. 
? StandardOpenOption.CREATE — создавать новый файл, если его нет. 
? StandardOpenOption.CREATE_NEW — создавать новый файл. Если файл уже сущест-вует, то происходит ошибка. 
224 Глава 22. Файлы (NIO.2) ? StandardOpenOption.DELETE_ON_CLOSE — удалять файл при закрытии. 
? StandardOpenOption.DSYNC — каждое обновление содержимого файла синхронно пишется на устройство хранения (жесткий диск). 
? StandardOpenOption.READ — открыть для чтения. 
? StandardOpenOption.SPARSE — разреженный файл (sparse file). Поддерживается в некоторых файловых системах. Для файлов, в которых много блоков, запол-ненных нулями, разреженный файл хранит вместо этих нулей только инфор- мацию об областях, заполненных нулями, что уменьшает занимаемое файлом место. 
? StandardOpenOption.SYNC — каждое обновление содержимого файла или мета-данных синхронно пишется на устройство чтения (жесткий диск). 
? StandardOpenOption.TRUNCATE_EXISTING — если файл уже существует и открыва-ется для записи, то его длина устанавливается в 0. 
? StandardOpenOption.WRITE — открывает файл на запись. 
 22.12. Наиболее часто используемые методы для небольших файлов public static byte[] readAllBytes(Path path)  throws IOException Читает содержимое файла и возвращает его в массиве байт. 
 public static List<String> readAllLines(Path path,  Charset cs)  throws IOException Читает содержимое текстового файла и возвращает его в виде списка строк. 
 public static Path write(Path path,  byte[] bytes,  OpenOption... options)  throws IOException Записывает байты в файл. 
 public static Path write(Path path,  Iterable<? extends CharSequence> lines,  Charset cs,  OpenOption... options)  throws IOException Записывает строки в файл, преобразуя их в указанную кодировку. 
Глава 22. Файлы (NIO.2) 225 22.13. Буферизированный ввод и вывод в текстовые файлы public static BufferedReader newBufferedReader(Path path,  Charset cs)  throws IOException Возвращает BufferedReader, который может быть использован для чтения из тек-стового файла. 
 public static BufferedWriter newBufferedWriter(Path path,  Charset cs,  OpenOption... options)  throws IOException Открывает или создает файл для записи. Возвращаемый BufferedWriter может быть использован для записи в файл. Если OpenOption не переданы, то используются опции CREATE, TRUNCATE_EXISTING, WRITE. 
22.14. Небуферизированный ввод и вывод public static InpuяtStream newInputStream(Path path,  OpenOption... options)  throws IOException Возвращает поток, который можно использовать для чтения байт из файла. 
 public static OutputStream newOutputStream(Path path,  OpenOption... options)  throws IOException Возвращает поток, который можно использовать для записи байт в файл. Если OpenOption не переданы, то используются опции CREATE, TRUNCATE_EXISTING, WRITE. 
22.15. Создание файлов public static Path createFile(Path path,  FileAttribute<?>... attrs)  throws IOException Создает новый и пустой файл. Бросает исключение, если файл уже существует. 
22.16. Создание временных файлов public static Path createTempFile(Path dir,  String prefix,  String suffix,  FileAttribute<?>... attrs)  throws IOException 226 Глава 22. Файлы (NIO.2) Создает временный файл в указанном каталоге. Является только частью работы с временными файлами. Вы можете использовать метод File.deleteOnExit() для то-го, чтобы каталог удалялся автоматически. 
 public static Path createTempFile(String prefix,  String suffix,  FileAttribute<?>... attrs)  throws IOException Создает временный файл в специальном каталоге для временных файлов. Является только частью работы с временными файлами. Вы можете использовать метод File.deleteOnExit() для того, чтобы каталог удалялся автоматически. 
22.17. Java NIO.2 Channels В java.nio.file.channels хранятся классы для работы с файлами, ресурсами сети и другими устройствами через каналы. 
В Java NIO Channel есть несколько интерфейсов: ByteChannel, ReadableByteChannel, WritableByteChannel, SeekableByteChannel и др. 
А также различные классы, реализующие работу с разными сущностями (файлами, сетью и т. д.): FileChannel, ServerSocketChannel, SocketChannel, DatagramChannel и т. д. 
Интерфейс ReadableByteChannel содержит метод read: 
int read(ByteBuffer dst)  throws IOException Метод read считывает данные в dst и возвращает количество считанных байт либо –1 при достижении конца файла. 
Интерфейс WritableByteChannel содержит метод write: 
int write(ByteBuffer src)  throws IOException Метод write возвращает количество записанных байт. 
Файл можно открыть одновременно для чтения и записи и с возможностью пере-мещения текущей позиции в любое место файла. Подобная функциональность реа-лизуется с помощью интерфейса java.nio.channels.SeekableByteChannel. 
Получить экземпляр класса, реализующего интерфейс SeekableByteChannel, можно с помощью статического метода из класса Files: 
public static SeekableByteChannel newByteChannel(Path path,  OpenOption... options)  throws IOException либо: 
public static SeekableByteChannel newByteChannel(  Path path, Глава 22. Файлы (NIO.2) 227  Set<? extends OpenOption> options,  FileAttribute<?>... attrs)  throws IOException Пример использования (класс FileChannel реализует ReadableByteChannel, WritableByteChannel): 
FileChannelExample.java package ru.urvanov.javaindynamics2022.nio; 
 import java.io.IOException; 
import java.nio.ByteBuffer; 
import java.nio.channels.FileChannel; 
import java.nio.file.Paths; 
 import static java.nio.file.StandardOpenOption.READ; 
import static java.nio.file.StandardOpenOption.WRITE; 
 public class FileChannelExample {  public static void main(String[] args) {  String s = "Моя добавленная строчка\n"; 
 byte data[] = s.getBytes(); 
 ByteBuffer out = ByteBuffer.wrap(data); 
  ByteBuffer copy = ByteBuffer.allocate(12); 
  // Вместо output.txt укажите имя существующего файла  // (его содержимое будет изменено)  try (FileChannel fc = FileChannel.open(  Paths.get("output.txt"), READ, WRITE)) {  // Читаем первые 12 байт из файла. 
 int nread; 
 do {  nread = fc.read(copy); 
 } while (nread != -1 && copy.hasRemaining()); 
  // Пишем "Моя добавленная строчка" в начало файла. 
 fc.position(0); 
 while (out.hasRemaining())  fc.write(out); 
 out.rewind(); 
  // Перемещаемся в конец файла. Копируем первые 12 байт  // в конец файла. Пишем "Моя добавленная строчка" снова. 
 long length = fc.size(); 
 fc.position(length-1); 
 copy.flip(); 
228 Глава 22. Файлы (NIO.2)  while (copy.hasRemaining())  fc.write(copy); 
 while (out.hasRemaining())  fc.write(out); 
 } catch (IOException x) {  System.out.println("I/O Exception: " + x); 
 }  } } 22.18. Перечисление корневых каталогов файловой системы Для этого используется специальный метод класса FileSystem: 
public abstract Iterable<Path> getRootDirectories() Пример: 
Iterable<Path> dirs = FileSystems.getDefault().getRootDirectories(); 
for (Path name: dirs) {  System.err.println(name); 
} 22.19. Создание каталога Метод класса Files: 
public static Path createDirectory(Path dir,  FileAttribute<?>... attrs)  throws IOException создает каталог. 
public static Path createDirectories(Path dir,  FileAttribute<?>... attrs)  throws IOException создает каталог вместе со всеми родительскими каталогами, которых еще нет. 
Пример использования можно найти в проекте niofilecommander на сайте https:// urvanov.ru. 
22.20. Создание временного каталога public static Path createTempDirectory(Path dir,  String prefix,  FileAttribute<?>... attrs)  throws IOException Глава 22. Файлы (NIO.2) 229 Создает временный каталог. Как и методы, createTempFile является только частью работы с временными файлами. Вы можете использовать метод File. 
deleteOnExit() для того, чтобы каталог удалялся автоматически. 
  public static Path createTempDirectory(String prefix,  FileAttribute<?>... attrs)  throws IOException Создает временный каталог в специальном каталоге для временных файлов. Как и методы, createTempFile является только частью работы с временными файлами. Вы можете использовать метод File.deleteOnExit() для того, чтобы каталог удалялся автоматически. 
22.21. Перечисление содержимого каталога public static DirectoryStream<Path> newDirectoryStream(Path dir)  throws IOException Возвращает поток, который позволяет пройтись по всем элементам каталога. 
Пример использования: 
DirectoryStreamExample.java // Подставьте сюда путь к каталогу вместо src Path dir = Paths.get("src"); 
try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {  for (Path file: stream) {  System.out.println(file.getFileName()); 
 } } catch (IOException | DirectoryIteratorException x) {  // IOException не может броситься во время итерации. 
 // В этом куске кода оно может броситься только  // методом newDirectoryStream. 
 System.err.println(x); 
} public static DirectoryStream<Path> newDirectoryStream(Path dir,  String glob)  throws IOException  Позволяет посмотреть элементы каталога, названия которых удовлетворяют пере-данному шаблону Glob. 
Например, следующий код возвращает список файлов с расширениями .class, .java, .jar: 
DirectoriesByGlob.java // Подставьте сюда путь к каталогу вместо target/classes Path dir = Paths.get("target/classes"); 
230 Глава 22. Файлы (NIO.2) try (DirectoryStream<Path> stream =  Files.newDirectoryStream(dir, "*.{java,class,jar}")) {  for (Path entry: stream) {  System.out.println(entry.getFileName()); 
 } } catch (IOException x) {  // IOException никогда не бросится во время итерации. 
 // В этом куске кода оно может броситься только  // методом newDirectoryStream  System.err.println(x); 
}  Можно написать свой собственный фильтр для содержимого каталога. Например, этот фильтр будет возвращать только каталоги: 
DirectoriesByFilter.java package ru.urvanov.javaindynamics2022.nio; 
 import java.io.IOException; 
import java.nio.file.DirectoryStream; 
import java.nio.file.Files; 
import java.nio.file.Path; 
import java.nio.file.Paths; 
 public class DirectoriesByFilter {  public static void main(String[] args) {  DirectoryStream.Filter<Path> filter =  new DirectoryStream.Filter<Path>() {  public boolean accept(Path file) throws IOException {  return (Files.isDirectory(file)); 
 }  }; 
 // Подставьте сюда путь к каталогу вместо target/classes  Path dir = Paths.get("target/classes"); 
 try (DirectoryStream<Path>  stream = Files.newDirectoryStream(dir, filter)) {  for (Path entry: stream) {  System.out.println(entry.getFileName()); 
 }  } catch (IOException x) {  System.err.println(x); 
 }  } } Глава 22. Файлы (NIO.2) 231 22.22. Символические и другие ссылки Каждый метод класса Path автоматически обрабатывает символические ссылки либо предоставляет опции, которые позволяют указать, каким образом их обраба-тывать. 
Ссылки бывают символическими и жесткими. Жесткие ссылки имеют больше ограничений, чем символические: 
? Цель, на которую указывает жесткая ссылка, должна существовать. 
? Жесткие ссылки обычно не могут указывать на каталоги. 
? Жесткие ссылки не могут указывать на другой раздел или том и не могут указы-вать на другую файловую систему. 
? Жесткие ссылки выглядят и ведут себя так, как обычный файл, поэтому их может быть трудно обнаружить. 
? Жесткая ссылка для всех целей и действий является той же сущностью, что и исходный файл. Они имеют те же самые права доступа, временные метки и т. д. 
Из-за таких ограничений жесткие ссылки не так часто используются, как символи-ческие ссылки. 
22.23. Создание символических ссылок Если ваша файловая система поддерживает символические ссылки, то вы можете создавать их с помощью метода класса Files: 
public static Path createSymbolicLink(Path link,  Path target,  FileAttribute<?>... attrs)  throws IOException Этот метод создает символическую ссылку по пути link, указывающую на target. 
Параметр attrs позволяет задать атрибуты ссылки. 
Пример использования можно найти в проекте niofilecommander на сайте https:// urvanov.ru. 
22.24. Создание жестких ссылок public static Path createLink(Path link,  Path existing)  throws IOException Создает жесткую ссылку по пути link, указывающую на existing. 
Пример использования можно найти в проекте niofilecommander на сайте https://urvanov.ru. 
232 Глава 22. Файлы (NIO.2) 22.25. Определение символической ссылки public static boolean isSymbolicLink(Path path) Этот метод класса Files возвращает true, если файл является символической ссыл-кой. 
22.26. Нахождение цели ссылки public static Path readSymbolicLink(Path link)  throws IOException Этот метод класса Files возвращает путь, на который указывает символическая ссылка. Если link не является ссылкой, то бросается исключение java.nio. 
file.NotLinkException. 
22.27. Обход дерева файлов с FileVisitor Чтобы обходить дерево файлов, нужно сперва написать класс, реализующий ин-терфейс java.nio.file.FileVisitor. Этот интерфейс позволяет описать действия, которые будут происходить в основные моменты обхода дерева файлов: при посе-щении файла, перед доступом к каталогу, после доступа к каталогу и при возник-новении ошибки. FileVisitor имеет четыре метода для этих ситуаций: 
? preVisitDirectory — вызывается перед посещением элементов каталога. 
? postVisitDirectory — вызывается после посещения всех элементов каталога. 
? visitFile — вызывается при посещении файла. В метод передаются BasicFileAttributes. 
? visitFileFailed — вызывается в случае, когда не удается получить доступ к файлу. 
Если вам не нужны все эти четыре метода, то вы можете вместо реализации интер-фейса FileVisitor наследоваться от java.nio.file.SimpleFileVisitor. Этот класс реализует FileVisitor и посещает все файлы в дереве, бросая исключение IOException при возникновении ошибки. Вы можете отнаследоваться от этого клас-са и реализовать только те методы, которые вам нужны. 
Пример реализации SimpleFileVisitor: 
PrintFiles.java import static java.nio.file.FileVisitResult.*; 
 public static class PrintFiles  extends SimpleFileVisitor<Path> {   // Выводит в консоль информацию о каждом типе файлов. 
 @Override Глава 22. Файлы (NIO.2) 233  public FileVisitResult visitFile(Path file,  BasicFileAttributes attr) {  if (attr.isSymbolicLink()) {  System.out.format("Symbolic link: %s ", file); 
 } else if (attr.isRegularFile()) {  System.out.format("Regular file: %s ", file); 
 } else {  System.out.format("Other: %s ", file); 
 }  System.out.println("(" + attr.size() + "bytes)"); 
 return CONTINUE; 
 }   // Пишет в консоль каждый посещаемый каталог  @Override  public FileVisitResult postVisitDirectory(Path dir,  IOException exc) {  System.out.format("Directory: %s%n", dir); 
 return CONTINUE; 
 }   // Если возникла какая-нибудь ошибка при доступе к файлу,  // то выводим эту ошибку. 
 // Если вы не переопределите этот метод и возникнет  // ошибка, то бросится исключение IOException  @Override  public FileVisitResult visitFileFailed(Path file,  IOException exc) {  System.err.println(exc); 
 return CONTINUE; 
 } }  Запуск процесса обхода дерева файлов public static Path walkFileTree(Path start,  FileVisitor<? super Path> visitor)  throws IOException или public static Path walkFileTree(Path start,  Set<FileVisitOption> options,  int maxDepth,  FileVisitor<? super Path> visitor)  throws IOException Второй метод позволяет задать максимальную глубину обхода и FileVisitOption. 
FOLLOW_LINKS, что позволит заходить в символические ссылки. 
234 Глава 22. Файлы (NIO.2) Пример для нашего PrintFiles: 
PrintFiles.java // Вместо general/src подставить путь к свеому каталогу Path startingDir = Paths.get("general/src"); 
PrintFiles pf = new PrintFiles(); 
Files.walkFileTree(startingDir, pf)  Дерево файлов обходится в глубину, но вы не можете предугадать порядок посе-щения подкаталогов. 
Если ваша программа делает изменения в файловой системе, то вам нужно внима-тельно реализовывать ваш FileVisitor. 
Например, если вы пишете рекурсивное удаление, то сначала вам нужно удалить файлы в каталоге, а затем удалять сам каталог. В этом случае удалять каталог нуж-но в методе postVisitDirectory. 
Если вы пишете рекурсивное копирование, то вам сначала нужно создавать каталог в preVisitDirectory, а лишь потом копировать файлы в visitFiles. Если вам нужно скопировать атрибуты из исходного каталога, то это нужно делать после копирова-ния каталога, т. е. в postVisitDirectory. 
Если вы пишете поиск файла, то осуществляйте сравнение в visitFile; если вам нужно находить не только файлы, но и каталоги, то используйте вдобавок метод preVisitDirectory или postVisitDirectory. 
Вам также нужно решить, как обрабатывать символические ссылки. Если вы уда-ляете файлы, то переходить по символическим ссылкам, скорее всего, не нужно. 
Если вы копируете дерево файлов, то вам, вероятно, потребуется переходить по ссылкам. По умолчанию метод walkFileTree не переходит по символическим ссыл-кам. 
Метод visitFile вызывается для файлов. Если вы указали FOLLOW_LINKS и ваше дерево файлов имеет циклическую ссылку на родительский каталог, то во время повторения каталога будет сообщено в visitFileFailed с помощью исключения FileSystemLoopException. 
Во время обхода может потребоваться не заходить внутрь какого-либо каталога либо даже прервать обход дерева. Методы FileVisitor возвращают java.nio.file. 
FileVisitResult, которое является перечислением со следующими константами: 
? FileVisitResult.CONTINUE — указывает, что обход дерева файлов должен про-должаться. Если метод preVisitDirectory возвращает CONTINUE, то каталог посе-щается. 
? FileVisitResult.TERMINATE — прерывает обход всего дерева файлов. 
? FileVisitResult.SKIP_SUBTREE — если preVisitDirectory возвращает это значе-ние, то указанный каталог и его подкаталоги пропускаются. 
Глава 22. Файлы (NIO.2) 235 ? FileVisitResult.SKIP_SIBLINGS — если preVisitDirectory возвращает это значе-ние, то указанный каталог не посещается и postVisitDirectory не вызывается. 
Если возвращается из postVisitDirectory, то остальные каталоги с тем же роди-тельским каталогом пропускаются. 
Смотрите примеры в niofilecommander на сайте (https://urvanov.ru/2016/01/08/ niofilecommander/). 
22.28. Поиск файлов Каждая реализация файловой системы поставляет свою реализацию интерфейса java.nio.file.PathMatcher. 
Вы можете получить экземпляр класса, реализующий этот интерфейс для файловой системы: 
String pattern = ...; 
PathMatcher matcher =  FileSystems.getDefault().getPathMatcher("glob:" + pattern); 
Строка, которая передается в этот метод, указывает, какие файлы искать. В этом примере используется синтаксис glob. Можно использовать регулярные выраже-ния, тогда вместо glob: нужно писать regex:. 
В дальнейшем этот matcher можно использовать при обходе дерева файлов вот так: 
if (matcher.matches(filename)) {  System.out.println(filename); 
} Пример использования можно найти в проекте niofilecommander на сайте https://urvanov.ru. 
22.29. Подписываемся на изменения в каталоге Последовательность шагов, которую нужно проделать для того, чтобы следить за изменениями в каком-нибудь каталоге: 
1. Создаем экземпляр WatchService для файловой системы. 
2. Для каждого каталога, за которым нужно наблюдать, регистрируем наблюдателя (watcher). При регистрации каталога вы указываете события, о которых вам бы хотелось знать. Для каждого каталога вы получаете экземпляр класса WatchKey. 
3. Делаем бесконечный цикл на входящих событиях. При возникновении события WatchKey этого каталога получает сигнал и кладется в очередь наблюдателя. 
4. Получаем WatchKey из очереди. Вы можете получить имя файла из этого ключа. 
5. Получаем каждое событие для ключа (их может быть несколько) и обрабаты- ваем. 
6. Сбрасываем WatchKey и возвращаемся к ожиданию событий. 
236 Глава 22. Файлы (NIO.2) 7. Закрываем WatchServce. Он закрывается при выходе из потока либо при вызове метода. 
Экземпляры WatchKey потокобезопасны. 
import static java.nio.file.StandardWatchEventKinds.*; 
... 
 WatchService watcher = FileSystems.getDefault().newWatchService(); 
 Path dir = ...; 
try {  WatchKey key = dir.register(watcher,  ENTRY_CREATE,  ENTRY_DELETE,  ENTRY_MODIFY); 
} catch (IOException x) {  System.err.println(x); 
} Для обработки событий сначала мы получаем WatchKey с помощью одного из мето-дов WatchService: 
 WatchKey poll() Удаляет из очереди и возвращает следующий WatchKey либо null, если очередь пуста. 
 WatchKey poll(long timeout,  TimeUnit unit)  throws InterruptedException Удаляет из очереди и возвращает следующий WatchKey. Ждет, если нужно, указан-ное количество времени. 
 WatchKey take()  throws InterruptedException Удаляет из очереди и возвращает следующий WatchKey. Если очередь пуста, то ждет до тех пор, пока не появится хоть что-нибудь. 
 Затем обрабатываются все события из WatchKey, которые получаются при вызове его метода: 
List<WatchEvent<?>> pollEvents() Тип события получается с помощью следующего метода WatchEvent: 
WatchEvent.Kind<T> kind() Независимо от событий, на которые мы подписаны, мы может получить событие OVERFLOW. 
Получаем имя файла из события с помощью метода context(), который возвращает относительный путь к файлу от каталога, на изменения в котором мы подписаны. 
Глава 23. Многопоточность 237 Вызываем reset() на WatchKey. Если он вернул false, то он больше не работает и из цикла можно выходить. 
Пример обработки событий изменения содержимого каталога можно увидеть в niofilecommander на моем сайте, который обновляет свои панели при добавлении, переименовании и удалении файлов в них.