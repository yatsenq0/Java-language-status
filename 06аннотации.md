## Глава 6. Аннотации

### 6.1. Объявление аннотаций

Аннотации представляют собой метаинформацию. Они не выполняют какого-либо действия сами по себе, но могут предоставлять дополнительную информацию, которая может быть использована компилятором, различными утилитами сборки и генерации кода. Также аннотации могут обрабатываться во время выполнения программы.

Аннотации предваряются знаком `@`. Пример часто используемой аннотации — `@Override`, которая указывает компилятору, что этот метод переопределяет базовый:

```java
// StandardAnnotation.java
@Override
public void someMethod1() {
  // ...
}
```

Аннотации могут иметь элементы:

```java
// StandardAnnotation.java
@SuppressWarnings(value = "unchecked")
public void method1() { }
```

Если элементов много, то они разделяются запятой. Если элемент только один, и его имя `value`, то его название можно не указывать:

```java
// StandardAnnotation.java
@SuppressWarnings("unchecked")
void myMethod() { ... }
```

Предположим, что вы по традиции при объявлении каждого нового класса монстра записываете в комментариях информацию об авторах в таком виде:

```java
// IceElemental.java
package ru.urvanov.javaindynamics2022.annotation;

// Пример к разделу про аннотации
class IceElemental {
  // автор : Петров Иван
  // художник : Ишова Джамиля
  // звуки : Спиридонов Михаил
  // программирование : Пушкин Александр
  // дата создания : 30 марта 2016
  // описание : Ледяной элементаль - это сильное существо из льда
  // комментарии :
  // ... код
}
```

Вы можете записывать эту информацию с помощью аннотаций. Для этого вам сперва нужно ее объявить:

```java
// Monster.java
package ru.urvanov.javaindynamics2022.annotation;

@interface Monster {
  String author();
  String sprites();
  String sound();
  String code();
  String createdAt() default "0000-00-00";
  String description();
  // Пример использования массива
  String[] comments();
}
```

Теперь можно применить созданную аннотацию к нашему классу `IceElemental`:

```java
// IceElementalAnnotated.java
package ru.urvanov.javaindynamics2022.annotation;

@Monster(
  author="John Clark",
  sprites = "Izabella Simpson",
  sound = "Michael Lermontov",
  code = "Pushkin A.",
  createdAt = "2016-03-30",
  description = "Ice elemental is a powerful creature from ice",
  comments = {"lol", "gg", "Аффтар жжет"}
)
class IceElementalAnnotated { }
```

Обратите внимание на запись элементов аннотации (`author`, `sprites`, `sound`) и на запись массива элементов с использованием фигурных скобок (`comments`).

Можно использовать предопределенную аннотацию `@Documented`, чтобы наша аннотация попадала в документацию, сгенерированную утилитой JavaDoc:

```java
// DocumentedMonster.java
package ru.urvanov.javaindynamics2022.annotation;

import java.lang.annotation.Documented;

@Documented
@interface DocumentedMonster {
  String author();
  //...
}
```

### 6.2. Предопределенные аннотации

*   `@Deprecated` указывает, что элемент устарел и не должен использоваться. Компилятор Java генерирует предупреждение, если вы используете класс, метод или поле, помеченные аннотацией `@Deprecated`. Устаревший элемент должен быть также помечен тегом JavaDoc `@deprecated`:

    ```java
    // PredefinedAnnotations.java
    /**
     * @deprecated
     * Объяснение, почему устарело,
     * что использовать вместо устаревшего метода
     */
    @Deprecated
    static void deprecatedMethod() { }
    ```

*   `@Override` указывает, что метод переопределяет метод базового класса. Эту аннотацию использовать необязательно, но рекомендуется.

    ```java
    // PredefinedAnnotations.java
    @Override
    public int myMethod1(double x) {
      // ...
      Return 10;
    }
    ```

    Если метод с `@Override` не может корректно переопределить метод базового класса, то компилятор генерирует ошибку.

    ```java
    // PredefinedAnnotations.java
    // Указываем компиляторy не генерировать предупреждение об использовании
    // устаревшего метода.
    @SuppressWarnings("deprecation")
    void useDeprecatedMethod() {
      // Используем устаревший метод.
      objectOne.deprecatedMethod();
    }
    ```

    Каждое предупреждение принадлежит какой-либо категории. В спецификации Java описаны две категории. В `@SupressWarnings` можно указывать несколько категорий:

    ```java
    @SuppressWarnings({"unchecked", "deprecation"})
    ```

    Различные реализации компиляторов и различные IDE могут добавлять свои категории предупреждений. Неподдерживаемые названия категорий пропускаются при использовании `@SuppressWarnings`.

*   `@SafeVarargs` применяется к методу или конструктору и указывает, что код не осуществляет потенциально опасных операций со своим varargs-параметром (параметр, принимающий произвольное число параметров). Подробнее о нем рассказано в разделе 18.31. "Подавление предупреждений для методов с произвольным количеством параметров с нематериализуемыми формальными параметрами" главы 18 .

*   `@FunctionalInterface` указывает, что это объявление типа будет функциональным интерфейсом. Функциональные интерфейсы появились в Java 8, про них рассказывается в разделе 7.9. "Лямбда-выражения".

### 6.3. Мета-аннотации

Аннотации, применяемые к другим аннотациям, называются мета-аннотациями. В пакете `java.lang.annotation` есть несколько мета-аннотаций:

*   `@Retention` определяет, как аннотация будет сохранена:

    *   `RetentionPolicy.SOURCE` — аннотация будет только в исходном коде, и она будет игнорироваться компилятором.
    *   `RetentionPolicy.CLASS` — аннотация будет доступна компилятору, но будет игнорироваться виртуальной машиной Java.
    *   `RetentionPolicy.RUNTIME` — аннотация будет сохраняться JVM и будет доступна во время выполнения.

*   `@Documented` — указывает, что элементы, помеченные этой аннотацией, должны документироваться в JavaDoc. По умолчанию аннотации не включаются в документацию.

*   `@Target` — указывает, какие элементы можно помечать этой аннотацией:

    *   `ElementType.ANNOTATION_TYPE` — данная аннотация может быть применена к другой аннотации.
    *   `ElementType.CONSTRUCTOR` — может быть применена к конструктору.
    *   `ElementType.FIELD` — может быть применена к полю.
    *   `ElementType.LOCAL_VARIABLE` — может быть применена к локальной переменной.
    *   `ElementType.METHOD` — может быть применена к методу.
    *   `ElementType.MODULE` — может быть применена к модулю. Подробнее про модули рассказано в главе 17 "Модули".
    *   `ElementType.PACKAGE` — может быть применена к пакету. Подробнее про пакеты рассказано в главе 10 "Пакеты".
    *   `ElementType.PARAMETER` — может быть применена к параметрам метода.
    *   `ElementType.RECORD_COMPONENT` — может быть применена к записям. Подробнее про записи рассказано в главе 12 "Записи".
    *   `ElementType.TYPE` — может быть применена к классу, интерфейсу, аннотации или перечислению.
    *   `ElementType.TYPE_PARAMETER` — может быть применена к аргументам типа. Подробнее про аргументы типа рассказано в главе 18 "Обобщения".
    *   `ElementType.TYPE_USE` — может быть применена к использованию типа.

*   `@Inherited` — аннотация может быть унаследована от базового класса (по умолчанию не наследуются). Когда запрашивается аннотация класса, а у класса нет такой аннотации, то запрашивается аннотация базового класса. Она может быть применена только к классам.

*   `@Repeatable` — аннотация может быть применена несколько раз.

Допустим, мы хотим применить аннотацию `@Author` несколько раз для указания нескольких авторов:

```java
// DevilBird.java
@Author("Petya")
@Author("Vasya")
@Author("Suslik")
class DevilBird { }
```

Тогда мы должны объявить такую аннотацию вот так:

```java
// Author.java
import java.lang.annotation.Repeatable;

@Repeatable(Authors.class)
@interface Author {
  String value();
}
```

Обратите внимание, что добавлена аннотация `@Repeatable` с указанием `Authors.class`, которую мы должны объявить как аннотацию с массивом — аннотация `Author`:

```java
// Authors.java
@interface Authors{
  Author[] value();
}
```

Теперь мы можем указывать аннотацию `@Author` столько раз, сколько захотим, для любого класса.

