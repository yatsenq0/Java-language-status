## Глава 5. Классы и объекты

### 5.1. Классы

Классы в Java объявляются с помощью ключевого слова `class`. Пример простого объявления класса:

```java
// Goblin.java
package ru.urvanov.javaindynamics2022.classes;

public class Goblin {
}
```

Здесь мы объявляем новый класс с именем `Goblin`. Внутри фигурных скобок объявляются все поля, конструкторы и методы класса.

Перед ключевым словом `class` может стоять модификатор `public`, который делает класс доступным из всех пакетов. Если модификатора `public` нет, как в нашем случае, то класс доступен только в том пакете, в котором он объявлен.

### 5.2. Поля

Пример объявления полей:

```java
// GoblinFields.java
package ru.urvanov.javaindynamics2022.classes;

public class GoblinFields {
    private int money;
    double health;
    protected int diamonds = 10;
    public String name;
}
```

В этом примере мы объявили четыре поля:

*   поле `money` с типом `int`;
*   поле `health` с типом `double`;
*   поле `diamonds` с типом `int`;
*   поле `name` с типом `String`.

Каждый экземпляр класса `GoblinFields` будет иметь свое значение полей `money`, `health`, `diamonds` и `name`.

В самом начале объявления поля либо указывается модификатор доступа к полю (`private`, `protected` или `public`), либо не указывается, и тогда используется доступ по умолчанию `package-private`. Затем при необходимости указывается ключевое слово `static` (будет объяснено позже), а также, если нужно, ключевое слово `final` (будет объяснено позже). После них — тип поля и имя. Затем поле может сразу инициализироваться начальным значением, например, как поле `diamonds` инициализируется числом 10 в нашем примере.

Модификаторы доступа, `static` и `final`, могут располагаться в любом порядке, но в соглашении по оформлению кода принят именно такой порядок, какой описан в этом разделе.

Поле `money` объявлено с модификатором доступа `private`, и оно будет доступно только внутри этого класса.

Поле `health` объявлено без модификаторов доступа, и для него будет использоваться уровень доступа `package-private` (поле будет доступно только внутри своего пакета).

Поле `diamonds` объявлено с модификатором доступа `protected`, и оно будет доступно в этом пакете, этом классе и классах-наследниках от этого класса (как объявлять наследники, будет объяснено позже).

Поле `name` объявлено с модификатором доступа `public`, и оно будет доступно во всех классах всех пакетов (табл. 5.1).

**Таблица 5.1. Уровни доступа**

| Модификатор       | Класс | Пакет | Дочерний класс | Все классы |
| :---------------- | :---- | :---- | :--------------- | :--------- |
| `Public`          | Есть  | Есть  | Есть             | Есть       |
| `Protected`       | Есть  | Есть  | Есть             | Нет        |
| Без модификатора  | Есть  | Есть  | Нет              | Нет        |
| `Private`         | Есть  | Нет   | Нет              | Нет        |

Имя поля следует давать в соответствии с соглашениями по оформлению кода ([https://www.oracle.com/java/technologies/javase/codeconventions-contents.html](https://www.oracle.com/java/technologies/javase/codeconventions-contents.html)).

Обращаться к полю внутри класса, которому оно принадлежит, можно просто по имени поля:

```java
// GoblinFire.java
package ru.urvanov.javaindynamics2022.classes;

class GoblinFire {
    int ammo = 10;
    //... другие поля класса

    // метод стрельбы
    public void fire() {
        // уменьшаем количество пуль.
        // Обратите внимание, что к полю класса
        // обращаемся просто по имени
        ammo--;
        // ... остальной код
    }
    // ... другие методы
}
```

Из других классов обращение к полю класса происходит через точку, например:

```java
// AccessGoblinField.java
package ru.urvanov.javaindynamics2022.classes;

public class AccessGoblinField {
    public static void main(String[] args) {
        // Создаем объект GoblinFire
        GoblinFire goblinObj = new GoblinFire();
        // Обращение к полю ammo
        goblinObj.ammo++;
    }
}
```

Имейте в виду, что прямое обращение к полю другого класса является примером плохого стиля, поскольку нарушает принципы ООП. Все обращения должны происходить к методам, которые уже сами меняют значения полей в соответствии с заложенной в них логикой.

Также рекомендуется давать всем полям класса минимальный из всех возможных уровней доступа. Это означает, что большинство полей класса должны иметь уровень доступа `private`. Остальные уровни доступа должны даваться отдельным переменным только в том случае, если это действительно нужно.

При объявлении полей можно в одной инструкции объявить несколько полей с одинаковым типом и одинаковыми модификаторами, но соглашение по оформлению кода так делать не рекомендует:

```java
// Так делать НЕ рекомендуется
int x, y, z; // Объявляем три переменные: x, y, z
```

### 5.3. Объявление методов

Мы уже видели примеры объявления методов в главе 1 "Введение" и в примере доступа к полям в данном разделе.

Пример объявления метода:

```java
// GoblinMethods.java
package ru.urvanov.javaindynamics2022.classes;

public class GoblinMethods {
    private int hitPoints;

    public int fire(boolean withAim, double windDirection, double windPower) {
        // ... инструкции...
        return hitPoints;
    }
}
```

Объявление метода состоит из следующих частей:

1.  Модификатор доступа: `private`, без модификатора (`package-private`), `protected`, `public`.
2.  Ключевое слово `static`, если нужно (будет описано позже).
3.  Ключевое слово `final`, если нужно (будет описано позже).
4.  Тип возвращаемого значения (в данном примере `int`) или `void`, если метод не возвращает значение.
5.  Имя метода (в этом примере `fire`).
6.  Список параметров (в нашем примере три параметра: `withAim`, `windDirection`, `windPower`).
7.  Список исключений (будет описан в последующих разделах).
8.  Тело метода в фигурных скобках.

Модификаторы доступа, `static` и `final`, могут располагаться в любом порядке, но по соглашению о написании кода принят именно такой порядок, который описан здесь.

Имя метода может содержать символы подчеркивания, знак доллара, цифры и многие другие символы Юникода (даже русские буквы), но не может начинаться с цифры, так же как и имя переменной. Однако по соглашению об оформлении кода на именование методов распространяются почти такие же правила, что и на именование переменных, с тем отличием, что имя метода должно быть глаголом:

`fire`, `buildObject`, `connect`, `compareTo`.

Если в объявлении метода не используется ключевое слово `void`, то метод должен явно вернуть значение с помощью оператора `return`. Пример:

```java
// GoblinMethods.java
public int returnSix() {
    return 6;
}
```

В операторе `return` можно указать выражение, тогда оно будет вызвано, и результатом вызова метода будет результат этого выражения:

```java
// GoblinMethods.java
public double sum(double x1, double x2) {
    return x1 + x2;
}
```

Тип возвращаемого значения должен совпадать с тем, что указан в объявлении, иначе будет ошибка компиляции. Если в объявлении присутствует ключевое слово `void`, то использование `return` необязательно, но его можно указать для досрочного завершения выполнения метода:

```java
// GoblinMethods.java
public void myVoidMethod1() {
    // ...
    if (hitPoints > 3) {
        return;
    }
    //...
}
```

В качестве типа возвращаемого значения может использоваться имя интерфейса или класса.

Если в качестве возвращаемого значения указан интерфейс, то метод должен вернуть экземпляр любого класса, реализующего этот интерфейс, или `null`.

Если в качестве возвращаемого значения указан класс, то метод должен вернуть экземпляр этого класса, экземпляр его класса-потомка или `null`.

Сигнатура метода — это имя метода вместе со списком его параметров.

Java различает методы между собой по их сигнатуре. В одном классе не может быть двух и более методов с одинаковой сигнатурой, но, поскольку список параметров входит в сигнатуру методов, их можно перегружать.

Перегрузка методов — создание нескольких методов с одинаковым именем, но разным списком параметров.

Перегрузка методов позволяет создавать, например, для каждого типа свою реализацию метода с тем же именем, но другим типом параметра, либо создать отдельный метод, принимающий другое количество параметров.

Пример перегрузки методов:

```java
// GoblinMethods.java
class GoblinMethods {
    public void hit(Axe axe) {
        // ... инструкции...
    }

    public void hit(Flail flail) {
        // ... инструкции...
    }

    public void hit(Scimitar scimitar) {
        // ... инструкции...
    }

    public void hit(Torch torch) {
        // ... инструкции...
    }

    public void hit(Sword sword) {
        // ... инструкции...
    }

    public void hit(Sword sword, int comboCount) {
        // ... инструкции...
    }
}
```

Все методы в примере выше — это разные методы. Компилятор различает их по списку параметров. Возвращаемое значение не входит в сигнатуру метода, а значит, вы не можете создать несколько методов с одинаковым именем и параметрами, но разными возвращаемыми значениями.

Примеры вызова методов `hit`:

```java
// GoblinMethods.java
Scimitar scimitar = new Scimitar();
goblin.hit(scimitar); // будет вызван public void hit(Scimitar scimitar)

Sword sword = new Sword();
goblin.hit(sword); // будет вызван public void hit(Sword sword)
```

Не стоит злоупотреблять перегрузкой методов. Используйте ее только там, где это действительно нужно, иначе это может усложнить понимание вашего кода другими разработчиками.

### 5.4. Конструкторы

Конструкторы вызываются для создания объектов. Они похожи на методы, но не имеют возвращаемого значения (даже `void`), и они носят то же самое имя, что и сам класс.

Пример конструктора для класса `GoblinConstructor`:

```java
// GoblinConstructor.java
public GoblinConstrutor(int initialMoney, double initialHealth) {
    money = initialMoney;
    health = initialHealth;
}
```

Теперь, чтобы создать экземпляр класса `GoblinConstructor`, нужно вызвать конструктор с ключевым словом `new`:

```java
GoblinConstructor myGoblin = new GoblinConstructor (8, 100.0);
```

Код выше создаст экземпляр класса `GoblinConstructor` с помощью нашего конструктора и присвоит ссылку на этот класс переменной `myGoblin`.

С помощью перегрузки можно создать несколько конструкторов, но они должны иметь различное количество или тип параметров:

```java
// GoblinConstructor.java
package ru.urvanov.javaindynamics2022.classes;

public class GoblinConstructor {
    private int money;
    double health;
    protected int diamonds = 10;
    public String name;

    // Конструктор без параметров.
    public GoblinConstructor() {
    }

    // Конструктор с двумя параметрами
    public GoblinConstructor(int initialMoney, double initialHealth) {
        money = initialMoney;
        health = initialHealth;
    }

    // Конструктор с одним параметром.
    public GoblinConstructor(String goblinName) {
        name = goblinName;
    }

    // Приватный конструктор. Его можно будет вызвать
    // только внутри этого класса.
    private GoblinConstructor(int initialDiamonds) {
        diamonds = initialDiamonds;
    }
    //... еще конструкторы и методы
}
```

Теперь мы можем создавать экземпляры класса `GoblinConstructor`, используя любой из этих конструкторов, но приватный можно вызывать только внутри самого класса `GoblinConstructor` (например, в одном из его методов или полей инициализации).

```java
// GoblinConstructor.java
GoblinConstructor goblin0 = new GoblinConstructor();
GoblinConstructor goblin1 = new GoblinConstructor("Vasya");
GoblinConstructor goblin2 = new GoblinConstructor(3, 45.0);
```

Если мы не объявим ни одного конструктора в описании класса, то компилятор добавит один конструктор по умолчанию без параметров и с модификатором доступа `public`. Если же мы объявим хотя бы один конструктор, даже приватный, то конструктор без параметров добавляться не будет, но мы можем объявить его сами, если нужно.

**ХИТРОСТЬ**

Операция `new` возвращает ссылку на объект. Можно сразу же вызвать какой-нибудь метод этого объекта или обратиться к свойству, не присваивая эту ссылку переменной:

```java
new GoblinConstructor(myParam1).someMethod1(myParam2);
```

Если метод тоже возвращает ссылку на объект, то можно сразу вызвать метод этого объекта:

```java
// GoblinConstructor.java
new GoblinConstructor(myParam1)
  .someMethod1(myParam2).someMethod2();
//... и т. д.
```

Ключевые слова `static`, `final` и `abstract` будут описаны позднее, но если вы перечитываете учебник второй раз, то:

**ЗАПОМНИТЕ**

Конструктор **НЕ** может быть `static`, `final` или `abstract`.

### 5.5. Передача параметров

Метод может иметь любое число параметров, но каждый параметр должен иметь уникальное имя в пределах описания этого метода. Нельзя объявить метод, у которого два параметра называются одинаково, даже если они имеют разный тип. Имя параметра не может совпадать с именем локальной переменной, объявленной в методе. Однако имя параметра может совпадать с именем поля класса, в этом случае параметр затеняет (shadows) поле, поскольку при прямом обращении к этому имени мы будем обращаться к параметру, а не к полю класса.

Параметры, описанные в объявлении метода, называются формальными. Значения, передаваемые в формальные параметры при вызове метода или конструктора, называются аргументами или фактическими параметрами.

Вы можете использовать любой примитивный тип для параметров, объект или массив.

Примитивные типы передаются по значению — изменения внутри метода или конструктора не отражаются на значении переменной, которую передали:

```java
// PrimitiveTypeParameters
package ru.urvanov.javaindynamics2022.classes;

/**
 * Пример передачи параметров примитивных типов.
 * Они передаются по значению.
 */
public class PrimitiveTypeParameters {
    public void tryChangeParameterValue(int val1) {
        // Мы можем менять значение val1,
        // но val1 содержит копию переданного значения.
        // Все изменения val1 видны только внутри этого метода
        System.out.println("Inside method 2: " + val1); // 100
        val1++;
        System.out.println("Inside method 2: " + val1); // 101
    }

    public static void main(String[] args) {
        PrimitiveTypeParameters primitiveTypeParameters = new PrimitiveTypeParameters();
        int parameter1 = 100;
        System.out.println("parameter1 = " + parameter1); // 100
        primitiveTypeParameters.tryChangeParameterValue(parameter1);
        System.out.println("parameter1 = " + parameter1); // 100
        // изменения внутри метода происходили
        // с копией переменной, а не с нашим
        // parameter1.
    }
}
```

Объекты и массивы передаются по ссылке: изменения внутри метода или конструктора меняют объект, который нам передали. Однако, если внутри метода присвоить значению параметра `null` или ссылку на другой объект/массив, такое изменение коснется только параметра метода, а исходный объект или массив останется неизменным.

Пример:

```java
// GoblinWithMoney.java
package ru.urvanov.javaindynamics2022.classes;

/**
 * Передача параметров по ссылке.
 */
public class GoblinWithMoney {
    private int money;

    /**
     * @param goblinMoney передается по ссылке.
     *                    Меняя его поля, мы меняем исходный объект.
     * @param arr1        тоже передается по ссылке.
     *                    Меняя значения в нем, мы меняем исходный массив.
     */
    public static void tryChangeParameterValue(
      GoblinWithMoney goblinMoney,
      int[] arr1) {
        // Эти изменения будут видны снаружи метода.
        goblinMoney.money++;
        arr1[0] = 200;

        // Эти изменения затрагивают только наш параметр ссылочного типа
        // Объекты снаружи метода не будут изменены.
        goblinMoney = null;
        arr1 = null;
        goblinMoney = new GoblinWithMoney();
        goblinMoney.money = -400;
        arr1 = new int[100];
        arr1[2] = 3;
    }

    public static void main(String[] args) {
        GoblinWithMoney goblin = new GoblinWithMoney();
        goblin.money = 45;
        int[] arr1 = {3, 4, 7};
        tryChangeParameterValue(goblin, arr1);
        System.out.println(goblin.money); // 46
        System.out.println(arr1[0]); // 200;
        System.out.println(arr1[2]); // 7
    }
}
```

Выведет в консоль:

```
46
200
7
```

Иногда бывает полезно иметь метод с произвольным числом параметров. В таком случае можно передавать ему массив в качестве параметра. Однако в Java есть возможность создать метод, принимающий произвольное число параметров. Для этого после типа последнего параметра ставится многоточие, а внутри метода этот параметр обрабатывается как обычный массив. Пример:

```java
// Varargs.java
package ru.urvanov.javaindynamics2022.classes;

/**
 * Пример метода с переменным числом параметров
 */
public class Varargs {
    public void sum(
      int par1,
      double par2,
      String par3,
      int... lastParameter) {
        System.out.println("lastParameter[0] = "
          + lastParameter[0]); // 3
        System.out.println("lastParameter[1] = "
          + lastParameter[1]); // 5
        //...
    }

    public static void main(String[] args) {
        Varargs main = new Varargs();
        main.sum(100, 3.4, "par3", 3, 5, 6, 8, 9);
    }
}
```

Многоточие является токеном само по себе, и технически корректно ставить пробел между типом и многоточием, но, согласно принятому соглашению по оформлению кода в Java, так делать не рекомендуется.

При вызове метода или конструктора можно передавать выражение, и тогда в метод или конструктор поступит вычисленное значение этого выражения. Параметры методов и конструкторов вычисляются слева направо: сначала вычисляется первый параметр, затем второй и т. д. Вызов метода происходит только после того, как все параметры будут вычислены.

### 5.6. Сборка мусора

В некоторых языках программирования нужно вручную освобождать память, выделенную под объекты. В Java такой необходимости нет. Виртуальная машина Java сама освобождает память от объектов, которые больше не используются. Объект считается более не использующимся, если на него больше нет ссылок. Ссылки на объект обычно исчезают после того, как объект выходит из своей области видимости. Вы можете самостоятельно убрать ссылку на объект, присвоив переменной значение `null`.

Сборщик мусора автоматически освобождает память от объектов, которые больше не используются, когда сочтет нужным.

### 5.7. Ключевое слово `this`

Если переменная, объявленная в методе, или параметр метода имеет то же самое имя, что и свойство класса, то эта переменная затеняет свойство класса. Обращаясь по имени переменной, в этом случае мы будем обращаться к переменной метода или к параметру метода, а не к свойству класса. Чтобы обратиться к затененному свойству класса, нужно использовать ключевое слово `this`, которое означает этот класс.

```java
// Orc.java
package ru.urvanov.javaindynamics2022.classes;

class Orc {
    double health = 100.0;

    public void someMethod1() {
        double health = 200.0;
        System.out.println(health); // 200.0
        System.out.println(this.health); // 100.0
    }

    public void setHealth(double health) {
        // присваиваем свойству класса
        // переданное значение
        this.health = health;
    }

    public static void main(String[] args) {
        Orc orc = new Orc();
        orc.setHealth(999.9);
        orc.someMethod1();
        ;
    }
}
```

Ключевое слово `this` может также использоваться для вызова из конструктора класса другого конструктора этого класса. Вызов другого конструктора должен быть обязательно первым оператором/инструкцией в конструкторе:

```java
// LegendaryBeast.java
package ru.urvanov.javaindynamics2022.classes;

class LegendaryBeast {
    private double health;
    private int ammo;
    private int gold;

    public LegendaryBeast() {
        this(100.0, 0, 0);
        // ... остальная инициализация.
    }

    public LegendaryBeast(double health) {
        this(health, 0, 0);
        // ... остальная инициализация.
    }

    public LegendaryBeast(double health, int ammo) {
        this(health, ammo, 0);
        // ... остальная инициализация.
    }

    public LegendaryBeast(double health, int ammo, int gold) {
        this.health = health;
        this.ammo = ammo;
        this.gold = gold;
    }
}
```

В этом примере класс `LegendaryBeast` имеет несколько конструкторов с разным числом параметров (перегруженные конструкторы). Конструкторы с меньшим числом параметров вызывают конструктор с самым большим количеством параметров.

Компилятор Java различает эти конструкторы по параметрам (типу, количеству и порядку).

### 5.8. Ключевое слово `static`

При создании каждый объект получает свой отдельный набор переменных экземпляров. Если же нужно сделать какую-то переменную разделяемой для всех экземпляров, то используется ключевое слово `static`.

Пример:

```java
// GoblinWithCounter.java
package ru.urvanov.javaindynamics2022.classes;

class GoblinWithCounter {
    static int idCounter = 0;
    int id;

    GoblinWithCounter() {
        idCounter++;
        id = idCounter;
    }
}
```

В таком классе `GoblinWithCounter` переменная `idCounter` одна, общая для всех экземпляров. Для всех экземпляров этого класса значение этой переменной будет всегда одно и то же, благодаря чему каждый экземпляр класса будет получать в поле `id` уникальное значение, большее, чем значение поля `id` предыдущего экземпляра. Переменная `idCounter` называется статическим свойством/полем или переменной класса и относится к классу, а не к его экземплярам.

Обратиться к статическому свойству можно либо через имя класса, либо через имя экземпляра, однако рекомендуется всегда обращаться к статическим свойствам через имя класса, чтобы подчеркнуть, что оно относится именно к классу:

```java
System.out.println("idCounter=" + GoblinWithCounter.idCounter); // предпочтительно
GoblinWithCounter goblin = new GoblinWithCounter();
System.out.println("idCounter=" + goblin.idCounter); // нежелательно
```

Статическое свойство также может иметь модификаторы `private`, `protected` или `public`.

Модификатор `static` можно применить к методу, тогда он будет статическим, и его можно будет вызывать через имя класса:

```java
static int getIdCounter() {
    return idCounter;
}
```

Пример вызова:

```java
int x = Goblin.getIdCounter();
```

Статические методы можно вызывать и через имя экземпляра, но рекомендуется всегда вызывать их через имя класса, т. к. они относятся именно к нему.

К статическим методам и свойствам можно обратиться даже тогда, когда еще нет ни одного экземпляра класса.

Запомните:

*   Методы экземпляров могут обращаться к переменным экземпляров (нестатическим свойствам/полям) и методам экземпляров напрямую.
*   Методы экземпляров могут обращаться к переменным класса (статическим полям) и методам класса (статическим методам) напрямую.
*   Методы классов могут обращаться к методам класса (статическим методам) и переменным класса (статическим свойствам/полям) напрямую.
*   Методы классов не могут напрямую обращаться к переменным экземпляров (нестатическим свойствам/полям) и методам экземпляров, и они не могут использовать ключевое слово `this`, т. к. для них нет экземпляра класса. Они должны использовать ссылку на какой-нибудь экземпляр.

### 5.9. Ключевое слово `final`

Это ключевое слово больше относится к наследованию, которое будет рассмотрено в дальнейших разделах. Здесь я опишу `final` лишь в общих чертах.

Ключевое слово `final` может быть применено к локальной переменной, переменной экземпляра или параметру. Оно означает, что значение переменной не будет меняться после инициализации. Если попытаться изменить значение такой переменной, то возникнет ошибка компиляции.

```java
// GoblinFinal.java
class GoblinFinal {
    final String name;

    public GoblinFinal(String name) {
        this.name = name; // Инициализируем переменную final.
    }

    public void someMethod1(final String secondName) {
        final String thirdName = "Third";

        // Переменные с final менять после инициализации нельзя!
        // this.name = secondName; // Нельзя! Ошибка компиляции.
        // secondName = "3"; // Нельзя! Ошибка компиляции.
        // thirdName = "4"; // Нельзя! Ошибка компиляции.
    }
    // . . .
}
```

Переменные `final` не инициализируются значением по умолчанию. Им обязательно должно быть присвоено какое-нибудь значение, иначе возникнет ошибка компиляции.

Ключевое слово `final` может применяться к методу, тогда этот метод нельзя переопределять в классах-потомках для методов экземпляров и нельзя скрывать (hide) в классах потомках для случая статических методов (наследование и переопределение метода будут описаны в разделе про наследование):

```java
// GoblinFinal.java
class GoblinFinal {
    // . . .

    // Этот метод нельзя переопределять в потомках.
    public final void myFinalMethod1() {
    }

    // Этот метод нельзя скрывать в потомках.
    public static final void myFinalMethod2() {
    }
    // . . .
}
```

Можно применить `final` ко всему классу, это означает, что у класса не может быть потомков, т. е. нельзя будет наследоваться от этого класса.

```java
// GoblinFinalClass.java
final class GoblinFinalClass {
}
```

Модификатор `static`, примененный совместно с `final` к свойствам класса, используется для объявления констант. Такое свойство не может быть изменено после инициализации, и оно обязательно должно быть проинициализировано.

Компилятор подставляет реальное значение констант во все места программы, где они используются. Если значение константы пришлось впоследствии поменять, то нужно перекомпилировать все классы, которые ее используют, т. к. иначе там останется старое значение константы.

Пример объявления константы:

```java
// GoblinFinal.java
static final double PI = 3.141592653589793;
```

По соглашению об именовании имена констант записываются прописными буквами, а между словами ставится символ подчеркивания.

### 5.10. Инициализация полей

Полям можно присвоить начальное значение сразу при объявлении:

```java
// GoblinInitializeFields.java
public class GoblinInitializeFields {
    int x = 300;
    int y = x * 3; // Будет вычислено значение и присвоено 900.

    public static void main(String[] args) {
        GoblinInitializeFields spider = new GoblinInitializeFields();
        System.out.println(spider.x);
        System.out.println(spider.y);
    }
    // . . . Остальная часть класса
}
```

Инициализация происходит сверху вниз в порядке объявления в исходном коде.

Сначала `x` присвоится 300, а затем `y` присвоится 300 * 3.

Если выражение инициализации не помещается в одну строку или требуется обработка ошибок, использование циклов и прочее, то можно задействовать блоки инициализации:

```java
// GoblinInitializeFields.java
class GoblinInitializeFields {
    // ... начало класса

    static int idCounter;
    int money;

    static {
        // Инициализация статических полей
        idCounter = 3;
    }

    {
        // Инициализации переменных экземпляров.
        money = 300;
    }
}
```

Блоки статической инициализации выполняются однократно при инициализации класса. Может быть несколько блоков инициализации, и в таком случае они будут выполняться в том порядке, в котором фигурируют в исходном файле сверху вниз.

Блоки инициализации экземпляров выполняются при создании экземпляров объекта. Может быть несколько блоков инициализации экземпляров, в таком случае они выполняются в порядке появления в исходном файле.

Не стоит слишком сильно перемешивать блоки инициализации, конструкторы и инициализацию при объявлении, иначе код может получиться запутанным и сложным для понимания. Однако при наличии всех этих видов инициализации в одном классе инициализация экземпляра происходит так:

1.  Вычисляются аргументы конструктора. Если конструктор начинается с вызова другого конструктора этого класса, то вычисляются и его аргументы и т. д.
2.  Если конструктор не начинается с вызова другого конструктора, то он начинается с явного или неявного вызова конструктора базового класса (будет описано в разделе про наследование), и выполняется этот конструктор базового класса.
3.  Выполняются все выражения инициализации экземпляров и блоки инициализации экземпляров в том порядке, в котором они объявлены в исходном файле, словно они идут одним блоком.
4.  Выполняется остаток тела конструктора.

Пример:

```java
// SpiderInitializeFields.java
package ru.urvanov.javaindynamics2022.classes;

public class SpiderInitializeFields {
    int x1;

    {
        x1 = 100;
    }

    int x2 = x1 + 1;

    SpiderInitializeFields() {
        x1 = 200;
    }

    int x3 = x1 + 2;

    {
        x1 = -100;
    }

    public static void main(String[] args) {
        SpiderInitializeFields s = new SpiderInitializeFields();
        System.out.println("x1=" + s.x1);
        System.out.println("x2=" + s.x2);
        System.out.println("x3=" + s.x3);
    }
}
```

Выведет в консоль:

```
x1=200
x2=101
x3=102
```

