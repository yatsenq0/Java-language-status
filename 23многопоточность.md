## Глава 23: Многопоточность

### 23.1 Класс Thread

Каждый поток ассоциирован с классом `java.lang.Thread`. Есть два основных способа использования объектов `Thread` в многопоточном программировании:

- **Создание потоков и управление ими с помощью экземпляров класса Thread**.
- **Абстрагирование от управления потоками и передача задач в executor**.

Есть два способа запуска кода в другом потоке с помощью `Thread`:

1. **Предоставить экземпляр класса, реализующего интерфейс `java.lang.Runnable`**:  
   Экземпляр класса `java.lang.Runnable` передается в конструктор класса `Thread`.

   ```java
   // RunnableImpl.java
   package ru.urvanov.javaindynamics2022.multithreading;

   public class RunnableImpl implements Runnable {
       public void run() {
           System.out.println("Текст из другого потока");
       }

       public static void main(String args[]) {
           (new Thread(new RunnableImpl())).start();
       }
   }
   ```

2. **Написать подкласс класса Thread**:  
   Класс `Thread` сам реализует интерфейс `java.lang.Runnable`, но его метод `run()` ничего не делает. Приложение может унаследовать класс от `Thread` и переопределить метод `run()`.

   ```java
   // ThreadChild.java
   package ru.urvanov.javaindynamics2022.multithreading;

   public class ThreadChild extends Thread {
       public void run() {
           System.out.println("Текст из другого потока");
       }

       public static void main(String args[]) {
           (new ThreadChild()).start();
       }
   }
   ```

В обоих случаях мы используем метод `Thread.start()` для запуска нового потока. Именно он запускает отдельный поток. Если просто вызывать метод `run()`, то код будет выполняться в том же потоке, отдельный поток создаваться не будет.

Первый способ, где предоставляется экземпляр класса, реализующего «Runnable», более общий, так как в этом случае класс может наследоваться от отличного от «Thread» класса. Второй способ легче использовать в простых приложениях, но он ограничен тем, что ваш класс будет наследником «Thread».

### Метод sleep()

Метод «sleep» (`sleep`) из пакета «classa» (`classa`) останавливает выполнение текущего потока на указанное время. Он используется когда нужно освободить процессор чтобы он занялся другими процессами или задал интервал между действиями.

Есть два варианта методов sleep:
- Первый принимает количество миллисекунд (`millis`) на которое нужно остановить текущий процесс.
- Второй дополнительно принимает второй параметр — количество наносекунд (`nanos`) на которые нужно дополнительно остановить процесс:
  ```java
  public static void sleep(long millis) throws InterruptedException;
  public static void sleep(long millis, int nanos) throws InterruptedException;
  ```
где 
- `_millis_`: это количество миллисекунд,
- `_nanos_`: это количество наносекунд дополнительно к _millis_.

Время остановки процесса неточно и зависит от возможностей системы; состояние ожидания для процесса может быть прервано извне
Конечно, вот отформатированный текст:

## Пример: `SleepExample.java`

```java
package ru.urvanov.javaindynamics2022.multithreading;

public class SleepExample {
    public static void main(String args[]) throws InterruptedException {
        for (int n = 0; n < 10; n++) {
            // Ждем 2 секунды
            Thread.sleep(2_000);
            
            // Выводим значение счетчика цикла
            System.out.println(n);
        }
    }
}
```

Обратите внимание: метод `main` объявляет, что он бросает исключение `InterruptedException`. Это исключение генерируется методом `sleep`, если поток прерывается во время ожидания внутри `sleep`. Поскольку эта программа не объявила никаких других потоков, которые могут прерывать текущий, ей вовсе не обязательно обрабатывать это исключение.

### Прерывание (interrupt)

Прерывание — это сигнал для потока о том, что он должен прекратить делать то, что он делает сейчас, и делать что-то другое. Что должен делать поток в ответ на прерывание, решает программист, но обычно поток завершается.

Поток отправляет прерывание вызовом метода `public void interrupt()` класса `Thread`. Для того чтобы механизм прерывания работал корректно, прерываемый поток должен поддерживать возможность прерывания своей работы.

### Поддержка Прерывания

Как поток должен поддерживать прерывание своей работы? Это зависит от того, что он сейчас делает. Если поток часто вызывает методы, которые могут бросить исключение `InterruptedException`, то он просто вызывает return при перехвате подобного исключения. Пример:

```java
try {
    Thread.sleep(1_000);
} catch (InterruptedException e) {
    // Ожидание было прервано
    return;
}
```

Многие методы, которые бросают исключение `InterruptedException`, например методы sleep или wait(), останавливают свое выполнение и возвращают управление в вызвавший их код при получении сигнала о перерывании.

Если же поток выполняется длительное время без вызова таких методов или операций ввода-вывода с блокировкой (например I/O), то он может периодически проверять наличие сигнала о перерывании с помощью статического метода класса Thread — **`Thread.interrupted()`**:

```java
for (int i = 0; i < monsters.length; i++) {
    recalculateStats(monsters[i]);
    
    if (Thread.interrupted()) {
        // Обработка параметров монстров была прервана. Выходим.
        return;
    }
}
```

В этом примере код просто проверяет наличие сигнала о перерывании и выходит из цикла/метода/потока при его наличии. В более сложных приложениях имеет смысл бросить новое исключение InterruptedException:

```java
if (Thread.interrupted()) {
    throw new InterruptedException();
}
```

Это позволяет располагать код обработки перерывания в одной клаузе catch.

### Механизм Перевивания

Механизм перевивания реализован с помощью внутреннего флага — статуса перевивания (`interrupt status`). Вызов **`Thread.interrupt()`** устанавливает этот флаг. Когда же сам текущий тред проверяет наличие перевивания через **`Thread.interrupted()`**, то этот флаг сбрасывается после проверки.

Нестатический **`isInterrupted()`**, который используется одним тредом для проверки статуса перевивания другого треда без изменения этого флага.

По соглашению любой метод из стандартной библиотеки Java который выбрасывает Исключения типа InterruptedException очищает статус перевивания когда выбрасывает это исклю-чение Однако есть вероятность того что статус будет сразу же установлен еще раз если другой тред снова вызовет interrupt() на этом объекте 

## Метод Join

Метод join позволяет одному треду ждать завершения другого треда:
- Если t является экземпляром класса Thread чей процесс продолжается 
- Тогда t.join(); приведет к остановке выполнения текущего процесса до тех пор пока процесс t не завершит свою работу.
  
Метод join() имеет варианты с параметрами для указания максимального времени ожидания: 

```java
t.join(long millis); 
t.join(long millis,int nanos); 
```
Эти варианты позволяют задать максимальное время ожидания перед тем как продолжить выполнение основного процесса даже если целевой процесс еще работает
Конечно, вот отформатированный текст:

## Методы `join()`

Методы `join()` в Java позволяют одному потоку ждать завершения другого. Существуют два варианта этих методов:

```java
public final void join(long millis) throws InterruptedException;
public final void join(long millis, int nanos) throws InterruptedException;
```

Эти методы позволяют задать время в миллисекундах и дополнительно количество наносекунд, в течение которых ждать завершения выполнения потока. Однако, как и с методами `sleep`, методы `join` зависят от возможностей операционной системы, поэтому вы не должны полагаться на то, что `join` будет ждать точно указанное время.

Как и методы `sleep`, методы `join` отвечают на сигнал прерывания, останавливая процесс ожидания и бросая исключение `InterruptedException`.

## Пример использования

Пример состоит из двух потоков. Первый является главным потоком приложения (который есть в каждой программе на Java), который создает новый поток и ждет его завершения. Если второй поток выполняется слишком долго, то главный прерывает его.

### InterruptJoinExample.java

```java
package ru.urvanov.javaindynamics2022.multithreading;

public class InterruptJoinExample {
    
    // Выводим сообщение с именем текущего потока в начале.
    static void writeMessage(String message) {
        String threadName = Thread.currentThread().getName();
        System.out.format("[%s]: %s%n", threadName, message);
    }

    private static class Counter implements Runnable {
        
        public void run() {
            try {
                for (int n = 0; n < 5; n++) {
                    // Ждем 2 секунды
                    Thread.sleep(2000);
                    
                    // Выводим значение счетчика цикла
                    writeMessage("counter " + n);
                }
            } catch (InterruptedException interruptedException) {
                writeMessage("Thread interrupted");
            }
        }
    }

    public static void main(String args[]) throws InterruptedException {
        
        writeMessage("Starting Counter");
        
        long startTime = System.currentTimeMillis();
        
        Thread t = new Thread(new Counter());
        
        t.start();
        
        writeMessage("Waiting for Counter to finish");
        
        // Ждем пока MessageLoop существует
        while (t.isAlive()) {
            writeMessage("calling join...");
            
            // Ждем максимум 1 секунду завершения потока Counter
            t.join(1000);
            
            // Максимально 10 секунд.
            // Если поток не успел, то посылаем ему сигнал прерывания.
            if (((System.currentTimeMillis() - startTime) > 10000)
                    && t.isAlive()) {
                writeMessage("Interrupting...");
                
                t.interrupt();
                
                // Должно быть недолго теперь.
                // -- Ждем до конца 
                t.join(); 
            }
        }
        
        writeMessage("DONE");
    }
}
```

## Синхронизация Потоков

Потоки общаются между собой путем разделения своих полей или полей объектов друг с другом. Для управления доступом к общим ресурсам используются механизмы синхронизации: блоки синхронизации (`synchronized`) или другие инструменты из пакета `java.util.concurrent`.
Конечно, вот отформатированный текст:

## Введение в ошибки многопоточности

При использовании нескольких потоков могут возникнуть два типа ошибок: **вмешательство в поток (thread interference)** и **ошибки консистентности памяти (memory consistency errors)**. Для предотвращения этих ошибок необходимо использовать синхронизацию потоков.

Однако синхронизация может привести к **конкуренции потоков (thread contention)**, которая возникает, когда два или более потока пытаются получить доступ к одному и тому же ресурсу одновременно. Это приводит к тому, что среда выполнения Java выполняет один или более этих потоков медленнее или даже приостанавливает их выполнение. **Голодание (starvation)** и **активная блокировка (livelock)** — это формы конкуренции потоков.

## 23.3 Вмешательство в поток

Рассмотрим простой класс `Counter`:

```java
package ru.urvanov.javaindynamics2022.multithreading;

// Пример вмешательства в поток (thread interference)
class Counter {
    private int value = 0;

    public void increment() {
        for (int n = 0; n < 100_000; n++) {
            value++;
        }
    }

    public void decrement() {
        for (int n = 0; n < 100_000; n++) {
            value--;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        
        Thread threadIncrement = new Thread(counter::increment);
        Thread threadDecrement = new Thread(counter::decrement);
        
        threadIncrement.start();
        threadDecrement.start();
        
        threadIncrement.join();
        threadDecrement.join();

        // Каждый раз будем получать разный результат,
        // из-за того что потоки несинхронизированы.
        // Это последствия thread interference.
        
        System.out.println(counter.getValue());
    }

    private int getValue() {
        return value;
    }
}
```

Каждый вызов метода `increment` добавляет `1` к переменной `value` в цикле `100_000` раз, а каждый вызов метода `decrement` вычитает `1` из переменной `value`. Однако если объект `Counter` используется несколькими потоками, то может произойти **вмешательство в поток**, которое помешает коду работать так, как ожидается.

**Вмешательство в поток** происходит тогда, когда два действия выполняются разными потками но используют одни и те же данные. Это означает, что два действия содержат несколько шагов и последовательность шагов частично перекрывается.

Может показаться, что операции над экземплярами класса не могут перекрываться потому что все операции над переменной являются одиночными простыми инструкциями. Однако...
Конечно, вот отформатированный текст:

## Ошибки Многопоточности

Даже простые инструкции могут транслироваться виртуальной машиной в несколько шагов. Выражение C++ может быть разложено на три шага:
1. **Получить текущее значение** `value`.
2. **Увеличить полученное значение** на 1.
3. **Сохранить увеличенное значение** в `value`.

Предположим, что поток `threadIncrement` вызывает `increment`, и в то же самое время поток `threadDecrement` вызывает `decrement`. Начальное значение `c` равно 0; их пересеченные действия могут породить следующую последовательность шагов:
1. Поток `threadIncrement` получает значение.
2. Поток `threadDecrement` получает значение.
3. Поток `threadIncrement` увеличивает полученное значение, в результате получает 1.
4. Поток `threadDecrement` уменьшает полученное значение, в результате получает –1.
5. Поток `threadIncrement` сохраняет результат 1 в переменную.
6. Поток `threadDecrement` сохраняет результат –1 в переменную.

Результат потока `threadIncrement` потерян; он был перезаписан потоком `threadDecrement`. Такое частичное перекрытие действий — это только один из вариантов; иногда может оказаться, что результат потока «уменьшения» будет потерян либо ошибки не будет совсем.

Из-за этого ошибки взаимодействия между потками трудно обнаруживать и исправлять.

### Глава 23: Многопоточность
#### 23.4 Ошибки Согласованности Памяти (Memory Consistency Errors)

Ошибки согласованности памяти возникают, когда разные потоки видят разные данные своих разделяемых объектов и полей данных.

Для исключения ошибок согласованности памяти нужно понимать связи «происходит до» (happens-before). Эта связь гарантирует, что данные записанные одной инструкцией видимы другой инструкцией.

Рассмотрим следующий пример:

Предположим поле типа int объявлено и инициализировано:
```java
int value = 0;
```

Поле value используется совместно двумя потками threadA и threadB аналогично тому как это было с примером Counter:

- Предположим что potok threadA увеличивает value:
```java
value++;
```
- Сразу после этого potok threadB выводит консольное сообщение со значением value:
```java
System.out.println(value);
```

Если бы обе инструкции были выполнены одним potоком можно было смело предположить что выведется число 1 Однако если две инструкции выполняются разными potками может быть выведено число 0 тк нет гарантии что изменение значения по умолчанию будет видно другим до тех пор пока не обеспечена связь happens-before между этими двумя операциями

Подробнее про happens-before читайте разделе "Java Memory Model".

#### 23.5 Синхронизированные (synchronized) методы

Язык программирования Java предоставляет два базовых способа синхронизации: синхронизированные методы (`synchronized methods`) и синхронизированные блоки (`synchronized statements`). Есть другие более сложные способы синхронизации которые будут рассмотрены позже

Вот отформатированный текст:

## Синхронизация методов

Чтобы сделать метод синхронизированным, просто добавьте ключевое слово `synchronized` к его объявлению.

### Пример: SynchronizedCounter.java

```java
package ru.urvanov.javaindynamics2022.multithreading;

public class SynchronizedCounter {
    private int value = 0;

    public void increment100000() {
        for (int n = 0; n < 100_000; n++) {
            increment();
        }
    }

    private synchronized void increment() {
        value++;
    }

    public void decrement100000() {
        for (int n = 0; n < 100_000; n++) {
            decrement();
        }
    }

    private synchronized void decrement() {
        value--;
    }

    public static void main(String[] args) throws InterruptedException {
        SynchronizedCounter counter = new SynchronizedCounter();

        Thread threadIncrement = new Thread(counter::increment100000);
        Thread threadDecrement = new Thread(counter::decrement100000);

        threadIncrement.start();
        threadDecrement.start();

        threadIncrement.join();
        threadDecrement.join();

        // Результат будет 0, т.к. методы increment и decrement синхронизированы.
        
System.out.println(counter.getValue());
}

private int getValue() { 
return value;
}
}
```

## Правила работы синхронизированных методов

- **Блокировка**: Два вызова синхронизированных методов на одном и том же объекте не могут пересекаться. Когда один поток выполняет синхронизированный метод объекта, то другие потоки, которые вызывают синхронизированные методы того же самого объекта, блокируются (приостанавливают свое выполнение) до тех пор, пока первый поток не завершит работу с объектом.

- **Связь происходит-до**: Когда синхронизированный метод завершает свое выполнение, то он автоматически устанавливает связь "происходит-до" со всеми последующими вызовами синхронизированных методов того же самого объекта. Это гарантирует, что изменения состояния объекта будут видимы для других потоков.

### Конструкторы и синхронзация

Конструкторы не могут быть синхронизированными — это не имеет смысла, так как объект всегда создается в одном конкретном потоке. Использование ключевого слова `synchronized` для конструктора приведет к ошибке компиляции.
Конечно, вот отформатированный текст:

## Предупреждение
Когда создаете объект, который будет совместно использоваться разными потоками, то будьте очень осторожны, чтобы ссылка на объект не "утекла" раньше времени.

Например, предположим, что вы хотите сделать список `List`, который содержит экземпляры каждого класса. Вы можете захотеть добавить следующую строку в ваш конструктор:
```java
engine.addGameObject(this);
```
Но тогда другие потоки смогут использовать `engine` для получения доступа к объекту до того, как его создание будет завершено.

## Синхронизированные Методы
Синхронизированные методы — простая стратегия для предотвращения вмешательства в поток (thread interference) и ошибок согласованности памяти (memory consistency errors). Если объект видим более чем одному потоку, то все чтения и записи полей объекта должны происходить через синхронизированные методы.

Использование синхронизированных методов достаточно просто, но в некоторых случаях недостаточно эффективно; в таких случаях можно использовать более эффективные способы синхронизации.

### Важное Исключение
Поля с модификатором `final`, которые не могут быть изменены после создания экземпляра объекта, могут безопасно читаться из несинхронизированных методов после создания конструктора.

### Работа Синхронизированных Методов
Синхронизированные методы построены на внутренних мониторах (блокировках). Когда поток вызывает синхронизированный метод, то он забирает этот монитор. А когда он выходит из синхронизированного метода — освобождает его. Использовать синхронизированные методы нужно с пониманием принципов их работы. Они не имеют никакого механизма защиты от deadlock-ов.

## Внутренние Мониторы и Синхронзация

Каждый объект в Java имеет свой внутренний монитор (блокировку). По соглашению поток должен получить внутренний монитор перед доступом к полям и освободить его после совершения необходимых действий. Только один поток может держать монитор одновременно. Однако возможна повторная получение одного и того же монитора — это называется "повторная синхρονзация" (reentrant synchronization).

Если вызывается статический синхRONИЗИрованный метод — блокируется классовый уровень (`Class`), отличный от блокироки любого экземпляра класса.

В отличие от синХРОНИЗИрованных мЕТОДОВ — инСТРУКЦии должны указывать конкретный обЪект-монитор:
```java
public void increment100000() {
    for (int n = 0; n < 100_000; n++) {
        synchronized (this) {
            value++;
        }
    }
}
```

Можно использовать другой обЪект-монитор внутри одного обЪектА:
```java
private Object lock1 = new Object();

public void increment100000() {
    for (int n = 0; n < 100_000; n++) {
        synchronized (lock1) {
            value++;
        }
    }
}
```

## Атомарный Доступ

В программирОвании атомарное действие происходит полностью или совсем не происходит без видимых эффектов до завершения действия.
- Чтение/запись атомарны для ссылочных переменных и большинства примитивных типов.
- Чтение/запись атомарны для всех переменных с ключевым словом `volatile`.
Вот отформатированный текст:

## Атомарные Действия и Синхронизация

Атомарные действия не могут пересекаться, и они могут использоваться без опасений о вмешательстве в поток. Однако это не устраняет все потребности синхронизации атомарных действий, так как ошибки консистенции памяти все еще возможны.

Использование `volatile`-переменных уменьшает риск ошибок консистенции памяти, потому что любая запись в `volatile`-переменную делает связь "происходит-до" (happens-before) для последующих чтений из этой переменной. Это означает, что изменения `volatile`-переменных всегда видны для других потоков. Это также означает, что когда поток читает `volatile`-переменную, он видит не только последнее изменение, но и все побочные эффекты кода, которые приводят к этому изменению.

Если `volatile`-переменных недостаточно, но использование других методов синхронизации слишком накладно, то можно использовать специальные классы `AtomicInteger`, `AtomicLong` и подобные. Подробнее они рассмотрены в разделе 23.8 "Атомарные переменные".

Использование простого атомарного доступа к переменным более эффективно, чем доступ к этим переменным из синхронизированного кода, но он требует большей внимательности от программиста для исключения ошибок консистентности памяти.

## 23.8 Атомарные Переменные

В этом разделе мы разберёмся с тем, как работают классы `AtomicInteger`, `AtomicLong` и остальные подобные классы из пакета `java.util.concurrent.atomic` в Java.

На самом деле в этих классах гораздо больше методов чем просто get(), set() и compareAndSet(). Сами эти классы наследуются от java.lang.Number , а значит они наследуют и реализуют все его методы: byteValue(), shortValue(), intValue(), longValue(), floatValue(), doubleValue(). Однако нам интересны не они а методы специфичные для атомарных классов типа AtomicInteger:

### Методы AtomicInteger
1. **int addAndGet(int delta)**  
   Атомарное увеличение значения на delta. Возвращает обновленное значение.
   
2. **boolean compareAndSet(int expect,int update)**  
   Сравнивает текущее значение с expect . Если они равны то сохраняет update  и возврашает true . В противном случае возврашает false .

3. **int decrementAndGet()**  
   Атомально уменьшает хранящееся значение на единицу . Возвращает новое значение .

4. **int get()**  
   Возвращает текущее хранящееся значение .

5. **int getAndAdd(int delta)**  
   Атомально добавляет delta к текущему значению . Возвращает предыдущее значение .

6. **int getAndDecrement()**  
   Атомально уменьшает хранящееся значение на единицу . Возвращает предыдущее значение .

7. **int getAndIncrement()**  
   Атомально увеличивает хранящееся значение на единицу . Возвращает предыдущее значение .

8. **int getAndSet(int newValue)**  
   Атормано устанавливает новое значенияи возврашет старое 

9..** int incrementAndGet()**
    -атомано увеличивет храящееся значениена еденицу 
    -и возращет новое значени 

10..void lazySet( int new Value)
     Устанавливаем новое значени спустя какоето время 
     Это новое значени может быть невидимо для других потоко како ето время 
     Они будут считывать старое значени 

11..void set( int new Value)
      Устанавливаем новое значени 

12..boolean weakCompareand Set ( int exspect , inr update )
       Анологично Compare and Set но может вернуть false И НЕ обновить Значение даже если храящеесия Значение равно ожидаемому

Конечно, вот отформатированный текст:

## AtomicInteger и AtomicLong

Для `AtomicLong` методы аналогичны тем, что есть у `AtomicInteger`, но они принимают и возвращают `long` вместо `int`.

Работа методов классов `AtomicInteger` и `AtomicLong` основана на специальной команде процессора CAS (compare-and-set), которая сначала сравнивает значение с ожидаемым и лишь потом заменяет его на новое.

**Примечание:** Имейте в виду, что у нас нет специальных атомарных классов для типов данных `byte`, `short`, `float` и `double`.

## 23.9. Взаимная блокировка (Deadlock)

Взаимная блокировка (deadlock) описывает ситуацию, когда два или более потока блокируются навсегда, ожидая один другого. Ниже приведен пример.

Предположим, что у нас есть система, работающая со счетами пользователей. Счета пользователей представлены классом `AccountWithDeadlock`.

### AccountWithDeadlock.java
```java
public class AccountWithDeadlock {
    private final int id;
    private int amount;

    public AccountWithDeadlock(int id) {
        this.id = id;
    }

    public int getId() {
        return this.id;
    }

    public int getAmount() {
        return this.amount;
    }

    public synchronized void transfer(AccountWithDeadlock fromAccount, int transferSum) {
        synchronized (fromAccount) {
            fromAccount.amount -= transferSum;
            this.amount += transferSum;
        }
    }
}
```

На первый взгляд может показаться, что все в порядке. Но на самом деле в этом коде спрятана взаимная блокировка. Если вызвать методы перевода средств (`transfer`) на первом счете и втором практически одновременно, то может произойти следующее:

1. **Блокировка первого счета**: Берется блокировка на первом счете.
2. **Переключение потоков**: Происходит переключение между потоками.
3. **Блокировка второго счета**: Берется блокировка на втором счете.
4. **Переключение потоков снова**: Происходит еще одно переключение между потоками.
5. **Ожидание освобождения второй блокировки**: Поток с первой блокировкой пытается взять вторую блокировку внутри синхронизованного блока но не может из-за того что она уже занята другим потоком.
6. **Ожидание освобождения первой блокировки**: Аналогично другой поток пытается взять первую уже занятую другому потоку.
7. Оба потока ждут освобождения друг друга навсегда

Конечно, вот отформатированный текст:

## Как избавиться от взаимных блокировок (deadlock)?

В данном случае можно обратить внимание на идентификатор счета `id`. Понятное дело, что каждый счет имеет уникальный идентификатор. Чтобы избежать взаимных блокировок (deadlock), мы можем всегда брать блокировки строго в порядке сортировки их идентификаторов, т.е. сначала меньший, а затем больший.

### Пример на Java

```java
public class AccountFixed {
    private final int id;
    private int amount;

    public AccountFixed(int id) {
        this.id = id;
    }

    public int getId() {
        return this.id;
    }

    public int getAmount() {
        return this.amount;
    }

    public void transfer(AccountFixed fromAccount, int transferSum) {
        AccountFixed firstBlock;
        AccountFixed secondBlock;

        if (this.id < fromAccount.id) {
            firstBlock = this;
            secondBlock = fromAccount;
        } else {
            firstBlock = fromAccount;
            secondBlock = this;
        }

        synchronized (firstBlock) {
            synchronized (secondBlock) {
                fromAccount.amount -= transferSum; 
                this.amount += transferSum; 
            }
        }
    }
}
```

Если же окажется так, что объекты, на которых нужно взять блокировку, не имеют уникальных полей, по которым можно определять меньший и больший объект, то можно ввести подобные поля синтетически.

## 23.10 Голодание (starvation)

Голодание описывает ситуацию, когда поток не может получить доступ к совместно используемым ресурсам и не может продвинуться в своем выполнении дальше. Это возникает когда совместно используемый ресурс делается недоступным на долгое время "жадными" потоками.

Например предположим что объект предоставляет синхронизированный метод который обычно выполняется достаточно долго. Если один поток вызывает этот метод часто то другие потоки которым тоже нужен частый синхронизированный доступ к тому же самому объекту будут часто блокироваться.

## 23.11 Активная блокировка (livelock)

Поток часто реагирует на события из другого потока. Если действие другого потока тоже является ответом на событие из еще одного потока то может произойти активная блокировка (livelock). Как и взаимная блокировка deadlock активно заблокированные потоки не могут продвинуться дальше в своем выполнении Однако эти потоки не заблокированы — они просто слишком заняты отвечая друг другу чтобы вернуться к работе Это можно сравнить с двумя людьми которые пытаются пройти мимо друг друга в коридоре: Алиса двигается влево чтобы Боб мог пройти в это же время Боб двигается вправо чтобы Алиса могла пройти Видя что они все еще блокируют друг друга Боб двигается влево а Алиса вправо но они все еще блокируют друг друга

## 23.12 Защищенные блочкировки

Наиболее часто используемый способ согласования потоков — защищенные блочкировки Such blocks начинаются с выбора условия которое должно быть true перед тем как может осуществиться блочирвка Есть несколько шагов которые нужно выполнить чтобы осуществить блочирвку правильно Предположим что loadCompleted это метод который не должен выполняться до тех пор пока ресурсы приложения не будут загружены и разделяемая между птоаками переменная resourcesLoaded не будет установлена другим птоаком В реальном приложении он мог бы например начать обработку загруженных ресурсов изменение размеров изображений для подгонки под размер монитора вычисление статического освещения и т д Такой метод теоретически должен просто выполнять цикл пока условие не выполнится но это было бы расточительно тк выполняется во время всего ожидания
Вот отформатированный текст с использованием Markdown для заголовков и улучшения читаемости:

## Использование `Object.wait()` для приостановки потока

### Простой цикл

Простой цикл, который тратит процессорное время, не является эффективным способом ожидания завершения загрузки ресурсов.

```java
public void loadCompleted() {
    // Простой цикл. Тратит процессорное время.
    // Не делайте так!
    while (!resourcesLoaded) {}
    System.out.println("Loading completed.");
}
```

### Использование `Object.wait()`

Наиболее эффективно использовать `Object.wait()`, чтобы приостановить работу текущего потока. Вызов метода `wait` не возвращает управление до тех пор, пока другой поток не обработает уведомление о том, что произошло некоторое специальное событие.

```java
public synchronized void loadCompleted() {
    // Этот цикл выполняется только один раз для каждого специального события,
    // которое может быть событием, которое мы ожидаем.
    while (!resourcesLoaded) {
        try {
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
System.out.println("Resources loaded. Processing...");
```

**Замечание**: Всегда вызывайте `wait` внутри цикла, который проверяет условие, которое ожидается. Не предполагайте, что прерывание было вызвано конкретным условием или что это условие до сих пор выполняется.

### Обработка исключений

Как и многие другие методы, которые приостанавливают выполнение, `wait` может бросить `InterruptedException`. В этом примере мы просто выводим в консоль стек-трейс ошибки.

### Синхронизация и монитор объекта

Обратите внимание на то, что мы вызываем метод `wait` внутри синхронизированного метода. Это означает, что текущий поток владеет монитором объекта (`this`). Это обязательное условие: вы должны владеть монитором объекта перед вызовом `wait`.

При вызове метода `wait`, поток освобождает блокировку и приостанавливает выполнение. Затем другой поток получает ту же самую блокировку и вызывает либо `Object.notifyAll`, либо `Object.notify`, сообщая всем ожидающим потокам о произошедшем значимом событии.

```java
public synchronized void resourcesLoaded() {
    resourcesLoaded = true;
    notifyAll();
}
```

Методы уведомления:
- **notifyAll**: пробуждает все потоки.
- **notify**: пробуждает только один случайный из них.

## Приложение загрузки и обработки ресурсов

Давайте создадим более полноценное приложение для загрузки и обработки ресурсов:

**ResourceLoadProcessExample.java**
```java
package ru.urvanov.javaindynamics2022.multithreading;

import java.util.Arrays;

public class ResourceLoadProcessExample {

    private byte[] resource;
    
    private boolean resourcesLoaded = false;  // True если ресурсы еще не загружены
    
}
```
Загрузчик будет загружать данные в массив байт (`resource`). Обработчик будет обрабатывать эти данные после их полной загрузки через общий объект между двумя потоками. Согласование действий этих двух компонентов крайне важно: обработчик должен ждать завершения загрузки данных перед их использованием; аналогично — после того как данные были получены обработчиком — они могут быть заменены новыми данными только после того как предыдущие ресурсы были полностью обработаны.

Конечно, вот отформатированный текст:

```java
// False, если ресурсы загружены и готовы к обработке
private boolean empty = true;

/**
 * Возвращает загруженный ресурс. Ждет, пока ресурс не будет доступен.
 *
 * @return Загруженный ресурс или null для завершения работы.
 */
public synchronized byte[] getLoaded() {
    // Ждем, пока нет загруженного ресурса.
    while (empty) {
        try {
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // Меняем статус
    empty = true;

    // Пробуждаем загрузчик
    notifyAll();

    return resource;
}

/**
 * Уведомляет о том, что новый ресурс был загружен.
 *
 * @param resource Загруженный ресурс или null для завершения работы.
 */
public synchronized void loaded(byte[] resource) {
    // Ждем, пока предыдущий ресурс не обработан.
    while (!empty) {
        try {
            wait();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    // Переключаем статус.
    empty = false;

    // Загруженный ресурс
    this.resource = resource;

    // Пробуждаем обработчик ресурсов.
    notifyAll();
}

public static void main(String[] args) throws InterruptedException {
    
// Создание экземпляра ResourceLoadProcessExample 
ResourceLoadProcessExample resourceLoadProcessExample = new ResourceLoadProcessExample();

// Поток для обработки данных 
Thread processor = new Thread(() -> {  
  boolean workMore = true;  

  while (workMore) {  
      byte[] resource = resourceLoadProcessExample.getLoaded();  

      if (resource == null) {  
          workMore = false;  
      } else {  
          System.out.println("Processing resource: " + Arrays.toString(resource));  

          try {  
              Thread.sleep(1000);  // Пауза на секунду между обработками 
          } catch (InterruptedException e) {  
              e.printStackTrace();  
              workMore = false;  // Завершение при прерывании 
          }   
      }
  }
});

// Поток для загрузки данных 
Thread loader = new Thread(() -> {  
    
  for (int n = 0; n < 10; n++) {  

      byte[] loadedResource = new byte[10];  

      Arrays.fill(loadedResource, (byte) n);  

      resourceLoadProcessExample.loaded(loadedResource); 

      
      try {   
          Thread.sleep(n * 1_000);   /* Задержка между каждой итерацией в зависимости от номера */   
       } catch (InterruptedException ignored){}   

   }

   /* Отправляем сигнал об окончании передачи данных */   
   resourceLoadProcessExample.loaded(null);
});

processor.start();    
loader.start();    

processor.join();     
loader.join();        
}
```

Этот код демонстрирует синхронизированную работу двух потоков: один отвечает за загрузку данных (`loader`), а другой за их обработку (`processor`). Они используют методы `getLoaded()` и `loaded()` класса `ResourceLoadProcessExample`, чтобы синхронизировать доступ к общим данным.





 
 
 








 


