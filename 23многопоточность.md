ГЛАВА 23  Многопоточность 23.1. Класс Thread Каждый поток ассоциирован с классом java.lang.Thread. Есть два основных спосо-ба использования объектов Thread в многопоточном программировании: 
Этот класс имеет один метод run(), который должен содержать код, выполняе-  ? Создание потоков и управление ими с помощью экземпляров класса Thread. 
? Абстрагирование от управления потоками и передача задач в executor. 
Есть два способа запуска кода в другом потоке с помощью Thread: 
1. Предоставить экземпляр класса, реализующего интерфейс java.lang.Runnable. 
238 Глава 23. Многопоточность мый в отдельном потоке. Экземпляр класса java.lang.Runnable передается в конструктор класса Thread: 
RunnableImpl.java package ru.urvanov.javaindynamics2022.multithreading; 
 public class RunnableImpl implements Runnable {   public void run() {  System.out.println("Текст из другого потока"); 
 }   public static void main(String args[]) {  (new Thread(new RunnableImpl())).start(); 
 }  } 2. Написать подкласс класса Thread. Класс Thread сам реализует интерфейс java.lang.Runnable, но его метод run() ничего не делает. Приложение может унаследовать класс от Thread и переопределить метод run(): 
ThreadChild.java package ru.urvanov.javaindynamics2022.multithreading; 
 public class ThreadChild extends Thread {   public void run() {  System.out.println("Текст из другого потока"); 
 }   public static void main(String args[]) {  (new ThreadChild()).start(); 
 } }  В обоих случаях мы используем метод Thread.start() для запуска нового потока. 
Именно он запускает отдельный поток. Если просто вызывать метод run(), то код будет выполняться в том же потоке, отдельный поток создаваться не будет. 
Первый способ, где предоставляется экземпляр класса, реализующего Runnable, более общий, т. к. в этом случае класс может наследоваться от отличного от Thread класса. Второй способ легче использовать в простых приложениях, но он ограничен тем, что ваш класс будет наследником Thread. 
Метод sleep класса Thread останавливает выполнение текущего потока на указан-ное время. Он используется, когда нужно освободить процессор, чтобы он занялся Глава 23. Многопоточность 239 другими потоками или процессами либо для задания интервала между какими-нибудь действиями. 
Есть два варианта метода sleep: первый принимает в качестве параметра количест-во миллисекунд, на которое нужно остановить текущий поток, второй дополни-тельно принимает второй параметр, в котором указывается количество наносекунд, на которые нужно дополнительно остановить поток: 
public static void sleep(long millis)  throws InterruptedException  public static void sleep(long millis, int nanos)  throws InterruptedException где millis — это количество миллисекунд, nanos — количество наносекунд дополнительно к millis. 
Время остановки потока неточно, оно зависит от возможностей системы. К тому же состояние ожидания для потока может быть прервано извне. 
Пример: 
SleepExample.java package ru.urvanov.javaindynamics2022.multithreading; 
 public class SleepExample {  public static void main(String args[])  throws InterruptedException {  for (int n = 0; n < 10; n++) {  // Ждем 2 секунды  Thread.sleep(2_000); 
 // Выводим значение счетчика цикла  System.out.println(n); 
 }  } }  Обратите внимание: метод main объявляет, что он throws InterruptedException. Это исключение бросается методом sleep, если поток прерывается во время ожидания внутри sleep. Так как эта программа не объявила никаких других потоков, которые могут прерывать текущий, то ей вовсе не обязательно обрабатывать это исклю- чение. 
Прерывание (interrupt) — это сигнал для потока, что он должен прекратить делать то, что он делает сейчас, и делать что-то другое. Что должен делать поток в ответ на прерывание, решает программист, но обычно поток завершается. 
240 Глава 23. Многопоточность Поток отправляет прерывание, вызывая метод public void interrupt() класса Thread. Для того чтобы механизм прерывания работал корректно, прерывае-мый поток должен поддерживать возможность прерывания своей работы. 
Как поток должен поддерживать прерывание своей работы? Это зависит от того, что он сейчас делает. Если поток часто вызывает методы, которые могут бросить InterruptedException, то он просто вызывает return при перехвате подобного ис-ключения. Пример: 
try {  Thread.sleep(1_000); 
} catch (InterruptedException e) {  // Ожидание было прервано  return; 
} Многие методы, которые бросают InterruptedException, например методы sleep, останавливают свое выполнение и возвращают управление в вызвавший их код при получении прерывания (interrupt). 
Если поток выполняется длительное время без вызова методов, которые бросают исключение InterruptedException, то он может периодически вызывать метод Thread.interrupted(), который возвращает true, если получен сигнал о прерыва-нии. Например: 
for (int i = 0; i < monsters.length; i++) {  recalculateStats(monsters[i]); 
 if (Thread.interrupted()) {  // Обработка параметров монстров была прервана. Выходим  return; 
 } } В этом примере код просто проверяет наличие сигнала о прерывании и выходит из потока, если сигнал есть. В более сложных приложениях имеет смысл бросить исключение InterruptedException: 
if (Thread.interrupted()) {  throw new InterruptedException(); 
} Это позволяет располагать код обработки прерывания потока в одной клаузе catch. 
Механизм прерывания реализован с помощью внутреннего флага, известного как статус прерывания (interrupt status). Вызов Thread.interrupt() устанавливает этот флаг. Когда поток проверяет наличие прерывания вызовов Thread.interrupted(), то флаг статуса прерывания сбрасывается. Нестатический метод isInterrupted(), который используется одним потоком для проверки статуса прерывания другого потока, не меняет флаг статуса прерывания. 
Глава 23. Многопоточность 241 По соглашению любой метод, который прерывает свое выполнение, бросая исклю-чение InterruptedException, очищает флаг статуса прерывания, когда он бросает это исключение. Однако есть вероятность, что флаг статуса прерывания будет сразу же установлен еще раз, если другой поток вызовет interrupt(). 
Метод join позволяет одному потоку ждать завершения другого потока. Если t является экземпляром класса Thread, чей поток в данный момент продолжает вы-полняться, то t.join(); 
приведет к приостановке выполнения текущего потока до тех пор, пока поток t не завершит свою работу. Метод join() имеет варианты с параметрами: 
public final void join(long millis)  throws InterruptedException  public final void join(long millis,  int nanos)  throws InterruptedException Они позволяют задать время в миллисекундах и дополнительно количество наносе-кунд, в течение которых ждать завершения выполнения потока. Однако, как и с ме-тодами sleep, методы join зависят от возможностей операционной системы, поэто-му вы не должны полагаться на то, что join будет ждать точно указанное время. 
Как и методы sleep, методы join отвечают на сигнал прерывания, останавливая процесс ожидания и бросая исключение InterruptedException. 
Пример состоит из двух потоков. Первый является главным потоком приложения, который есть в каждой программе на Java. Главный поток создает новый и ждет его завершения. Если второй поток выполняется слишком долго, то главный прерывает его. 
InterruptJoinExample.java package ru.urvanov.javaindynamics2022.multithreading; 
 public class InterruptJoinExample {   // Выводим сообщение с именем текущего потока в начале. 
 static void writeMessage(String message) {  String threadName =  Thread.currentThread().getName(); 
 System.out.format("[%s]: %s%n",  threadName,  message); 
 }   private static class Counter  implements Runnable { 242 Глава 23. Многопоточность  public void run() {  try {  for (int n = 0; n < 5; n++) {  // Ждем 2 секунды  Thread.sleep(2_000); 
 // Выводим значение счетчика цикла  writeMessage("counter " + n); 
 }  } catch (InterruptedException interruptedException) {  writeMessage("Thread interrupted"); 
 }  }  }   public static void main(String args[])  throws InterruptedException {   writeMessage("Starting Counter"); 
 long startTime = System.currentTimeMillis(); 
 Thread t = new Thread(new Counter()); 
 t.start(); 
  writeMessage("Waiting for Counter to finish"); 
 // ждем, пока MessageLoop существует  while (t.isAlive()) {  writeMessage("calling join..."); 
 // Ждем максимум 1 секунду  // завершения потока Counter  t.join(1_000); 
  // максимально 10 секунд  // Если поток не успел, то посылаем ему сигнал прерывания  if (((System.currentTimeMillis() - startTime) > 10000)  && t.isAlive()) {  writeMessage("Interrupting..."); 
 t.interrupt(); 
 // Должно быть недолго теперь. 
 // -- Ждем до конца  t.join(); 
 }  }  writeMessage("DONE"); 
 } } Глава 23. Многопоточность 243 23.2. Синхронизация Потоки общаются, в основном разделяя свои поля и поля объектов между собой. 
При этом может возникнуть два типа ошибок: вмешательство в поток (thread interference) и ошибки консистентности памяти (memory consistency errors). Для то-го чтобы предотвратить эти ошибки, нужно использовать синхронизацию потоков. 
Однако синхронизация может привести к конкуренции потоков (thread contention), которая возникает, когда два или более потока пытаются получить доступ к одному и тому же ресурсу одновременно; это приводит к тому, что среда выполнения Java выполняет один или более этих потоков медленнее или даже приостанавливает их выполнение. Голодание (starvation) и активная блокировка (livelock) — это формы конкуренции потоков. 
23.3. Вмешательство в поток (thread interference) Рассмотрим простой класс Counter: 
Counter.java package ru.urvanov.javaindynamics2022.multithreading; 
 // Пример вмешательства в поток (thread interference) class Counter {  private int value = 0; 
  public void increment() {  for (int n = 0; n < 100_000; n++) {  value++; 
 }  }   public void decrement() {  for (int n = 0; n < 100_000; n++) {  value--; 
 }  }   public static void main(String[] args) throws InterruptedException {  Counter counter = new Counter(); 
 Thread threadIncrement = new Thread(counter::increment); 
 Thread threadDecrement = new Thread(counter::decrement); 
 threadIncrement.start(); 
 threadDecrement.start(); 
 threadIncrement.join(); 
 threadDecrement.join(); 
244 Глава 23. Многопоточность  // Каждый раз будем получать разный результат,  // из-за того что потоки несинхронизированы. 
 // Это последствия thread interference. 
 System.out.println(counter.getValue()); 
 }   private int getValue() {  return value; 
 }  }  Каждый вызов метода increment добавляет 1 к c в цикле 100 000 раз, а каждый вызов decrement вычитает 1 из c в цикле 100 000 раз. Однако, если объект Counter используется несколькими потоками, вмешательство в поток может помешать это-му коду работать, как ожидалось. 
Вмешательство в поток происходит, когда два действия выполняются разными потоками, но используют одни и те же данные. Это означает, что два действия, ко-торые содержат несколько шагов, и последовательность шагов частично перекры-ваются. 
Может показаться, что операции над экземплярами Counter не могут перекрывать-ся, т. к. все операции над c являются одиночными простыми инструкциями. Однако даже простые инструкции могут транслироваться виртуальной машиной в несколь-ко шагов. Выражение c++ может быть разложено на три шага: 
1. Получить текущее значение value. 
2. Увеличить полученное значение на 1. 
3. Сохранить увеличенное значение в value. 
Предположим, что поток threadIncrement вызывает increment, и в то же самое вре-мя поток threadDecrement вызывает decrement. Начальное значение c равно 0, их пересеченные действия могут породить следующую последовательность шагов: 
1. Поток threadIncrement получает value. 
2. Поток threadDecrement получает value. 
3. Поток threadIncrement увеличивает полученное значение, в результате получает 1. 
4. Поток threadDecrement уменьшает полученное значение, в результате получает –1. 
5. Поток threadIncrement сохраняет результат 1 в value. 
6. Поток threadDecrement сохраняет результат –1 в value. 
Результат потока threadIncrement потерян, он был перезаписан потоком threadDecrement. Такое частичное перекрытие действий — это только один из вари-антов. В некоторых других ситуациях может оказаться, что результат потока threadDecrement будет потерян либо ошибок не будет совсем. Из-за этого ошибки вмешательства в поток трудно обнаруживать и исправлять. 
Глава 23. Многопоточность 245 23.4. Ошибки согласованности памяти (memory consistency errors) Ошибки согласованности памяти (memory consistency errors, ошибки консистент-ности памяти) возникают, когда разные потоки видят разные данные в своих разде-ляемых объектах и их полях. Для исключения ошибок согласованности памяти нужно понимать связи происходит-до (happens-before). Эта связь гарантирует, что данные, записанные в память одной инструкцией, видимы в другой. Рассмотрим следующий пример. Предположим, что поле типа int объявлено и инициализиро- вано: 
int value = 0; 
Поле value используется совместно двумя потоками threadA и threadB аналогично тому, как это было в примере Counter. Предположим, что поток threadA увеличива-ет value: 
value++; 
Сразу же после этого поток threadB выводит в консоль значение value: 
System.out.println(value); 
Если бы обе инструкции были выполнены одним потоком, то можно было бы смело предположить, что в консоль выведется число 1. Однако, если две инструкции выполняются разными потоками, может быть выведено 0, т. к. нет гарантии, что изменение value потоком threadA будет видимо потоком threadB, до тех пор, пока не будет обеспечена связь происходит-до (happens-before) между этими инструк-циями. 
Подробнее про happens-before читайте в разделе 23.19 "Java Memory Model". 
  23.5. Синхронизированные (synchronized) методы Язык программирования Java предоставляет два базовых способа синхронизации: 
синхронизированные методы (synchronized methods) и синхронизированные инст-рукции (synchronized statements). Есть другие, более сложные способы синхрониза-ции, они будут рассмотрены в дальнейшем. 
Чтобы сделать метод синхронизированным (synchronized), просто добавьте ключе-вое слово synchronized к его объявлению: 
SynchronizedCounter.java package ru.urvanov.javaindynamics2022.multithreading; 
 public class SynchronizedCounter {  private int value = 0; 
246 Глава 23. Многопоточность  public void increment100000() {  for (int n = 0; n < 100_000; n++) {  increment(); 
 }  }   private synchronized void increment() {  value++; 
 }   public void decrement100000() {  for (int n = 0; n < 100_000; n++) {  decrement(); 
 }  }   private synchronized void decrement() {  value--; 
 }   public static void main(String[] args) throws InterruptedException {  SynchronizedCounter counter = new SynchronizedCounter(); 
 Thread threadIncrement = new Thread(counter::increment100000); 
 Thread threadDecrement = new Thread(counter::decrement100000); 
 threadIncrement.start(); 
 threadDecrement.start(); 
 threadIncrement.join(); 
 threadDecrement.join(); 
 // Результат будет 0, т. к. методы  // increment и decrement синхронизированы. 
 System.out.println(counter.getValue()); 
 }   private int getValue() {  return value; 
 } }  Синхронизированные методы работают по следующим правилам: 
? Два вызова синхронизированных методов на одном и том же объекте не могут пересекаться. Когда один поток выполняет синхронизированный метод объекта, то другие потоки, которые вызывают синхронизированные методы того же самого объекта, блокируются (приостанавливают свое выполнение) до тех пор, пока первый поток не завершит работу с объектом. 
? Когда синхронизированный метод завершает свое выполнение, то он автомати-чески делает связь происходит-до (happens-before) со всеми последующими Глава 23. Многопоточность 247 вызовами синхронизированных методов того же самого объекта. Это гарантиру-ет, что изменения состояния объекта будут видимы для других потоков. 
Конструкторы не могут быть синхронизированными, это не имеет смысла, т. к. 
объект всегда создается в одном конкретном потоке. Использование ключевого слова synchronized для конструктора приведет к ошибке компиляции. 
ПРЕДУПРЕЖДЕНИЕ Когда создаете объект, который будет совместно использоваться разными потоками, то будьте очень осторожны, чтобы ссылка на объект не "утекла" раньше времени. 
Например, предположим, что вы хотите сделать список List, который содержит экземпляры каждого класса. Вы можете захотеть добавить следующую строку в ваш конструктор: 
engine.addGameObject(this); 
Но тогда другие потоки смогут использовать engine для получения доступа к объ-екту до того, как его создание будет завершено. 
Синхронизированные методы — простая стратегия для предотвращения вмеша-тельства в поток (thread interference) и ошибок согласованности памяти (memory consistency errors). Если объект видим более чем одному потоку, то все чтения и записи полей объекта должны происходить через синхронизированные методы. 
Использование синхронизированных методов достаточно просто, но в некоторых случаях недостаточно эффективно; в таких случаях можно использовать более эффективные способы синхронизации, которые будут описаны в последующих разделах. 
ВАЖНОЕ ИСКЛЮЧЕНИЕ Поля с модификатором final, которые не могут быть изменены после создания экземп-ляра объекта, могут безопасно читаться из несинхронизированных методов после создания конструктора. 
Синхронизированные методы построены на внутренних мониторах (блокировках). 
Когда поток вызывает синхронизированный метод, то он забирает этот монитор, а когда он выходит из синхронизированного метода, то освобождает его. 
Использовать синхронизированные методы нужно с пониманием принципов их работы. Они не имеют никакого механизма защиты от deadlock-ов, которые рас-смотрены в разделе 23.9 "Взаимная блокировка (Deadlock)". 
23.6. Внутренние мониторы и синхронизация Каждый объект в Java имеет свой внутренний монитор (блокировку). По соглаше-нию поток, которому требуется эксклюзивный и согласованный доступ к полям объекта, должен получить внутренний монитор объекта перед доступом к ним и освободить его после совершения необходимых действий с ними. Поток владеет монитором объекта между временем получения и временем освобождения блоки-ровки. 
248 Глава 23. Многопоточность Только один поток может держать монитор объекта в одно время. Но поток МОЖЕТ получить монитор, которым он уже владеет. Возможность потоков полу-чать один и тот же монитор несколько раз называется "повторная синхронизация" (reentrant synchronization). Это может быть, например, ситуация, когда синхронизи-рованный код напрямую или ненапрямую вызывает метод, который тоже содержит синхронизированный код, и оба кода используют ту же самую блокировку. Без reentrant synchronization синхронизированному коду пришлось бы использовать много предосторожностей, чтобы исключить блокировку потоком самого себя. 
Если вызывается статический синхронизированный метод, то поток получает внут-реннюю блокировку объекта Class, связанного с этим классом. Таким образом, дос-туп к статическим полям контролируется другой блокировкой, отличной от блоки-ровки любого из экземпляров класса. 
В отличие от синхронизированных методов, синхронизированные инструкции должны указать объект, который предоставляет монитор. Вот так можно переде-лать класс SynchronizedCounter на использование синхронизированных инструкций: 
public void increment100000() {  for (int n = 0; n < 100_000; n++) {  synchronized (this) {  value++; 
 }  } } Вместо this в синхронизированных инструкциях можно указывать другой объект, что позволяет брать монитор не над всем SynchronizedCounter, например, а создать какой-нибудь специальный внутренний объект для этих целей. Это позволяет брать блокировки над разными объектами внутри синхронизированных инструкций одного объекта. 
private Object lock1 = new Object(); 
public void increment100000() {  for (int n = 0; n < 100_000; n++) {  synchronized (lock1) {  value++; 
 }  } }  23.7. Атомарный доступ В программировании атомарное действие — это действие, которое происходит полностью и сразу. Атомарное действие не может остановиться посередине: оно либо завершается полностью, либо не происходит совсем. Никаких эффектов от атомарного действия не видно снаружи до тех пор, пока действие не завершится. 
Глава 23. Многопоточность 249 Даже самые простые выражения могут содержать в себе составные действия, кото-рые могут быть разложены на другие действия. Однако следующие действия ато-марны: 
? Чтение и запись атомарны для ссылочных переменных и большинства прими-тивных типов (все типы, кроме long и double) ? Чтение и запись атомарны для всех переменных, объявленных как volatile (включая long и double). 
Атомарные действия не могут пересекаться, и они могут использоваться без опасе-ний о вмешательстве в поток. Однако это не устраняет все потребности синхрони-зации атомарных действий, т. к. ошибки консистенции памяти все еще возможны. 
Использование volatile-переменных уменьшает риск ошибок консистенции памяти, потому что любая запись в volatile-переменную делает связь происходит-до (happens-before) для последующих чтений из этой переменной. Это означает, что изменения volatile-переменных всегда видны для других потоков. Это также озна-чает, что, когда поток читает volatile-переменную, он видит не только последнее изменение, но и все побочные эффекты кода, которые приводят к этому измене-нию. 
Если volatile-переменных недостаточно, но использование других методов син- хронизации слишком накладно, то можно использовать специальные классы AtomicInteger, AtomicLong и подобные. Подробнее они рассмотрены в разделе 23.8 "Атомарные переменные". 
Использование простого атомарного доступа к переменным более эффективно, чем доступ к этим переменным из синхронизированного кода, но он требует большей внимательности от программиста, чтобы исключить ошибки консистентности па-мяти. 
23.8. Атомарные переменные В этом разделе мы разберем, как работают AtomicInteger, AtomicLong и остальные подобные классы из пакета java.util.concurrent.atomic в Java. 
На самом деле, в этих классах гораздо больше методов, чем просто get, set и compareAndSet. 
Сами эти классы наследуются от java.lang.Number, а значит, они наследуют и реа-лизуют все его методы: byteValue, shortValue, intValue, longValue, floatValue, doubleValue. Однако нам интересны не они, а методы, специфичные для атомарных классов вроде AtomicInteger: 
 int addAndGet(int delta) Атомарное увеличение значения на delta. Возвращает обновленное значение. 
 boolean compareAndSet(int expect, int update) Сравнивает текущее значение с expect. Если они равны, то сохраняет update и воз-вращает true. В противном случае возвращает false. 
250 Глава 23. Многопоточность int decrementAndGet() Атомарно уменьшает хранящееся значение на единицу. Возвращает новое значе-ние. 
 int get() Возвращает текущее хранящееся значение. 
 int getAndAdd(int delta) Атомарно добавляет delta к текущему значению. Возвращает предыдущее значение. 
 int getAndDecrement() Атомарно уменьшает хранящееся значение на единицу. Возвращает предыдущее значение. 
 int getAndIncrement() Атомарно увеличивает хранящееся значение на единицу. Возвращает предыдущее значение. 
 int getAndSet(int newValue) Атомарно устанавливает новое значение и возвращает старое. 
 int incrementAndGet() Атомарно увеличивает хранящееся значение на единицу и возвращает новое значе-ние. 
 void lazySet(int newValue) Устанавливает новое значение спустя какое-то время. Это новое значение может быть невидимо для других потоков какое-то время, они будут считывать старое значение. Метод может быть полезен для оптимизации производительности, т. к. 
последующие обращения к значению вполне могут получить старое значение из кеша процессора без обращения к реальному значению в памяти. 
 void set(int newValue) Устанавливает новое значение. 
 boolean weakCompareAndSet(int expect, int update) Аналогично compareAndSet, но может вернуть false и не обновить значение, даже если хранящееся значение равно expected. 
 Для AtomicLong методы аналогичны, но принимают и возвращают long вместо int. 
 Работа методов классов AtomicInteger и AtomicLong основана на специальной команде процессора CAS (compare-and-set), которая сначала сравнивает значение с ожидаемым и лишь потом заменяет его на новое. 
Глава 23. Многопоточность 251 ПРИМЕЧАНИЕ Имейте в виду, что у нас нет специальных атомарных классов для byte, short, float и double! 
23.9. Взаимная блокировка (Deadlock) Взаимная блокировка (deadlock) описывает ситуацию, когда два или более потока блокируются навсегда, ожидая один другого. Ниже описан пример. 
Предположим, что у нас есть система, работающая со счетами пользователей. Сче-та пользователей представлены классом AccountWithDeadlock: 
AccountWithDeadlock.java public class AccountWithDeadlock {  private final int id; 
 private int amount; 
  public AccountWithDeadlock(int id) {  this.id = id; 
 }   public int getId() {  return this.id; 
 }   public int getAmount() {  return this.amount; 
 }   public synchronized void transfer(  AccountWithDeadlock fromAccount, int transferSum) {  synchronized (fromAccount) {  fromAccount.amount -= transferSum; 
 this.amount += transferSum; 
 }  } }  На первый взгляд может показаться, что все в порядке. Но на самом деле в этом коде спрятана взаимная блокировка. Если вызвать transfer на первом счете, а затем на втором практически одновременно, то может произойти так, что: 
1. Берется блокировка this на методе synchronized у счета 1. 
2. Происходит переключение потоков. 
3. Берется блокировка this на методе synchronized у счета 2. 
4. Происходит переключение потоков. 
252 Глава 23. Многопоточность 5. Поток, уже имеющий блокировку на счете 1, пытается взять блокировку на сче-те 2 в синхронизированном блоке, но блокировка this у счета 2 уже занята, поэтому поток останавливается до тех пор, пока блокировка счета 2 не освобо-дится. 
6. Поток, уже имеющий блокировку на счете 2, пытается взять блокировку на сче-те 1 в синхронизированном блоке, но блокировка this у счета 1 уже занята, поэтому поток останавливается до тех пор, пока блокировка счета 1 не освобо-дится. 
7. Оба потока ждут освобождения блокировок друг друга, чего никогда не про-изойдет. 
Как избавиться от подобного? В данном случае можно обратить внимание на иден-тификатор счета id. Понятное дело, что каждый счет имеет уникальный идентифи-катор. Чтобы избежать взаимных блокировок (deadlock), мы можем всегда брать блокировки строго в порядке сортировки их идентификаторов, т. е. сначала меньший, а затем больший, чем решим проблему взаимных блокировок для этого случая: 
AccountFixed.java public class AccountFixed {  private final int id; 
 private int amount; 
  public AccountFixed(int id) {  this.id = id; 
 }   public int getId() {  return this.id; 
 }   public int getAmount() {  return this.amount; 
 }   public void transfer(AccountFixed fromAccount, int transferSum) {  AccountFixed firstBlock; 
 AccountFixed secondBlock; 
 if (this.id < fromAccount.id) {  firstBlock = this; 
 secondBlock = fromAccount; 
 } else {  firstBlock = fromAccount; 
 secondBlock = this; 
 } Глава 23. Многопоточность 253  synchronized (firstBlock) {  synchronized (secondBlock) {  fromAccount.amount -= transferSum; 
 this.amount += transferSum; 
 }  }   } }  Если же окажется так, что объекты, на которых нужно взять блокировку, не имеют уникальных полей, по которым можно определять меньший и больший объект, то можно ввести подобные поля синтетически. 
23.10. Голодание (starvation) Голодание (starvation) описывает ситуацию, когда поток не может получить доступ к совместно используемым ресурсам и не может продвинуться в своем выполнении дальше. Это возникает, когда совместно используемый ресурс делается недоступ-ным на долгое время "жадными" потоками. Например, предположим, что объект предоставляет синхронизированный метод, который обычно выполняется доста-точно долго. Если один поток вызывает этот метод часто, то другие потоки, кото-рым тоже нужен частый синхронизированный доступ к тому же самому объекту, будут часто блокироваться. 
23.11. Активная блокировка (livelock) Поток часто реагирует на события из другого потока. Если действие другого потока тоже является ответом на событие из еще одного потока, то может произойти ак-тивная блокировка (livelock). Как и взаимная блокировка (deadlock), активно забло-кированные потоки не могут продвинуться дальше в своем выполнении. Однако эти потоки не заблокированы — они просто слишком заняты, отвечая друг другу, чтобы вернуться к работе. Это можно сравнить с двумя людьми, которые пытаются пройти мимо друг друга в коридоре: Алиса двигается влево, чтобы Боб мог пройти, в это же время Боб двигается вправо, чтобы Алиса могла пройти. Видя, что они все еще блокируют друг друга, Боб двигается влево, а Алиса вправо, но они все еще блокируют друг друга. 
23.12. Защищенные блокировки (guarded blocks) Наиболее часто используемый способ согласования потоков — защищенные бло-кировки (guarded blocks). Такой блок начинается с выбора условия, которое должно быть true, перед тем, как может осуществиться блокировка. Есть несколько шагов, которые нужно выполнить, чтобы осуществить блокировку правильно. 
Предположим, что loadCompleted — это метод, который не должен выполняться до тех пор, пока ресурсы приложения не будут загружены и разделяемая между пото-254 Глава 23. Многопоточность ками переменная resourcesLoaded не будет установлена другим потоком. В реаль-ном приложении он мог бы, например, начать обработку загруженных ресурсов, изменение размеров изображений для подгонки под размер монитора, вычисление статического освещения и т. д. Такой метод теоретически должен просто выпол-нять цикл, пока условие не выполнится, но это было бы расточительно, т. к. выпол-няется в течение всего времени ожидания. 
public void loadCompleted() {  // Простой цикл. Тратит процессорное время  // не делайте так! 
 while(!resourcesLoaded) {}  System.out.println("Loading completed."); 
} Наиболее эффективно использовать Object.wait(), чтобы приостановить работу текущего потока. Вызов метода wait не возвращает управление до тех пор, пока другой поток не обработает уведомление о том, что произошло некоторое специ-альное событие, однако не имеет значения, какое событие ожидает поток: 
public synchronized void loadCompleted() {  // Этот цикл выполняется только один раз для каждого специального события,  // которое может быть событием, которое мы ожидаем. 
 while(!resourcesLoaded) try {  wait(); 
 } catch (InterruptedException e) {  e.printStackTrace(); 
 }  }  System.out.println("Resources loaded. Processing..."); 
} ЗАМЕЧАНИЕ Всегда вызывайте wait внутри цикла, который проверяет условие, которое ожидается. 
Не предполагайте, что прерывание было вызвано конкретным условием, которое нам нужно, или что это условие до сих пор выполняется. Вполне может оказаться, что прерывание было вызвано совсем другим событием, а не тем, которое мы ожидали. 
Как и многие другие методы, которые приостанавливают выполнение, wait может бросить InterruptedException. В этом примере мы просто выводим в консоль стек-трейс ошибки. 
ЗАМЕЧАНИЕ Обратите внимание, что мы вызываем метод wait внутри синхронизированного мето-да, а значит, текущий поток владеет монитором объекта this. Это обязательное условие. Вызывайте wait только тогда, когда уже владеете монитором объекта. 
При вызове метода wait поток освобождает блокировку и приостанавливает выпол-нение. Затем спустя время другой поток получает ту же самую блокировку и вызы-вает Object.notifyAll или Object.notify, сообщая всем ожидающим потокам, что произошло что-то существенное. Метод notifyAll() пробуждает все потоки, кото-Глава 23. Многопоточность 255 рые вызывали wait для объекта, а метод notify() пробуждает только один случай-ный поток из них. Мы используем notifyAll(): 
public synchronized resourcesLoaded() {  resouresLoaded = true; 
 notifyAll(); 
} Спустя какое-то время второй поток освобождает блокировку, первый поток снова получает блокировку и возвращается из вызова wait. 
Давайте сделаем приложение загрузки и обработки ресурсов более полноценным. 
Загрузчик будет загружать данные, а обработчик будет что-либо делать с ними. Два потока общаются с помощью общего объекта. Согласование их действий очень важно: поток обработчика не должен пытаться получать данные до того, как за-грузчик загрузит их, и поток загрузчика не должен пытаться доставить новые дан-ные до того, пока обработчик не получил предыдущие ресурсы. 
ResourceLoadProcessExample.java package ru.urvanov.javaindynamics2022.multithreading; 
 import java.util.Arrays; 
 public class ResourceLoadProcessExample {  // Ресурсы. В нашем случае просто массив байт  private byte[] resource; 
 // True, если ресурсы еще не загружены. 
 // False, если ресурсы загружены и готовы к обработке  private boolean empty = true; 
  public synchronized byte[] getLoaded() {  // Ждем, пока нет загруженного ресурса. 
 while (empty) {  try {  wait(); 
 } catch (InterruptedException e) {  e.printStackTrace(); 
 }  }  // Меняем статус  empty = true; 
 // Пробуждаем загрузчик  notifyAll(); 
 return resource; 
 }   public synchronized void loaded(byte[] resource) {  // Ждем, пока предыдущий ресурс не обработан. 
 while (!empty) { 256 Глава 23. Многопоточность  try {  wait(); 
 } catch (InterruptedException e) {  e.printStackTrace(); 
 }  }  // Переключаем статус. 
 empty = false; 
 // Загруженный ресурс  this.resource = resource; 
 // Пробуждаем обработчик ресурсов. 
 notifyAll(); 
 }   public static void main(String[] args) throws InterruptedException {  ResourceLoadProcessExample resourceLoadProcessExample  = new ResourceLoadProcessExample(); 
  Thread processor = new Thread(() -> {  boolean workMore = true; 
 while (workMore) {  byte[] resource = resourceLoadProcessExample.getLoaded(); 
  if (resource == null) {  workMore = false; 
 } else {  System.out.println("Processing resource: "  + Arrays.toString(resource)); 
 try {  Thread.sleep(1000); 
 } catch (InterruptedException e) {  e.printStackTrace(); 
 workMore = false; 
 }  }  }  }); 
  Thread loader = new Thread(() -> {  for (int n = 0; n < 10; n++) {  byte[] loadedResource = new byte[10]; 
 Arrays.fill(loadedResource, (byte) n); 
 resourceLoadProcessExample.loaded(loadedResource); 
 try {  Thread.sleep(n * 1_000); 
 } catch (InterruptedException e) {}  }  resourceLoadProcessExample.loaded(null); 
  }); 
Глава 23. Многопоточность 257  loader.start(); 
 processor.start(); 
 loader.join(); 
 processor.join(); 
  } }
  
23.13. Неизменяемые объекты (immutable objects) Объект считается неизменяемым, если его внутреннее состояние не может быть изменено после создания. Использование неизменяемых объектов — широко рас-пространенная стратегия для создания простого и надежного кода. 
Неизменяемые объекты особенно полезны в многопоточных приложениях. Так как они не могут менять своего внутреннего состояния, то они не могут быть испор- чены вмешательством в поток (thread interference) или прочитаны в некорректном состоянии. 
Ниже перечислены правила определения неизменяемых объектов. Не все классы, документированные как "неизменяемые", следуют этим правилам. Это необяза-тельно значит, что создатели этих классов были некомпетентны — они могли иметь веские причины считать, что экземпляры их объектов никогда не будут меняться после создания. Однако такие стратегии требуют сложного анализа и не подходят для начинающих. 
? Все поля должны быть final и private. 
? Не должно быть методов установки и изменения значений. 
? Не позволяйте расширять класс, объявляя дочерние классы. Самый простой спо-соб добиться этого — объявить класс как final. Более сложный способ — это сделать конструктор приватным и создавать экземпляры класса с помощью методов фабрик. 
? Если поля экземпляров ссылаются на изменяемые объекты, то не позволяйте менять состояние этих объектов: не предоставляйте методов, которые меняют внутреннее состояние изменяемых объектов, не позволяйте стороннему коду получить ссылки на изменяемые объекты (возвращайте копии этих объектов), не используйте те объекты, которые были переданы в конструктор (создавайте их копии, если нужно). 
Пример неизменяемого класса: 
ImmutablePoint.java package ru.urvanov.javaindynamics2022.multithreading; 
 /**  * Пример неизменяемого класса. 
 */ 258 Глава 23. Многопоточность public final class ImmutablePoint {  private final double x; 
 private final double y; 
  public ImmutablePoint(double x, double y) {  this.x = x; 
 this.y = y; 
 }   public double getX() {  return x; 
 }   public double getY() {  return y; 
 } } 23.14. Объекты Lock Синхронизированный код полагается на простой тип reentrant lock (блокировка, которую можно брать несколько раз). Этот тип легко использовать, но он имеет определенные ограничения. Более сложные способы блокировки поддерживаются пакетом java.util.concurrent.locks. 
Объекты, реализующие интерфейс Lock, работают очень похоже на внутренние блокировки, используемые синхронизированным кодом. Так же как и для внутрен-них блокировок, только один поток может держать блокировку объекта Lock в одно время. Объекты Lock также поддерживают механизм wait / notify через ассоции-рованные с ними объекты Condition. 
Преимущество объектов Lock над внутренними блокировками в том, что они могут отказаться от участия в попытке приобрести блокировку благодаря методам tryLock: 
boolean tryLock()  boolean tryLock(long time,  TimeUnit unit)  throws InterruptedException Метод tryLock сразу же завершается, если блокировка недоступна при вызове, либо после истечения указанного времени (если время указано). 
 void lockInterruptibly()  throws InterruptedException Метод lockInterruptibly отказывается от попытки получить блокировку, если дру-гой поток отправляет interrupt до получения блокировки. 
Глава 23. Многопоточность 259 void lock() Метод lock приостанавливает поток до тех пор, пока блокировка будет недоступна. 
Затем захватывает блокировку и возобновляет поток либо сразу забирает блоки-ровку, если она свободна. 
 void unlock() Освобождает блокировку. 
 Основные реализации интерфейса Lock: 
1. ReentrantLock. Работает аналогично внутренней блокировке и синхронизирован-ным методам / синхронизированным блокам инструкций, но с расширенными возможностями. 
2. ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock. Класс ReentrantReadWriteLock имеет два внутренних монитора. Один для чтения, а вто-рой для записи. Блокировка на чтение может держаться несколькими потоками одновременно, но блокировка на запись только одним (много читателей, один писатель). 
Пример использования ReentrantLock: 
import java.util.concurrent.locks.*; 
... 
Lock myLock = new ReentrantLock(); 
try {  boolean myLockSuccess = myLock.tryLock(); 
 if (myLockSuccess) {  // Выполняем действия над объектом,  // который разделяем с другими потоками. 
 } else {  // Кто-то другой уже работает с объектом. 
 } } finally {  myLock.unlock(); 
} 23.15. Executors Интерфейс java.util.concurrent.Executor предоставляет один метод execute, кото-рый является заменой обычного создания потока. Если r реализует интерфейс Runnable, а e реализует интерфейс Executor, то вы можете заменить (new Thread(r)).start(); 
следующим кодом: 
e.execute(r); 
260 Глава 23. Многопоточность Однако определение метода execute несколько отличается. В зависимости от реа-лизации Executor-а метод execute может делать то же самое, но обычно он исполь-зует уже существующий рабочий поток для запуска r, либо r помещается в оче-редь, где дожидается освобождения рабочего потока. 
Реализации executor-ов в java.util.concurrent созданы для использования с более продвинутыми интерфейсами ExecutorService и ScheduledExecutorService, но они также работают и с интерфейсом Executor. 
Интерфейс java.util.concurrent.ExecutorService расширяет интерфейс Executor, добавляя множество новых методов. Основной метод — submit, который принима-ет как Runnable, так и интерфейс java.util.concurrent.Callable<V> с единственным методом V call(), который позволяет заданиям возвращать значение. Метод submit возвращает интерфейс java.util.concurrent.Future, который используется для по-лучения результата и контролирования состояния потока. 
Интерфейс Future позволяет проверять, не закончилось ли выполнение фоновой задачи с помощью метода: 
boolean isDone(); 
Метод isDone возвращает true, если поток завершил свои вычисления либо был от-менен с помощью метода cancel интерфейса Future: 
boolean cancel(boolean mayInterruptIfRunning); 
Если задача была отменена, то метод isCancelled будет возвращать true: 
boolean isCancelled(); 
Получить значение из завершенной задачи можно с помощью метода get: 
V get() throws InterruptedException, ExecutionException; 
Метод get ожидает завершения выполнения и возвращает результат, который вер-нул метод call интерфейса Callable. Существует также вариант метода get с лими-том времени ожидания: 
V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; 
Интерфейс java.util.concurrent.ScheduledExecutorService расширяет интерфейс java.util.concurrent.ExecutorService и добавляет методы schedule*, которые по-зволяют запланировать выполнение задания. 
23.16. CompletableFuture Класс CompletableFuture появился в Java 8. Он реализует интерфейс Future и позво-ляет комбинировать задачи друг с другом. CompletableFuture содержит специаль-ные статические методы для запуска своих экземпляров. Некоторые из них позво-ляют передавать Executor, но некоторые не имеют такого параметра, и тогда ис-пользуется ForkJoinPool.commonPool(). 
Глава 23. Многопоточность 261 Пример простого использования: 
SimpleCompletableFuture.java package ru.urvanov.javaindynamics2022.multithreading; 
 import java.util.concurrent.CompletableFuture; 
import java.util.concurrent.ExecutionException; 
import java.util.concurrent.Executors; 
 public class SimpleCompletableFuture {  public static void main(String[] args) throws ExecutionException,  InterruptedException {  CompletableFuture<String> future1  = CompletableFuture.supplyAsync(() -> "Test1"); 
 CompletableFuture<String> future2  = CompletableFuture.supplyAsync(  () -> "Test2", Executors.newCachedThreadPool()); 
 System.out.println(future1.get()); 
 System.out.println(future2.get()); 
  CompletableFuture<Void> future3 = CompletableFuture.runAsync(  () -> System.out.println("Test3")); 
 CompletableFuture<Void> future4 = CompletableFuture.runAsync(  () -> System.out.println("Test4"),  Executors.newCachedThreadPool()); 
 future3.join(); 
 future4.join(); 
 } }  Метод get блокирует текущий поток. CompletableFuture чаще всего используется с методами, позволяющими задать callback-методы, которые будут что-то делать с вычисленным значением также в параллельном потоке. Для этого используются методы thenApply, thenRun и аналогичные: 
SimpleCompletableFuture.java // thenAccept CompletableFuture<String> completableFutureThenAccept  = CompletableFuture.supplyAsync(() -> "Hello"); 
 CompletableFuture<Void> futureThenAccept  = completableFutureThenAccept.thenAccept(  s -> System.out.println("Computation returned: " + s)); 
 futureThenAccept.get(); 
262 Глава 23. Многопоточность // thenRun CompletableFuture<String> completableFutureThenRun  = CompletableFuture.supplyAsync(() -> "Hello"); 
 CompletableFuture<Void> futureThenRun = completableFutureThenRun  .thenRun(() -> System.out.println("Computation finished.")); 
 futureThenRun.get(); 
 Можно выстраивать последовательные цепочки обработки, но использовать при-дется не thenRun и thenAccept, а thenApply, который принимает Function в качестве параметра: 
// thenApply CompletableFuture<Integer> futureThenApply  = CompletableFuture.supplyAsync(() -> 2); 
 futureThenApply.thenApply(result -> result + 3); 
 futureThenApply.thenApply(result -> result -1); 
 Integer futureThenApplyResult = futureThenApply.get(); 
System.out.println(futureThenApplyResult); 
Основная мощь CompletableFuture заключается в комбинировании задач с по- мощью allOf и anyOf: 
SimpleCompletableFuture.java // allOf List<CompletableFuture<Void>> allOf = new ArrayList<>(); 
allOf.add(CompletableFuture.runAsync(() -> {  try {  Thread.sleep(100); 
 } catch (InterruptedException e) {  e.printStackTrace(); 
 }  System.out.println("allOfTaskOne"); 
})); 
allOf.add(CompletableFuture.runAsync(() -> {  try {  Thread.sleep(200); 
 } catch (InterruptedException e) {  e.printStackTrace(); 
 }  System.out.println("allOfTaskTwo"); 
})); 
Глава 23. Многопоточность 263 CompletableFuture.allOf(  allOf.toArray(new CompletableFuture[allOf.size()])).join(); 
 // anyOf List<CompletableFuture<Void>> anyOf = new ArrayList<>(); 
anyOf.add(CompletableFuture.runAsync(() -> {  try {  Thread.sleep(120); 
 } catch (InterruptedException e) {  e.printStackTrace(); 
 }  System.out.println("anyOfTaskOne"); 
})); 
anyOf.add(CompletableFuture.runAsync(() -> {  try {  Thread.sleep(200); 
 } catch (InterruptedException e) {  e.printStackTrace(); 
 }  System.out.println("anyOfTaskTwo"); 
})); 
CompletableFuture.allOf(  anyOf.toArray(new CompletableFuture[anyOf.size()])).join(); 
 Обратите внимание, что в этом примере мы использовали join вместо get для ожидания завершения задач. Метод join делает то же самое, что и метод get, но не требует обработки проверяемых исключений. 
23.17. Пулы потоков Многие реализации executor-ов из пакета java.util.concurrent используют пул пото-ков. Пул потоков — это некий контейнер, содержащий в себе определенное число потоков и использующий их для выполнения заданий. Этот подход минимизирует издержки создания потоков. Они используют много памяти, и в больших приложе-ниях создание и уничтожение большого количества потоков значительно увеличи-вает потребление памяти. 
Пулы потоков бывают с фиксированным количеством потоков, с одним потоком, с кешем потоков и т. д. Наиболее часто использующийся тип пула потоков — это фиксированный пул потоков. Этот тип всегда держит работающими указанное количество потоков, даже если задач больше или меньше их числа. Задачи отправ-ляются в пул через внутреннюю очередь, которая хранит дополнительные задачи, если их больше, чем потоков. 
Важное преимущество фиксированного пула потоков в том, что приложения, кото-рые их используют, не подвисают из-за того, что они создали слишком большое количество потоков, превышающее возможности системы. 
264 Глава 23. Многопоточность Для создания пула с фиксированным числом потоков используется метод newFixedThreadPool класса java.util.concurrent.Executors, для остальных типов используются соответствующие другие методы. 
public static ExecutorService newFixedThreadPool(int nThreads) Класс Executors также имеет следующие фабричные методы: 
 public static ExecutorService newCachedThreadPool() Создает новые потоки по мере надобности. Повторно использует предыдущие по-токи, если они свободны. 
 public static ExecutorService newSingleThreadExecutor() Пул потоков, состоящий из одного потока. 
 Если ни один из стандартных executor-ов не удовлетворяет вашим потребностям, то вы можете создать экземпляры java.util.concurrent.ThreadPoolExecutor или java.util.concurrent.ScheduleThreadPoolExecutor. 
23.18. Fork/Join Framework Fork/Join Framework является реализацией интерфейса ExecutorService, который помогает вам получить преимущество при использовании мультипроцессорной системы. Он спроектирован для такой работы, которая может быть разбита рекур-сивно на множество маленьких частей. Цель фреймворка — использовать всю дос-тупную мощь, чтобы увеличить производительность вашего приложения. 
Как и с любой реализацией ExecutorService, fork/join framework распределяет зада-чи между рабочими потоками в пуле потоков. Fork/join фрейморк отличается тем, что он использует алгоритм воровства работы. Рабочие потоки, для которых кон-чилась работа, могут воровать задачи других потоков, которые все еще заняты. 
Основным классом fork/join фреймворка является java.util.concurrent.ForkJoinPool. 
Fork/join framework работает в тех случаях, когда работу можно разбить на не-большие части, которые можно выполнить отдельно. 
Пример: 
ForkAbs.java package ru.urvanov.javaindynamics2022.multithreading; 
 import java.util.Random; 
import java.util.concurrent.ForkJoinPool; 
import java.util.concurrent.RecursiveAction; 
 public class ForkAbs extends RecursiveAction {  private int[] source; 
Глава 23. Многопоточность 265  private int[] destination; 
 private int start; 
 private int length; 
  public ForkAbs(  int[] source,  int start,  int length,  int[] destination) {  this.source = source; 
 this.start = start; 
 this.length = length; 
 this.destination = destination; 
 }   private void computeDirectly() {  // Это только пример. В реальности здесь  // могут быть довольно сложные вычисления. 
 for (int n = start; n < start + length; n++) {  destination[n] = Math.abs(source[n]); 
 }  }  ... 
 Теперь мы реализуем абстрактный метод compute(), который либо реализует вы-числение абсолютного значения напрямую, либо делит его на мелкие задачи. 
ForkAbs.java private static int threshold = 10; 
 @Override protected void compute() {  if (length < threshold) {  computeDirectly(); 
 return; 
 }   int split = length / 2; 
 invokeAll(new ForkAbs(source, start, split, destination),  new ForkAbs(  source,  start + split,  length - split,  destination)); 
} 266 Глава 23. Многопоточность Пример запуска: 
ForkAbs.java int[] source = new int[100]; 
int[] destination = new int[source.length]; 
Random random = new Random(); 
System.out.println("source = "); 
for (int n = 0; n < source.length; n ++) {  source[n] = random.nextInt(); 
 System.out.print(source[n]); 
 System.out.print(" "); 
} System.out.println(); 
 ForkAbs forkAbs = new ForkAbs(source, 0, source.length, destination); 
 ForkJoinPool pool = new ForkJoinPool(); 
pool.invoke(forkAbs); 
 System.out.println("destination = "); 
for (int n = 0; n < destination.length; n ++) {  System.out.print(destination[n]); 
 System.out.print(" "); 
} System.out.println();

23.19. Java Memory Model Модель памяти Java или Java Memory Model (JMM) описывает поведение програм-мы в многопоточной среде. Она объясняет возможное поведение потоков и то, на что должен опираться программист, разрабатывающий приложение. 
В этом разделе приведено достаточно большое количество терминов. Думаю, что большая часть из них пригодится вам только на собеседованиях, но представлять общую картину того, что такое Java Memory Model, все-таки полезно. 
Java может работать на разных процессорах и разных операционных системах, что приводит к затруднению синхронизации между потоками. Многие современные процессоры имеют несколько ядер, могут выполнять команды не в той последова-тельности, в которой они записаны, а компиляторы могут менять последователь-ность команд для оптимизации. 
Неправильно синхронизированные программы могут приводить к неожиданным результатам. 
Например, программа использует локальные переменные r1 и r2 и общие перемен-ные A и B. Первоначально A == B == 0 (табл. 23.1). 
Глава 23. Многопоточность 267 Таблица 23.1. Соответствие локальных и общих переменных Thread 1 Thread 2 1: r2 = A; 3: r1 = B; 
2: B = 1; 4: A = 2; 
 Может показаться, что результат r2 == 2 и r1 == 1 невозможен, т. к. первой должна быть либо инструкция 1, либо инструкция 3. Если инструкция 1 будет первой, то она не сможет увидеть число 2, записанное в инструкции 4. Если инструкция 3 будет первой, то она не сможет увидеть результат инструкции 2. 
Если какое-то выполнение программы привело бы к такому поведению, то мы бы знали, что инструкция 4 была до инструкции 1, которая была до инструкции 2, которая была до инструкции 3, которая была до инструкции 4, что совершенно аб-сурдно. 
Однако современным компиляторам разрешено переставлять местами инструкции в обоих потоках в тех случаях, когда это не затрагивает исполнение этого потока, не учитывая другие потоки. Если инструкция 1 и инструкция 2 поменяются места-ми, то мы с легкостью сможем получить результат r2 == 2 и r1 == 1 (табл. 23.2). 
Таблица 23.2. Перемена инструкций Thread 1 Thread 2 B = 1; r1 = B; 
r2 = A; A = 2; 
 Для некоторых программистов подобное поведение может оказаться ошибочным, но здесь нужно сделать замечание, что этот код неверно синхронизирован. 
? у нас есть запись из одного потока; 
? мы читаем ту же переменную из другого потока; 
? чтение и запись не синхронизированы, что не гарантирует правильный порядок. 
Ситуация, описанная в примере выше, называется data race. 
Ошибка проектирования, когда data race приводит к ошибкам в программе, называ-ется race condition. 
Переставлять команды может Just-In-Time компилятор или процессор. Более того, каждое ядро процессора может иметь свой кеш. А значит, у каждого процессора может быть свое значение одной и той же переменной, что может привести к ана-логичным результатам. 
Модель памяти описывает, какие значения могут быть считаны в каждый момент программы. Поведение потока в изоляции должно быть таким, каким оно описано в самом потоке, но значения, считываемые из переменных, определяются моделью 268 Глава 23. Многопоточность памяти. Когда мы ссылаемся на это, то мы говорим, что программа подчиняется intra-thread semantic, т. е. семантике однопоточного приложения. 
Память, которая может быть совместно использована разными потоками, называет-ся "куча" (shared memory или heap memory). 
Все переменные экземпляров, статические поля, массивы элементов хранятся в ку-че. Дальше в этой главе они будут называться просто переменными. 
Локальные переменные, параметры конструкторов и методов, а также параметры блока catch никогда не разделяются между потоками. 
Два доступа к одной переменной называются конфликтующими, если хотя бы один из них меняет значение переменной (другой может как менять, так и считывать текущее значение). 
Inter-thread action (наиболее корректный, на мой взгляд, перевод — "межпоточное действие") — это действие внутри одного потока, которое может повлиять на дру-гой поток или быть замечено им. Существует несколько типов межпоточных дей-ствий: 
? Чтение (нормальное, не volatile). Чтение переменной. 
? Запись (нормальная, не volatile). Запись переменной. 
? volatile read. Чтение volatile-переменной. 
? volatile write. Запись volatile-переменной. 
? Lock. Взятие блокировки монитора. 
? Unlock. Освобождение блокировки монитора. 
? Синтетические действия — первое и последнее действия в потоке. 
? Действия по запуску нового потока или обнаружению остановки потока. 
? Внешние действия. Это действия, которые могут быть обнаружены снаружи вы-полняющегося потока, например взаимодействия с внешним окружением. 
? Thread divergence actions. Действия потока, находящегося в бесконечном цикле без синхронизаций, работы с памятью или внешних действий. 
Program order (лучше не переводить, чтобы не возникло путаницы) — общий поря-док потока, выполняющего действия, который отражает порядок, в котором долж-ны быть выполнены все действия с соответствии с семантикой intra-thread semantic потока. 
Действия называются sequentially consistent (тоже лучше не переводить), если все действия выполняются в общем порядке, который соответствует program order, а также каждое чтение переменной видит последнее значение, записанное туда до этого в соответствии с порядком выполнения. 
Если в программе нет состояния гонки, то все запуски программы будут sequentially consistent. 
Synchronization order (порядок синхронизации, но лучше не переводить) — общий порядок всех действий по синхронизации в выполнении программы. 
Глава 23. Многопоточность 269 Действия по синхронизации вводят связь synchronized-with (синхронизировано с): 
? Действие освобождения блокировки монитора синхронизируется с (synchro-nizes-with) всеми последующими действиями по взятию блокировки этого мони-тора. 
? Присвоение значения volatile переменной синхронизируется с (synchronizes-with) всеми последующими чтениями этой переменной любым потоком. 
? Действие запуска потока синхронизируется с (synchronizes-with) первым дейст-вием внутри запущенного потока. 
? Присвоение значения по умолчанию (0, false, null) каждой переменной синхро-низируется с (synchronizes-with) первым действием каждого потока. 
? Последнее действие в потоке синхронизируется с (synchronizes-with) любым действием других потоков, которые проверяют, что первый поток завершился. 
? Если поток 1 прерывает поток 2, то прерывание выполнения потока 2 синхрони-зируется с (synchronizes-with) любой точкой, где другой поток (и прерывающий тоже) проверяет, что поток 2 был прерван (InterruptedException, Thread. 
interrupted, Thread.isInterrupted). 
Happens-before ("выполняется прежде" или "произошло-до") — отношение порядка между атомарными командами. Оно означает, что вторая команда будет видеть из-менения первой и что первая команда выполнилась перед второй. Happens-before возникает: 
? Освобождение монитора happens-before любого последующего взятия блокиров-ки этого монитора. 
? Присвоение значение volatile полю happens-before любого последующего чтения значения этого поля. 
? Запуск потока happens-before любых действий в запущенном потоке. 
? Все действия внутри потока happens-before любого успешного завершения join() над этим потоком. 
? Инициализация по умолчанию для любого объекта happens-before любых других действий программы. 
Все поля final должны быть инициализированы либо конструкциями инициализа-ции, либо внутри конструктора. Не стоит внутри конструкторов обращаться к дру-гим потокам. Поток увидит ссылку на объект только после полной инициализации, т. е. по окончании работы конструктора. Так как final полям присваивается значе-ние только один раз, то просто не обращайтесь к другим потокам внутри конструк-торов и блоков инициализации, и проблем возникнуть не должно. 
Однако final поля могут быть изменены через Java Reflection API, чем пользуются, например, десериализаторы. Просто не отдавайте ссылку на объект другим потокам и не читайте значение final поля до его обновления, и все будет нормально. 
Некоторые процессоры не позволяют записывать один байт в ОЗУ, что приводит к проблеме, называемой word tearing. Представьте, что у нас есть массив байт. 
270 Глава 24. Настройки и окружение Один поток записывает первый байт, а второй поток пытается записать значение в рядом стоящий байт. Но если процессор не может записать один байт, а только целое машинное слово, то запись рядом стоящего байта может быть проблематич-ной. Если просто считать машинное слово, обновить один байт и записать обратно, то мы помешаем другому потоку. 
В JVM нет проблемы word tearing. Два потока, пишущие рядом стоящие байты, не должны мешать друг другу.