отформатируй текст: 26.11. Интерфейс SortedSet Интерфейс java.util.SortedSet — это java.util.Set, который поддерживает свои элементы в отсортированном по возрастанию виде согласно естественному порядку или согласно Comparator-у, который был передан в конструктор. В дополнение Глава 26. Коллекции 293 к обычным операциям java.util.Set-а, интерфейс java.util.SortedSet добавляет три вида операций: 
? Работа с частью Set-а с помощью методов subset(E fromElement, E toElement), headSet(E toElement), tailSet(E fromElement), которые возвращают представле-ние, позволяющее работать с частью исходного Set. 
? Получение первого и последнего элементов в множестве с помощью методов first() и last(). 
? Доступ к Comparator-у, который используется для сортировки множества с по-мощью метода comparator(). 
По соглашению все реализации интерфейса java.util.Collection общего назначе-ния имеют стандартный конструктор, который принимает Collection в качестве параметра. Реализации SortedSet не являются исключением. В TreeSet этот конст-руктор создает экземпляр, который сортирует эти элементы в соответствии с их естественным порядком. Однако было бы гораздо лучше динамически проверять, была ли коллекция экземпляром SortedSet, и сортировать TreeSet в соответствии с тем же Comparator-ом или естественным порядком. Специально для этого есть конструктор, который принимает SortedSet и возвращает новый экземпляр TreeSet, который содержит те же самые элементы, отсортированные в соответствии с тем же самым критерием. Заметьте, что порядок определяется на этапе компиляции, а не на этапе выполнения, т. к. используется перегрузка конструкторов. 
Реализации SortedSet также по соглашению имеют конструктор, который принима-ет java.util.Comparator и возвращает пустое множество, которое сортируется в со-ответствии с указанным Comparator-ом. Если в конструктор передается null, то ис-пользуется естественный порядок сортировки. 
Операции работы с частью множества аналогичны операциям работы с частью спи-сков, но есть одна большая разница. Подмножество остается валидным даже в том случае, если исходное множество было изменено напрямую. Это осуществимо, т. к. 
конечные точки подмножества являются абсолютными точками из элементов, а не индексами элементов, как это было для списков. 
Сортированные множества имеют три метода получения подмножества. Первый метод — subSet. У него есть два параметра, в которых указываются сами элементы диапазона подмножества. Эти элементы должны быть сравнимы с элементами в множестве при помощи Comparator SortedSet-а или естественного порядка его элементов, смотря, что используется. Начальный элемент включается в подмноже-ство, а конечный — не включается. 
int count = monsters.subSet("Ghoul", "Succubus").size(); 
Изменения в множестве, полученном с помощью метода subSet, отражаются на ис-ходном множестве. Можно удалить монстров от Ghoul до Succubus: 
monsters.subSet("Ghoul", "Succubus").clear(); 
Есть также два метода: headSet и tailSet. Эти методы принимают в качестве пара-метра только один объект. Метод headSet возвращает подмножество от начала до 294 Глава 26. Коллекции указанного объекта, исключая указанный объект. Второй возвращает множество от указанного объекта (включительно) до конца SortedSet-а. Пример: 
SortedSet<String> headMonsters = dictionary.headSet("Ghoul"); 
SortedSet<String> tailMonsters = dictionary.tailSet("Succubus"); 
26.12. Интерфейс SortedMap Интерфейс java.util.SortedMap представляет собой java.util.Map, который хранит свои элементы отсортированными по возрастанию ключей в соответствии с естест-венным порядком или указанным Comparator-ом. 
Интерфейс java.util.SortedMap содержит методы из java.util.Map и дополнитель-ные: 
? Работа с частью SortedMap. 
? Получение первого и последнего ключей карты. 
? Доступ к Comparator-у, если он есть. 
public interface SortedMap<K, V> extends Map<K, V>{  Comparator<? super K> comparator(); 
 SortedMap<K, V> subMap(K fromKey, K toKey); 
 SortedMap<K, V> headMap(K toKey); 
 SortedMap<K, V> tailMap(K fromKey); 
 K firstKey(); 
 K lastKey(); 
} Операции SortedMap, унаследованные от Map, действуют аналогично, но имеют две особенности: 
? Итератор проходит по элементам в соответствии с порядком сортировки. 
? Методы toArray у коллекций ключей, значений и элементов возвращают отсор-тированные массивы. 
По соглашению все реализации Map содержат конструктор, который принимает Map в качестве параметра. Реализации SortedMap тоже имеют такой конструктор. В java.util.TreeMap этот конструктор создает экземпляр, который упорядочивает свои элементы в соответствии с естественным порядком сортировки ключей. Одна-ко было бы лучше динамически проверять, что переданный Map является экземпля-ром SortedMap, и сортировать его с тем же критерием (Comparator-ом или естест-венным порядком сортировки). TreeMap содержит еще один конструктор, который принимает SortedMap и создает TreeMap, содержащий связки из переданного SortedMap, отсортированные по тому же критерию. Заметьте, что это определяется на этапе компиляции, т. к. используется перегрузка конструкторов. 
Глава 26. Коллекции 295 26.13. Другие реализации интерфейсов коллекций Класс java.util.Collections имеет специальные методы, позволяющие любую коллекцию обернуть в синхронизированную, которая использует исходную кол-лекцию, но добавляет синхронизацию: 
public static <T> Collection<T> synchronizedCollection(Collection<T> c); 
public static <T> Set<T> synchronizedSet(Set<T> s); 
public static <T> List<T> synchronizedList(List<T> list); 
public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m); 
public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s); 
public static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m); 
Чтобы гарантировать потокобезопасность, все изменения коллекции должны про-исходить с полученной синхронизированной коллекцией, т. е. в идеале нужно "по-терять" ссылку на исходную коллекцию. 
Также можно обернуть коллекцию, получив неизменяемую коллекцию, элементы которой нельзя добавлять, удалять или заменять (возникнет java.lang. 
UnsupportedOperationException). Для этого нужно использовать следующие методы класса Collections: 
public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c); 
public static <T> Set<T> unmodifiableSet(Set<? extends T> s); 
public static <T> List<T> unmodifiableList(List<? extends T> list); 
public static <K,V> Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m); 
public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<? extends T> s); 
public static <K,V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, ? 
extends V> m); 
В Java 9 появились новые способы создания неизменяемых коллекций в дополне-ние к перечисленным выше. 
В классе List в Java 9 появились статические методы of, в которые можно передать элементы для нового неизменяемого списка: 
List<String> unmodifiableList = List.of("Vasya", "Petya"); 
В классе Set в Java 9 появились аналогичные статические методы of: 
Set<String> unmodifiableSet = Set.of("Vasya", "Petya"); 
В классе Map тоже появились аналогичные методы: 
Map<String, String> unmodifiableMap = Map.of("id1", "Vasya", "id2", "Petya"); 
Можно получить коллекцию с динамически проверяемым во время выполнения типом: 
public static <E> Collection<E> checkedCollection(Collection<E> c, Class<E> type); 
public static <E> Set<E> checkedSet(Set<E> s, Class<E> type); 
public static <E> List<E> checkedList(List<E> list, Class<E> type); 
public static <K,V> Map<K,V> checkedMap(Map<K,V> m, Class<K> keyType,  Class<V> valueType); 
296 Глава 26. Коллекции public static <E> SortedSet<E> checkedSortedSet(SortedSet<E> s, Class<E> type) public static <K,V> SortedMap<K,V> checkedSortedMap(SortedMap<K,V> m, Class<K> keyType, Class<V> valueType); 
Любой массив можно превратить в неизменяемый список с помощью метода java.util.Arrays.asList: 
@SafeVarargs public static <T> List<T> asList(T... a) С помощью метода Collections.nCopies можно создать неизменяемый список, со-держащий указанное количество копий элемента: 
public static <T> List<T> nCopies(int n,  T o) Можно создать неизменяемое множество, состоящее только из одного элемента Collections.singleton: 
public static <T> Set<T> singleton(T o) С помощью методов Collections.emptySet(), Collections.emptyList(), Collections. 
emptyMap() можно создать пустые коллекции: 
public static final <T> Set<T> emptySet(); 
public static final <T> List<T> emptyList(); 
public static <E> SortedSet<E> emptySortedSet(); 
public static final <K,V> SortedMap<K,V> emptySortedMap(); 
26.14. Java Stream API Предположим, что мы создаем компьютерную игру, в которой пытаемся описать домового классом Hobgoblin: 
Hobgoblin.java package ru.urvanov.javaindynamics2022.collection; 
 import java.time.LocalDate; 
 public class Hobgoblin {   private String name; 
 private Role role; 
 private int gold; 
 private double health = 100.0; 
 private double power = 30.0; 
  public enum Role {  WARRIOR,  MAGE, Глава 26. Коллекции 297  ARCHER  }  public Hobgoblin(  String name,  Role role,  int gold,  double health,  double power) {  this.name = name; 
 this.role = role; 
 this.gold = gold; 
 this.health = health; 
 this.power = power; 
 }   ... 
}  Следующий пример выводит все имена: 
Hobgoblin.java System.out.println("Список домовых:"); 
for (Hobgoblin hobgoblin : hobgoblins) {  System.out.println(hobgoblin.getName()); 
}  То же самое с помощью потоков и агрегатных операций: 
Hobgoblin.java System.out.println("Список домовых с помощью Java Stream API:"); 
hobgoblins  .stream()  .map(Hobgoblin::getName)  .forEach(System.out::println); 
 В этом примере версия со stream-ами длиннее, но для более сложных задач версии с потоками будут более лаконичными. 
Канал (pipeline) — это последовательность агрегатных операций. Канал (pipeline) состоит из следующих компонентов: 
? Источник, в роли которого может выступать коллекция, массив, генерирующая функция или канал ввода/вывода. 
? Ноль или более промежуточных операций. Промежуточная операция, например map, порождает новый stream. Операция map преобразует элементы. 
298 Глава 26. Коллекции ? Терминальная операция, например forEach, findFirst, findAny, count, создает не-stream результат, например значение примитивного типа, коллекцию, или не возвращает никаких значений совсем. В этом примере параметром forEach явля-ется ссылка на метод System.out.println. 
Следующий пример вычисляет среднее количество золота у всех домовых: 
Hobgoblin.java System.out.println("Среднее количество золота у всех домовых:"); 
OptionalDouble average = hobgoblins  .stream()  .mapToInt(Hobgoblin::getGold)  .average(); 
 Метод mapToInt возвращает новый stream типа IntStream (который является stream-ом, содержащим только int). Метод применяет функцию, переданную в параметр, к каждому элементу stream-а. В этом примере в него передается ссылка на метод получения золота, имеющегося в наличии у домового. В результате mapToInt воз-вращает stream, содержащий возрасты всех членов мужского пола из коллекции hobgoblins.java. 
Операция average вычисляет среднее значение элементов из stream-а типа IntStream. 
Она возвращает объект типа java.util.OptionalDouble. Если stream не содержит элементов, то average возвращает пустой экземпляр java.util.OptionalDouble, и вызов метода getAsDouble приведет к исключению java.util. 
NoSuchElementException. 
Кроме IntStream, существуют еще LongStream и DoubleStream для работы long и double соответственно. Кроме average существуют еще и другие терминальные операции: sum, min, max, count и другие, которые возвращают одно значение на ос-нове содержимого stream-а. Такие операции называются редукционными опера-циями (reduction operations). JDK также содержит редукционные методы, которые возвращают коллекцию вместо одного значения. Многие редукционные операции выполняют конкретную задачу, например нахождение среднего значения или груп-пировку элементов по категориям. Однако JDK содержит редукционные операции общего назначения reduce и collect, которые позволяют создавать собственные терминальные операции. 
С помощью findFirst и findAny можно вернуть один элемент из stream. Отличие в том, что findFirst возвращает первый элемент при упорядоченном stream, а findAny возвращает любой первый попавшийся: 
Hobgoblin.java System.out.println("findAny result: " + hobgoblins.stream().findAny()); 
Глава 26. Коллекции 299 Метод stream.reduce — редукционная операция (reduction operation) общего назна-чения. 
Рассмотрите следующий канал (pipeline): 
Hobgoblin.java System.out.println("Сумма золота у всех домовых:"); 
int sum1 = hobgoblins  .stream()  .mapToInt(Hobgoblin::getGold)  .sum(); 
System.out.println("sum1: " + sum1); 
 И сравните его со следующим, использующим операцию Stream.reduce: 
Hobgoblin.java int sum2 = hobgoblins  .stream()  .map(Hobgoblin::getGold)  .reduce(0, (a, b) -> a + b); 
System.out.println("sum2: " + sum2); 
 В этом примере операция reduce принимает два аргумента: 
? identity: начальное значение редукции и результат по умолчанию для случая, когда нет элементов в stream. В этом примере 0. 
? accumulator: функция с двумя параметрами: частичный результат редукции (в этом примере сумма обработанных чисел до этого момента) и следующий элемент stream-а. Он возвращает частичный результат. В этом примере функция accumulator-а является лямбда-выражением, которое складывает два Integer-а и возвращает полученный результат. 
Операция reduce всегда возвращает новое значение. Однако функция accumulator возвращает новое значение каждый раз, когда она обрабатывает элемент из stream. 
Предположим, что мы ходим превратить эти элементы в более сложный объект, например коллекцию. Если мы будем для этого использовать reduce, то каждая об-работка элемента вызовет создание новой коллекции, что неэффективно. 
В отличие от метода reduce, который всегда создает новое значение при обработке элемента, метод collect меняет существующее значение. 
Рассмотрим пример, когда из большого числа домовых нам необходимо создать одного объединенного домового, который получается в результате мутации. Коли-чество золота у результирующего домового должно быть суммой золота у всех исходных домовых, а сила результирующего домового должна быть средним арифметическим от силы всех исходных домовых: 
300 Глава 26. Коллекции HobgoblinMorph.java package ru.urvanov.javaindynamics2022.collection; 
 import java.util.function.Consumer; 
 public class HobgoblinMorph implements Consumer<Hobgoblin> {  private int gold; 
 private double power; 
 private int count; 
  @Override  public void accept(Hobgoblin other) {  count++; 
 gold+= other.getGold(); 
 power+= other.getPower(); 
 }   public void combine(HobgoblinMorph hobgoblinMorph) {  this.gold += hobgoblinMorph.gold; 
 this.power += hobgoblinMorph.power; 
 this.count += hobgoblinMorph.count; 
 }   public Hobgoblin morph() {  return new Hobgoblin(  "WeatlhyHobgoblin",  Hobgoblin.Role.WARRIOR,  gold,  100.0,  power / count); 
 } }  Следующий конвейер использует класс HobgoblinMorph и метод collect для вычис-ления среднего возраста всех членов мужского пола: 
Hobgoblin.java System.out.println("Преобразуем в объединенного богатого домового:"); 
HobgoblinMorph hobgoblinMorph = hobgoblins.stream()  .collect(  HobgoblinMorph::new,  HobgoblinMorph::accept,  HobgoblinMorph::combine); 
System.out.println(hobgoblinMorph.morph()); 
Глава 26. Коллекции 301 Операция collect в этом примере принимает три аргумента: 
? supplier: фабричная функция, которая создает экземпляры. Для операции collect она создает экземпляры результирующего контейнера. В этом приме-ре — экземпляры класса HobgoblinMorph. 
? accumulator: функция включает элемент из steam в число членов результирую-щего контейнера. В этом примере она модифицирует контейнер HobgoblinMorph, увеличивая переменные для подсчета золота и силы. 
? combiner: функция, которая принимает два результирующих контейнера и объ- единяет их содержимое. 
Операции collect можно использовать с параллельными stream-ами. (Если вы за-пустите метод collect с параллельным stream, то JDK создаст новый поток, когда функция combiner создает новый объект, а значит, вам не нужно беспокоиться о синхронизации.) Операция collect часто используется со стандартными коллекторами, которые преобразуют элементы в список, множество или в Map (Collectors.toList, Collectors.toSet, Collectors.toMap). 
Hobgoblin.java List<Integer> hobgoblinGolds = hobgoblins.stream()  .map(Hobgoblin::getGold)  .collect(Collectors.toList()); 
 Эта версия collect принимает один параметр типа Collector. Этот класс содержит три метода, которые могут использоваться в качестве аргументов операции collect. 
Пример использует Collectors.toList, который собирает элементы stream-а в но-вый экземпляр List. Как и большинство методов класса Collectors, метод toList возвращает экземпляр Collector, а не саму коллекцию. 
Java Stream API позволяет производить группировку элементов коллекций по како-му-либо полю либо по результату вычисления какого-либо выражения. 
Следующий пример группирует элементы hobgoblins по полу: 
Hobgoblin.java Map<Role, List<Hobgoblin>> groupedHobgoblins = hobgoblins.stream()  .collect(Collectors.groupingBy(Hobgoblin::getRole)); 
 Существует также вариант groupingBy с двумя параметрами. Второй параметр при-нимает операцию reduce: 
Hobgoblin.java Map<Role, Integer> groupedHobgoblinsGold = hobgoblins.stream()  .collect(Collectors.groupingBy( 302 Глава 26. Коллекции  Hobgoblin::getRole,  Collectors.summingInt(Hobgoblin::getGold))); 
 Java Stream API может работать с параллельными stream-ами. Сложность в реали-зации параллелизма в приложениях, использующих коллекции, — коллекции не являются потокобезопасными; это означает, что несколько потоков не могут мани-пулировать коллекцией без вмешательства в поток (thread interference) и ошибок консистентности памяти (memory consistency errors). Collections Framework предос-тавляет специальные обертки, которые делают синхронизацию для любой коллек-ции, что делает их потокобезопасными. Однако синхронизация приводит к конку-ренции потоков. Вы хотите избежать конкуренции потоков, т. к. это мешает их па-раллельной работе. Агрегатные операции и параллельные потоки позволяют реализовать параллелизм с непотокобезопасными коллекциями, т. к. вы не меняете коллекцию, пока работаете с ней. 
Параллелизм не означает, что операции будут выполняться быстрее, чем если бы они выполнялись последовательно, однако он может быть быстрее, если у вас дос-таточно много данных и много процессорных ядер. Несмотря на то что агрегатные операции позволяют вам легко реализовать параллелизм, решение об этом все еще остается на ваших плечах. 
Вы можете выполнять stream-ы последовательно или параллельно. При выполне-нии stream-ов параллельно Java разделяет stream на несколько substream-ов. Агре-гатные операции проходят по этим substream-ам параллельно и затем объединяют результат. 
Stream всегда последовательный, если не указано обратное. Для того чтобы создать параллельный stream, вызовите метод java.util.Collection.parallelStream, либо вы можете вызвать java.util.stream.BaseStream.parallel. Например, следующая инструкция вычисляет средний возраст всех мужских участников параллельно: 
Hobgoblin.java int parallelSumGold = hobgoblins  .parallelStream()  .filter(v -> Role.MAGE == v.getRole())  .mapToInt(Hobgoblin::getGold)  .sum(); 
 В случае использования параллельных stream-ов необходимо также использовать коллекторы, поддерживающие параллельную обработку. Например, для примера с группировкой домовых по роли нужно использовать Collectors.groupingByConcurrent: 
Hobgoblin.java Map<Role, List<Hobgoblin>> parallelGroupedHobgoblins  = hobgoblins.stream()  .collect(Collectors.groupingByConcurrent(Hobgoblin::getRole)); 
Глава 26. Коллекции 303 26.15. Алгоритмы Все стандартные реализации алгоритмов находятся в классе java.util.Collections, и все они являются статическими методами, которые принимают в качестве пер- вого аргумента коллекцию, над которой будет осуществляться выполнение алго-ритма. 
public static <T extends Comparable<? super T>> void sort(List<T> list) public static <T> void sort(List<T> list,  Comparator<? super T> c) Методы Collections.sort сортируют содержимое списка в соответствии с естест-венным порядком либо в соответствии с указанным компаратором. 
Пример: 
Sort.java import java.util.*; 
 public class Sort {  public static void main(String[] args) {  List<String> list = Arrays.asList(args); 
 Collections.sort(list); 
 System.out.println(list); 
 } }  public static void shuffle(List<?> list) Метод Collections.shuffle перемешивает содержимое списка случайным образом. 
 public static void reverse(List<?> list) Метод Collections.reverse меняет порядок элементов в списке на обратный. 
 public static <T> void fill(List<? super T> list,  T obj) Метод Collections.fill заменяет все элементы списка на obj. 
 public static <T> void copy(List<? super T> dest,  List<? extends T> src) Метод Collections.copy копирует все элементы из списка src в список dest. Список dest должен содержать количество элементов, как минимум равное количеству элементов src. 
 public static void swap(List<?> list,  int i,  int j) Меняет местами два элемента в списке. 
304 Глава 26. Коллекции @SafeVarargs public static <T> boolean addAll(Collection<? super T> c,  T... elements) Метод Collections.addAll добавляет все указанные элементы в коллекцию c. 
 public static <T> int binarySearch(  List<? extends Comparable<? super T>> list,  T key)  public static <T> int binarySearch(List<? extends T> list,  T key,  Comparator<? super T> c) Методы Collections.binarySearch ищут вхождение элемента в списке с помощью бинарного поиска и естественного порядка сортировки или компаратора. Список должен быть отсортирован по возрастанию с помощью используемого компаратора или в естественном порядке (зависимости от того, что используется при поиске). 
Если есть несколько искомых элементов, то может вернуться индекс любого из них. Если искомый объект не найден, то возвращается (-(место_вставки) - 1), где место_вставки — позиция, куда следовало бы вставить элемент. 
 public static int frequency(Collection<?> c,  Object o) Метод Collections.frequency возвращает количество элементов o в коллекции c. 
Для сравнения используется метод equals. 
 public static boolean disjoint(Collection<?> c1,  Collection<?> c2) Возвращает true, если две коллекции не имеют ни одного общего элемента. 
 26.16. Задания 1. Создайте класс мифического существа. Добавьте ему поле "жизненная сила", а также поле типа существа: демоническое, нежить, призрачное и т. д. Создайте список, содержащий существа разных типов. С помощью Java Stream API сгруп-пируйте существ по типу и посчитайте суммарное количество жизненной силы у каждого типа. 
2. Создайте класс, который мог бы представлять информацию о банковском счете: 
валюта, сумма, Ф.И.О. владельца и т. д. С помощью Java Stream API подсчитай-те суммарное количество денег каждой валюты и среднее количество денег каж-дой валюты на счете. 
3. Создайте класс, который мог бы представлять собой карточку товара в трюме пиратского корабля: вес, название, примерная цена за единицу, количество, ред-кость, риск при продаже и т. д. Заполните список десятью экземплярами этого Глава 27. Дата и время 305 класса. С помощью стандартных алгоритмов отсортируйте его по конечной стоимости. 
4. Назовите способы создания неизменяемых коллекций. 
5. Какие классы потокобезопасных коллекций вы знаете

## Интерфейс SortedSet

Интерфейс `java.util.SortedSet` — это расширение интерфейса `java.util.Set`, который поддерживает хранение элементов в отсортированном порядке, как по естественному порядку, так и по заданному компаратору. В дополнение к стандартным операциям `Set`, `SortedSet` добавляет три основные группы операций:

- **Работа с подмножествами**: Методы `subSet(E fromElement, E toElement)`, `headSet(E toElement)` и `tailSet(E fromElement)` позволяют работать с частями исходного множества.
- **Получение крайних элементов**: Методы `first()` и `last()` возвращают первый и последний элементы соответственно.
- **Доступ к компаратору**: Метод `comparator()` возвращает компаратор, используемый для сортировки множества.

Все реализации интерфейса `Collection` имеют стандартный конструктор, принимающий другую коллекцию. В случае `SortedSet`, например, в классе `TreeSet`, этот конструктор создает экземпляр, сортирующий элементы по их естественному порядку или по заданному компаратору. Если передан `null`, используется естественный порядок.

### Работа с подмножествами

Подмножества остаются валидными даже при изменении исходного множества. Это возможно благодаря тому, что границы подмножества определяются элементами, а не индексами.

Пример использования метода `subSet`:
```java
int count = monsters.subSet("Ghoul", "Succubus").size();
monsters.subSet("Ghoul", "Succubus").clear();
```

Методы `headSet` и `tailSet` работают с одним параметром и возвращают соответствующие подмножества.

### Интерфейс SortedMap

Интерфейс `java.util.SortedMap` представляет собой карту, хранящую свои элементы в отсортированном порядке по ключам. Он включает методы для работы с частями карты, получения первого и последнего ключей, а также доступа к компаратору.

```java
public interface SortedMap<K, V> extends Map<K, V> {
    Comparator<? super K> comparator();
    SortedMap<K, V> subMap(K fromKey, K toKey);
    SortedMap<K, V> headMap(K toKey);
    SortedMap<K, V> tailMap(K fromKey);
    K firstKey();
    K lastKey();
}
```

### Другие реализации интерфейсов коллекций

Класс `java.util.Collections` предоставляет методы для создания синхронизированных и неизменяемых коллекций:
- Синхронизированные коллекции:
  - `synchronizedCollection(Collection<T> c)`
  - `synchronizedSet(Set<T> s)`
  - `synchronizedList(List<T> list)`
  
- Неизменяемые коллекции:
  - `unmodifiableCollection(Collection<? extends T> c)`
  - `unmodifiableList(List<? extends T> list)`

В Java 9 появились статические методы для создания неизменяемых коллекций:
```java
List<String> unmodifiableList = List.of("Vasya", "Petya");
```

### Java Stream API

Java Stream API позволяет работать с коллекциями более лаконично. Например, для вывода всех имен домовых можно использовать:
```java
hobgoblins.stream().map(Hobgoblin::getName).forEach(System.out::println);
```

Для вычисления среднего количества золота у всех домовых:
```java
OptionalDouble average = hobgoblins.stream().mapToInt(Hobgoblin::getGold).average();
```

Stream API также поддерживает параллельные потоки для повышения производительности при обработке больших объемов данных.

### Алгоритмы

Стандартные алгоритмы реализованы в классе `java.util.Collections`. Например:
- Сортировка: 
```java
Collections.sort(list);
```
- Перемешивание:
```java
Collections.shuffle(list);
```
- Поиск:
```java
int index = Collections.binarySearch(list, key);
```

