## ГЛАВА 20. Потоки ввода/вывода

### 20.1. Введение

Поток ввода/вывода (I/O Stream) представляет собой источник данных или место их назначения. Потоки могут представлять собой абсолютно различные источники и места назначения: файлы на диске, устройства, сеть, другие программы, массивы в памяти и т. д.

Потоки поддерживают большое количество различных типов данных: байты, примитивные типы, локализованные символы, объекты. Некоторые потоки просто передают данные, другие изменяют в соответствии со своими потребностями.

### 20.2. Потоки байт

Все классы, работающие с потоками байт, наследуются от абстрактных классов `java.io.InputStream` или `java.io.OutputStream`.

На сайте [https://urvanov.ru](https://urvanov.ru) можно найти диаграмму классов-наследников как для `InputStream`, так и для `OutputStream` — базовых классов для работы с потоками.

Дочерние классы реализуют работу с файлами, сетью и тому подобным либо добавляют дополнительные возможности наподобие буферизации данных.

### 20.3. InputStream

Это абстрактный класс, являющийся базовым для всех классов, представляющих поток ввода.

*   `public int available() throws IOException`

    Возвращает количество байт, которое может быть прочитано из потока без блокировки. Некоторые реализации `InputStream` возвращают полное количество байт в потоке, но не все. Не стоит использовать этот метод для определения размера буфера, который будет хранить все данные из потока.
*   `public void close() throws IOException`

    Закрывает поток и освобождает все ресурсы.
*   `public void mark(int readlimit)`

    Помечает текущую позицию во входной строке. Работает, только если `markSupported()` возвращает `true`. Смысл этого метода в том, что поток каким-нибудь образом запоминает все считанные после вызова этого метода данные и может вернуть те же самые данные еще раз после вызова метода `reset()`. Если после вызова метода `mark(int readLimit)` из потока было прочитано больше `readLimit` байт, то поток не обязан запоминать что бы то ни было.
*   `public void reset() throws IOException`

    Если метод `markSupported()` возвращает `true`, то:

    *   Если метод `mark()` не был вызван ни разу либо количество байт, которые были прочитаны из потока после вызова `mark()`, больше аргумента метода `mark()` в последнем его вызове, то может броситься исключение `IOException`.
    *   Если исключение `IOException` не было брошено, то поток возвращается в такое состояние, что все вызовы методов `read()` в дальнейшем будут возвращать те же данные, которые они возвращали с момента последнего вызова метода `mark()` (либо с начала потока, если метод `mark()` не был вызван ни разу).

    Если метод `markSupported()` возвращает `false`, то:

    *   Вызов метода `reset()` может бросить исключение `IOException`.
    *   Если не бросается исключение `IOException`, то поток сбрасывается в фиксированное состояние, которое зависит от конкретного типа входного потока, и от того, как он был создан. Байты, которые будут прочитаны при последующих вызовах методов `read()`, зависят от конкретного типа входной строки.
*   `public boolean markSupported()`

    Возвращает `true`, если реализация `InputStream` поддерживает методы `mark()` и `reset()`.
*   `public abstract int read() throws IOException`

    Считывает один байт из потока. Возвращает его в `int`, содержащем значение от 0 до 255. Возвращает –1, если достигнут конец потока. Блокирует выполнение текущего потока программы до тех пор, пока не появятся входные данные, не будет достигнут конец потока либо не бросится исключение.
*   `public int read(byte[] b) throws IOException`

    Считывает некоторое количество байт из входного потока и сохраняет его в массив байт `b`. Возвращает количество считанных байт, которое может быть меньше длины массива. Метод блокирует выполнение текущего потока программы до тех пор, пока не появятся входные данные, не будет достигнут конец потока либо не бросится исключение.

    Если длина массива `b` равна нулю, то байты не считываются и возвращается 0, в противном случае происходит попытка считать хотя бы один байт. Если достигнут конец потока, то возвращается –1.

    Метод `read(b)` у класса `InputStream` имеет такой же эффект, что и `read(b, 0, b.length)`, но дочерние классы могут переопределить его, если нужно.
*   `public int read(byte[] b, int off, int len) throws IOException`

    Читает до `len` байт из входного потока в массив байт. Пытается считать `len` байт, но может считать и меньше. Количество реально считанных байт возвращается как `int`.

    Этот метод блокирует выполнение текущего потока программы до тех пор, пока не появятся данные, не будет достигнут конец потока либо не возникнет исключение.

    Если `len` равен нулю, то байты не считываются и возвращается 0. В противном случае происходит попытка считать хотя бы один байт. Если никаких байт нет, т. к. был достигнут конец потока, то возвращается –1, иначе хотя бы один байт считывается и сохраняется в `b`.

### 20.4. OutputStream

Абстрактный класс, являющийся базовым для классов, реализующих выходной поток байт:

Основные методы:

*   `public void close() throws IOException`

    Закрывает выходной поток и освобождает ресурсы.
*   `public void flush() throws IOException`

    Записывает все байты из буфера. Некоторые реализации выходного потока могут накапливать байты в буфере и лишь потом реально записывать их. Вызов этого метода принудительно записывает данные из буфера и очищает его.
*   `public abstract void write(int b) throws IOException`

    Записывает байт в выходной поток.
*   `public void write(byte[] b) throws IOException`

    Записывает `b.length` байт из указанного массива байт в выходной поток. Аналогично вызову `write(b, 0, b.length)`.
*   `public void write(byte[] b, int off, int len) throws IOException`

    Записывает в выходной поток `len` байт из массива байт, начиная с `off`. Реализация этого метода в `OutputStream` вызывает в цикле метод `write(int b)`. Дочерние классы могут переопределить его, дав более оптимальную реализацию.

### 20.5. FileInputStream и FileOutputStream

Предназначены для чтения и записи данных в файл и из файла. Пример использования:

```java
package ru.urvanov.javaindynamics2022.io;

import java.io.InputStream;
import java.io.OutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * Файловые потоки ввода/вывода
 */
class FileInputOutputStreams {
    public static void main(String[] args) {
        try (InputStream is = new FileInputStream("input.txt");
             OutputStream os = new FileOutputStream("output.txt")) {
            int bytesReaded;
            final int BUFFER_SIZE = 10_000;
            byte[] buff = new byte[BUFFER_SIZE];
            while ((bytesReaded = is.read(buff)) != -1) {
                os.write(buff, 0, bytesReaded);
            }
        } catch (IOException ioex) {
            ioex.printStackTrace();
        }
    }
}
```

В диаграмме наследников `InputStream` и диаграмме наследников `OutputStream`, которые можно найти на сайте [https://urvanov.ru](https://urvanov.ru), показаны конструкторы этих классов.

### 20.6. ByteArrayInputStream и ByteArrayOutputStream

Класс `ByteArrayInputStream` позволяет создать входной поток, который будет считывать данные из массива байт. Класс `ByteArrayOutputStream` позволяет записывать данные в поток, а по окончании получить записанные данные в виде массива байт с помощью метода `toByteArray()`. Принцип работы с этими классами такой же, как и с остальными наследниками `java.io.InputStream` и `java.io.OutputStream`.

В диаграмме наследников `InputStream` и диаграмме наследников `OutputStream`, которые можно найти на сайте [https://urvanov.ru](https://urvanov.ru), показаны конструкторы и методы этих классов.

### 20.7. FilterInputStream и FilterOutputStream

Базовые классы для потоков, которые содержат внутри себя другой поток и производят некую трансформацию записываемых и считываемых данных.

В диаграмме наследников `InputStream` и диаграмме наследников `OutputStream` показаны конструкторы и методы этих классов.

### 20.8. DataInputStream и DataOutputStream

Классы `DataInputStream` и `DataOutputStream` позволяют платформонезависимо записывать в поток и считывать из него примитивные типы языка Java. Класс `DataInputStream` реализует интерфейс `DataInput`, который содержит методы для чтения примитивных типов, а класс `DataOutputStream` реализует интерфейс `DataOutput`, который содержит методы для записи примитивных типов. Эти классы используют в качестве обертки над другими потоками, например, так:

```java
DataInputStream dis = new DataInputStream(new FileInputStream("myfile.data"));
```

Методы интерфейса `DataInput` используют исключение `java.io.EOFException` для обозначения конца потока, в отличие от методов класса `InputStream`, которые возвращают –1.

### 20.9. BufferedInputStream и BufferedOutputStream

Классы `BufferedInputStream` и `BufferedOutputStream` используют буфер, чтобы не нагружать систему операцией считывания и записи при каждом вызове методов `write` и `read`.

### 20.10. PipedInputStream и PipedOutputStream

Экземпляр класса `PipedInputStream` должен быть связан с экземпляром класса `PipedOutputStream` с помощью метода `connect(PipedOutputStream src)`. С помощью `PipedInputStream` считываются данные, которые в другом потоке записываются в `PipedOutputStream`.

### 20.11. ObjectInputStream и ObjectOutputStream

Классы `ObjectInputStream` и `ObjectOutputStream` позволяют считывать объекты из потока и записывать в него объекты, т. е. используются для сериализации и десериализации объектов.

### 20.12. Потоки символов

Все классы потоков символов наследуются от `java.io.Reader` или `java.io.Writer`.

Как и у потоков байт, есть два специализированных класса для файлового ввода/вывода: `java.io.FileReader` и `java.io.FileWriter`. Работа с потоками символов аналогична работе с потоками байт.

Любой поток байт можно превратить в поток символов, обернув его в `java.io.InputStreamReader` или в `java.io.OutputStreamWriter` для потока вывода.

```java
try (Reader reader = new InputStreamReader(
        new ByteArrayInputStream(byteArray), "windows-1251")) {
    // ... some code
}
```

С помощью класса `java.io.BufferedReader` можно считывать данные построчно, используя метод `readLine()`, который считает за конец строки символ `\n` (LF), `\r` (CR) или строку из двух символов `\r\n` (CR LF).

На сайте [https://urvanov.ru](https://urvanov.ru) вы можете посмотреть диаграмму с иерархией классов `Reader` и `Writer`.

Обратите внимание, что вторым параметром конструктора `InputStreamReader` мы указали кодировку `windows-1251`. У класса `InputStreamReader` существует конструктор с одним параметром, где не нужно указывать кодировку. Рекомендуется всегда использовать конструктор с указанием кодировки, т. к. в противном случае до Java 18 будет использоваться кодировка по умолчанию: `windows-1251` для Windows в России, `windows-1252` для Windows в Европе и `UTF-8` для современных Linux, что может привести к разным неожиданностям при использовании приложения в разных ОС. А начиная с Java 18, все методы и конструкторы из `java.io` и `java.nio` используют `UTF-8` по умолчанию.

Аналогично `Charset.defaultCharset()` возвращает `UTF-8`, начиная с Java 18, а в версиях до Java 18 он возвращает кодировку системы по умолчанию.

### 20.13. Scanner и PrintStream

Класс `PrintStream` позволяет записывать в поток форматированные данные. Особенно важны его методы `printf` или `format`. Пример `PrintStream` вы уже могли видеть: это `System.out`, с помощью которого мы осуществляли вывод в консоль в примерах.

Класс `Scanner` позволяет считывать из текста форматированные данные с помощью методов `nextInt`, `nextDouble` и аналогичных.

Работа с этими классами несколько отличается от работы с большинством классов, описанных в этой статье.

**ScannerExample.java**

```java
package ru.urvanov.javaindynamics2022.io;

import java.util.Scanner;

/**
 * Пример использования Scanner
 */
public class ScannerExample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("Введите целое число");
        int i = sc.nextInt();
        System.out.println("Введите дробное число");
        double d = sc.nextDouble();
        // System.out - это PrintStream
        // Мы используем метод format, в качестве первого аргумента
        // передается строка, содержащая специальные символы
        // форматирования.
        // %d - вывод десятичного целого числа
        // %f - вывод числа с плавающей точкой.
        // Мы дополнительно указываем,
        // что нужно вывести 10 символов до запятой
        // и 2 символа после запятой
        System.out.format("i = %d, d = %10.2f", i, d);
    }
}
```

