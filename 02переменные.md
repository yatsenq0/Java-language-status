## ГЛАВА 2. Переменные

### 2.1. Типы переменных

Переменные в Java объявляются либо с указанием типа, либо, начиная с Java 10, можно использовать `var`:

```java
int weight = 80;
double monsterHealth;
var ammoCount = 100;
```

Язык программирования Java является строго типизированным. Каждая переменная должна быть объявлена перед использованием либо с прямым указанием своего типа, либо с `var`. Если объявлять переменную с `var`, то ему обязательно нужно присвоить определенное значение, фактический тип вычисляется на основе типа выражения справа.

```java
var monstersCount = 10 * 200 / 2;
var ammo = 250;
```

Сами переменные бывают четырех типов:

*   Переменные экземпляров (нестатические свойства/поля) или Instance Variables (Non-Static Fields). Это те переменные, которые объявлены внутри класса без ключевого слова `static`. Их значения отличны для каждого экземпляра класса.
*   Переменные класса (статические свойства/поля) или Class Variables (Static Fields). Это любое свойство класса, объявленное с ключевым словом `static`. Это свойство относится к самому классу, а не к его экземплярам. Оно существует всегда в единственном экземпляре.
*   Локальные переменные или Local Variables. Локальные переменные — это переменные, объявленные внутри метода (внутри фигурных скобок метода). Они доступны только внутри метода, в котором они объявлены (внутри фигурных скобок). В них методы хранят информацию, необходимую только им, например промежуточные значения своих вычислений.
*   Параметры или Parameters. Параметры — это переменные, которые принимают значение переданных аргументов метода. Мы уже видели пример параметров в описании метода `public static void main(String[] args)`. В этом описании метода `args` — параметр метода.

В последующих главах будет расписано подробнее про классы, методы, переменные экземпляров и переменные классов. Пока же вы можете посмотреть пример объявления каждого из перечисленных выше типов в примере `VariableType`, который находится внутри проекта с примерами кода для книги. Найти этот класс легче всего с помощью главного меню IntelliJ IDEA, выбрав пункты `Navigate` \> `Class...`

В появившемся окне достаточно ввести две заглавные буквы из составного имени класса, как показано на рис. 2.1.

Рис. 2.1. Поиск класса по первым буквам слов его названия

`VariableType.java`

```java
package ru.urvanov.javaindynamics2022.ch1;

public class VariableType {
    // переменные класса ( статические свойства / поля )
    static int variableTypesCounter;
    static String globalName;

    // Переменные экземпляров ( нестатические свойства / поля )
    // Объявлены без ключевого поля static
    // их значения различны для каждого из экземпляров
    private double health;
    private String instanceName;

    // args - это параметры
    public static void main(String[] args) {
        // Объявление локальных переменных.
        // Доступны только внутри метода
        float value1;
        String str1;
        double sum;
    }
}
```

### 2.2. Соглашение об именовании переменных

В Java существуют общепринятые правила именования переменных, которые появились еще тогда, когда она принадлежала Sun, а не Oracle:

*   Имена переменных чувствительны к регистру. Переменные `var1` и `VAR1` — это две разные переменные. Длина имени переменной не ограничена, оно может содержать любое количество символов Юникода и цифр (теоретически можно использовать русские буквы и иероглифы, и оно будет работать), может начинаться с буквы, знака доллара `"$"` или символа подчеркивания `"_"`. Однако по соглашению об именовании Java имена переменных всегда должны начинаться со строчной буквы английского алфавита, но не с символа `"$"` или `"_"`. Также по этому соглашению знак доллара не используется совсем. Некоторые утилиты могут генерировать имена переменных с символом доллара, но вы не должны его использовать.
*   Последующие символы могут быть буквами, цифрами, знаком доллара и подчеркивания. Рекомендуется использовать полные английские слова при именовании переменных, а не сокращения.
*   Если имя переменной содержит несколько слов, то первые буквы второго и последующего слова делаются прописными: `monsterBag`, `transferMoney`, `abstractProxyFactorySingletonBean`.
*   Нельзя использовать зарезервированные (или ключевые) слова в качестве имен переменных.
*   Если значение переменной никогда не меняется, например `static final int BUFFER_SIZE=1024;`, то по соглашению об именовании нужно каждую букву делать ЗАГЛАВНОЙ, а между словами использовать символ подчеркивания `"_"`.

### 2.3. Типы данных

В Java используются восемь примитивных типов данных:

*   `byte` — 8-битное знаковое число. Может хранить значения от –128 до +127 (включительно). Используется, например, в массивах, когда нужно сэкономить память.
*   `short` — 16-битное знаковое число. Может хранить значения от –32 768 до +32 767 (включительно). Используется вместо `int`, когда необходимо сэкономить память.
*   `int` — 32-битное знаковое число. Может хранить значения от –231 до 231 – 1. В Java можно использовать этот тип для хранения беззнакового целого числа от 0 до 232 – 1, используя методы `compareUnsigned`, `divideUnsigned` и другие из класса `java.lang.Integer`.
*   `long` — 64-битное знаковое число. Может хранить значения от –263 до 263 – 1. В Java можно использовать этот тип для хранения беззнакового целого числа от 0 до 264 – 1, используя методы `compareUnsigned`, `divideUnsigned` и другие из класса `java.lang.Long`.
*   `float` — 32-битное число с плавающей точкой одинарной точности согласно IEEE 754. Используется вместо `double`, когда нужно сэкономить память. Нельзя использовать `float` для хранения и обработки денежных значений. Для денежных значений нужно использовать `java.math.BigDecimal`.
*   `double` — 64-битное число с плавающей точкой двойной точности согласно IEEE 754. Используется при необходимости хранить дробные значения. Нельзя использовать `double` для хранения и обработки денежных значений. Для денежных значений нужно использовать `java.math.BigDecimal`.
*   `boolean` — логическое значение. Имеет только два возможных значения: `true` и `false`. Используется для флагов. Его размер точно не определен, несмотря на то, что он несет 1 бит полезной информации.
*   `char` — 16-битный символ Юникода. Его минимальное значение `'\u0000'` или 0, а максимальное — `'\uffff'` (65 535 включительно)

### 2.4. Значения по умолчанию

Если переменная объявлена внутри метода (локальные переменные), то перед ее использованием ей обязательно нужно присвоить значение. При попытке использовать переменную без присваивания значения выйдет ошибка компиляции.

Для полей классов и полей экземпляров классов присваивать начальные значения необязательно, при этом для каждого из них будет присвоено значение по умолчанию в соответствии с таблицей (табл. 2.1).

**Таблица 2.1. Значения по умолчанию для различных типов**

| Тип данных           | Значение по умолчанию для полей |
| :------------------- | :------------------------------- |
| byte                 | 0                                |
| short                | 0                                |
| int                  | 0                                |
| long                 | 0L                               |
| float                | 0.0f                             |
| double               | 0.0d                             |
| char                 | ‘\u0000’                         |
| String (или любой объект) | null                             |
| boolean              | false                            |

Таблицу значений по умолчанию можно посмотреть в работающем примере в классе `DefaultValue`.

### 2.5. Литералы

Литерал — это запись в исходном коде, представляющая собой фиксированное значение.

Можно присвоить литерал переменной примитивного типа (`byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`):

`Literal.java`

```java
boolean b = true;
char ch1 = 'f';
int i1 = 100000;
byte b1 = 100;
short sh1 = 10000;
```

Запустить пример можно в классе `Literal` прилагаемого проекта с примерами.

### 2.6. Целочисленные литералы

Целочисленный литерал имеет тип `int` в обычном случае и тип `long`, если заканчивается на символ `"l"` (строчная буква `"эл"` английского алфавита) или `"L"` (прописная буква `"эл"` английского алфавита). Рекомендуется использовать `"L"`, т. к. `"l"` трудно отличить от единицы.

Значения типов `byte`, `short`, `int` и `long` могут быть созданы из литералов типа `int`.

Значения типа `long`, превышающие `int`, могут быть созданы из литералов типа `long`.

Десятичные литеры могут быть записаны в четырех системах счисления:

*   Десятичной. По основанию 10. Цифры от 0 до 9. Эту систему счисления мы используем в повседневной жизни.
*   Шестнадцатеричной. По основанию 16. Цифры от 0 до 9 и буквы от A до F. Префикс `0x`.
*   Восьмеричной. По основанию 8. Цифры от 0 до 7. Префикс цифра `0`.
*   Двоичной. По основанию 2. Цифры от 0 до 1. Начиная с Java SE 7. Префикс `0b`.

Пример:

`IntegerLiteral.java`

```java
// Число 41 в десятичной системе счисления
int v1 = 41;
// Число 41 в шестнадцатеричной системе счисления
int v2 = 0x29;
// Число 41 в восьмеричной системе счисления
int v3 = 051;
// Число 41 в двоичной системе счисления
int v4 = 0b101001;
```

Можно использовать символ подчеркивания между любыми двумя цифрами любой записи целочисленного литерала. Это может пригодиться, например, для отделения групп цифр:

`IntegerLiteral.java`

```java
int v5 = 1_000_000; //1000000
int v6 = 0x3f_3f; //16191
int v7 = 0_5_1; //41
int v8 = 0b100_101_001;//297
```

Но целочисленный литерал не может заканчиваться или начинаться символом подчеркивания, и символ подчеркивания не может стоять сразу после `0x` или `0b` при использовании шестнадцатеричной и двоичной систем счисления.

### 2.7. Литералы с плавающей точкой

Литералы с плавающей точкой имеют тип `float`, если они оканчиваются на `"f"` или `"F"`, и тип `double`, если они не имеют окончания или оканчиваются на `"d"` или `"D"`.

Можно также использовать научную запись числа (https://urvanov.ru/2021-12-08/научная-запись-числа/) с помощью `"e"` или `"E"`, что означает экспоненту (умножить на 10 в степени указанного числа).

`FloatingPointLiteral.java`

```java
double d1 = 123.4;
// То же значение, что и у d1 (1.234 умножить 10 во второй степени)
double d2 = 1.234e2;
float f1 = 123.4f;
```

Существует также двоично-десятичная запись:

`FloatingPointLiteral.java`

```java
// 1 (в шестнадцатеричной системе) умножить на 2 в степени 3.
// То есть 8.0
double d3 = 0x1p3;
// 0xF (в шестнадцатеричной системе) умножить на 2 в степени 3
// То есть 120.0
double d4 = 0xFp3;
```

Можно использовать символ подчеркивания для отделения групп в целой части, дробной части и экспоненте (после `"e"` или `"E"`, `"p"` или `"P"`). Символ подчеркивания может стоять только между двумя цифрами!

Примеры:

`FloatingPointLiteral.java`

```java
double d5 = 1_000.000_001;// 1000.000001
```

### 2.8. Символьные и строковые литералы

Строковые и символьные литералы могут содержать любой символ Юникода (UTF-16). Если ваш редактор текста не поддерживает эти символы, то вы можете вставлять их коды вида `'\u00A9'` (знак копирайта), где после `\u` стоит код символа Юникод в шестнадцатеричной системе счисления. Строки всегда заключаются в двойные кавычки, а символы — в одинарные.

Можно также использовать коды `\b` (backspace), `\t` (табуляция), `\n` (подача строки), `\f` (конец страницы, такое сейчас почти не используется), `\r` (возврат каретки), `\"` (двойная кавычка), `\'` (одинарная кавычка) и `\\` (косая черта).

`SymbolAndStringLiteral.java`

```java
char ch1 = '\t'; // Символ табуляции
char ch2 = 'f'; // Буква f
char ch3 = '\u00A9'; // Знак копирайта
char ch4 = '©'; // В коде можно использовать все символы Юникода.
// Так тоже сработает
System.out.println("символы: " + ch1 + ch2 + ch3 + ch4);

String myString1 = "Просто пример строки\nС переводами строк\n";
System.out.println("myString1 = " + myString1);
```

Для многострочных строковых литералов можно использовать блоки текста, которые окончательно вошли в Java 15 (https://urvanov.ru/2021/02/15/что-нового-в-java-15/#textblocks). Для блоков текста используют три двойные машинописные кавычки:

`SymbolAndStringLiteral.java`

```java
String myTextBlock1 = """
        Взгляни на милую, когда свое чело
        Она пред зеркалом цветами окружает,
        Играет локоном — и верное стекло
        Улыбку, хитрый взор и гордость отражает.

        """;
System.out.println("myTextBlock1 = ");
System.out.println(myTextBlock1);
```

С помощью блоков текста можно также создавать длинные строки, не помещающиеся в ширину экрана. Для этого используется обратная косая черта. В следующем куске кода создается переменная `textBlockWithOneLine`, содержащая одну строку без символов перевода строки:

`SymbolAndStringLiteral.java`

```java
String textBlockWithOneLine = """
        Lorem ipsum dolor sit amet, consectetur adipiscing \
        elit, sed do eiusmod tempor incididunt ut labore \
        et dolore magna aliqua.\
        """;
```

Если в многострочном блоке текста нужно каждую строку дополнить пробелами, то после нужного количества пробелов указывается `\s`:

`SymbolAndStringLiterla.java`

```java
String myTextBlockWithAdjust = """
        Взгляни на милую, когда свое чело \s
        Она пред зеркалом цветами окружает, \s
        Играет локоном — и верное стекло \s
        Улыбку, хитрый взор и гордость отражает. \s
        """;
```

Рекомендуется посмотреть примеры строковых литералов в классе `SymbolAndStringLiteral` прилагаемого к книге проекта с примерами.

### 2.9. Другие литералы

Существует еще литерал `null`, который можно присвоить переменным ссылочных типов данных.

Плюс еще есть литерал класса. Он формируется с помощью добавления `.class` к имени типа, например `String.class`. Этот литерал ссылается на объект `java.lang.Class`, который представляет собой тип.

### 2.10. Массивы

Массив — это объект-контейнер, хранящий фиксированное количество элементов одинакового типа. Длина массива фиксируется после создания и не меняется на всем протяжении существования этого массива.

Нумерация элементов массива начинается с нуля. Первый элемент имеет индекс 0, второй — 1 и т. д. Последний элемент имеет индекс, на единицу меньший длины массива.

При объявлении массива сначала указывается тип данных, затем идут квадратные скобки и имя переменной. Квадратные скобки можно ставить не только после типа данных, но и после имени переменной, однако рекомендуется первый вариант.

Пример:

```java
int[] arrayOfInt;
int arrayOfInt2[];
long[] arrayOfLong;
String[] arrayOfString;
double[] arrayOfDouble;
```

Для инициализации массива используется оператор `new` и имя типа данных с указанием размерности в квадратных скобках:

```java
int a[] = new int[10]; // массив из 10 элементов типа int.
double[] arrayOfDouble = new double[12]; // массив из 12 элементов
// типа double
```

После инициализации можно присваивать значения элементам массива. Доступ к элементам происходит по индексу, указанному в квадратных скобках после имени переменной:

```java
a[1] = 12;
a[3] = 14;
arrayOfDouble[2] = 3.3;
System.out.println("The second element of a: " + a[1]); // 12
```

Для первоначальной инициализации массива можно использовать вот такую конструкцию:

```java
// Инициализируем массив длиной 4 с элементами 10, 3, -4 и 67.
int[] myArray = {10, 3, -4, 67};
// или так
// Инициализируем массив длиной 4 с элементами 10, 3, -4 и 67.
int[] myArray = new int[] {10, 3, -4, 67};
```

Общий пример работы с массивами:

`ArrayExample.java`

```java
public class ArrayExample {
    public static void main(String[] args) {
        int[] myArray = {10, 3, -4, 67};
        double[] arrayOfDouble = new double[3];
        myArray[0] = 12;
        arrayOfDouble[2] = 3.4;
        System.out.println("The first element of myArray is "
                + myArray[0]); // 12
        System.out.println("The second element of myArray is "
                + myArray[1]); // 3
        System.out.println("The third element of arrayOfDouble is "
                + arrayOfDouble[2]); // 3.4
    }
}
```

Класс `java.util.Arrays` содержит множество полезных методов для работы с массивами: с помощью этих методов реализуются копирование, поиск, заполнение, сортировка. Имеет смысл ознакомиться с этими методами. Также может быть полезен метод `static void java.lang.System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`, который позволяет копировать элементы одного массива в другой.

