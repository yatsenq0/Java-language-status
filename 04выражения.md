## Глава 4. Выражения, Инструкции и Блоки

Выражения — это конструкции, состоящие из переменных, операций и вызовов методов. Тип данных, возвращаемый выражением, зависит от используемых элементов. Например, выражение `9 * 3.0` возвращает тип `double`.

В составных выражениях с различными операторами рекомендуется расставлять скобки, а не надеяться на приоритет операций:

```java
(a == b) && (d == c)
a + (b * c)
```

Инструкции или операторы — это наименьшая законченная часть языка программирования. Следующие виды выражений могут быть преобразованы в инструкции с помощью завершающего символа `;`:

*   Выражение с присвоением.
*   Любое использование `++` или `--`.
*   Вызов методов.
*   Выражения создания объектов.

```java
// Присваивание
f1 = 34.5f;

// Инкремент
y++;

// Вызов метода
System.out.println("Hello, World!");

// Создание объекта
java.math.BigDecimal sum1 = new java.math.BigDecimal("100.0");
```

В дополнение к вышеперечисленным инструкциям есть еще инструкции объявления и инструкции управления порядком выполнения. Инструкции управления порядком выполнения будут рассмотрены позже, а 








### 4.1. Операторы управления порядком выполнения

Инструкции (операторы) в программе выполняются сверху вниз по исходному файлу. Операторы управления порядком выполнения могут прервать обычный ход выполнения, позволив выполнить один кусок кода несколько раз, выполнить кусок кода только при выполнении определенного условия.

### 4.2. Операторы if-then и if-then-else

Оператор `if-then` / `if-then-else` позволяет выполнить один оператор или блок операторов только при выполнении определенного условия. Он имеет две формы.

Форма `if-then` позволяет выполнить кусок кода при выполнении определенного условия, а форма `if-then-else` в дополнение к этому позволяет еще указать кусок кода, который будет выполняться при НЕвыполнении этого условия.

Синтаксис `if-then` для блока операторов:

```java
if (<выражение_boolean>) {
    <оператор1>;
    <оператор2>;
    ...
    <операторN>;
}
```

Оператор `if-then` выполняется так:

1.  Вычисляется результат выражения `<выражение_boolean>`, которое должно обязательно вернуть тип `boolean`.
2.  Если выражение `<выражение_boolean>` вернуло `true`, то выполняется `<оператор1>` для случая с одним оператором и `<оператор1>`, `<оператор2>`, ... `<операторN>` для случая блока операторов.

Примеры:

```java
if (isCracked)
    System.out.println("Cracked");

if (isCracked) {
    System.out.println("In block");
    System.out.println("Cracked");
}
```

Согласно официальному соглашению по оформлению кода рекомендуется всегда использовать блок операторов, даже если оператор только один. Пример:

```java
if (isCracked) {
    System.out.println("Cracked");
}
```

Синтаксис `if-then-else`:

```java
if (<выражение_bolean>) {
    <оператор_then_1>;
    <оператор_then_3>;
    ...
    <оператор_then_N>;
} else
    <оператор_else_1>;

if (<выражение_bolean>)
    <оператор_then_1>;
else {
    <оператор_else_1>;
    <оператор_else_2>;
    ...
    <оператор_else_N>;
}

if (<выражение_bolean>) {
    <оператор_then_1>;
    <оператор_then_3>;
    ...
    <оператор_then_N>;
} else {
    <оператор_else_1>;
    <оператор_else_2>;
    ...
    <оператор_else_N>;
}
```

Работает он так:

*   Если `<выражение_boolean>` вернуло `true`, то выполняется оператор или блок операторов внутри фигурных скобок, как и для `if-then`.
*   Если `<выражение_boolean>` вернуло `false`, то выполняется оператор или блок операторов в `else`.

Примеры:

```java
if (isCracked) {
    System.out.println("Cracked");
} else {
    System.out.println("not cracked");
}

if (isCracked)
    System.out.println("Cracked");
else
    System.out.println("not cracked");
```

Можно в блоке `else` проверить другое условие, тогда получится конструкция вида:

```java
if (x < 0) {
    System.out.println("< 0");
} else if (x == 3) {
    System.out.println(" == 3");
} else if (x > 10) {
    System.out.println(" > 10");
} else {
    System.out.println("else (x >= 0 and x <> 3 and x <= 10)");
}
```

В конструкциях такого вида будет сначала проверяться условие в первом `if` (в данном случае `x < 0`), если оно вернет `true`, то выполнится его блок, если оно вернет `false`, то будет проверяться следующее условие (в данном случае `x == 3`), если оно вернет `true`, то выполнится его блок. Таким образом, будут проверяться подряд все условия до такого условия, которое вернет `true`. Если же ни одно из условий не вернет `true`, то выполнится блок `else` (если он есть, но его может не быть, тогда управление перейдет дальше к следующему оператору за такой конструкцией).

Обратите внимание, что `<выражение_boolean>` может быть абсолютно любым выражением, возвращающим `boolean`, можно использовать даже операцию присваивания переменной логического типа, т. к. операция присваивания тоже возвращает значение.

```java
boolean b;
int x = 3;

if (b = x > 0) {
    // Теперь b присвоено true как результат метода
    // obj1.someMethodReturnsBoolean()
} else {
    // А вот здесь b присвоено false.
}
```

Однако соглашение по оформлению кода в Java гласит, что использовать подобную возможность не стоит.

### 4.3. Оператор switch

Рассмотрим следующий кусок кода:

```java
if (mode == 0) {
    // Инструкции для mode 0
} else if (mode == 1) {
    // Инструкции для mode 1
} else if (mode == 2) {
    // Инструкции для mode 2
} else {
    // Инструкции для остальных mode.
}
```

В куске кода, приведенном выше, проверяется значение переменной `mode`. Для значений 0, 1 и 2 предусмотрены отдельные блоки кода, и еще один блок кода предусмотрен для всех остальных значений. Оператор `switch` делает то же самое, но код становится более наглядным:

```java
switch (mode) {
    case 0:
        // Инструкции для mode 0
        break;
    case 1:
        // Инструкции для mode 1
        break;
    case 2:
        // Инструкции для mode 2
        break;
    default:
        // Инструкции для других mode
        break;
}
```

Оператор `switch` работает в следующем порядке:

1.  Вычисляется выражение в скобках (в данном примере оно состоит просто из переменной `mode`).
2.  Полученное значение проверяется подряд со значениями в блоках `case`, и выполняется тот блок операторов, который относится к `case` со значением, совпадающим со значением выражения.
3.  Если ни одно из значений не совпало, то выполняется блок `default`.
4.  По ключевому слову `break` выполнение блока внутри `case` или `default` завершается, и управление передается на инструкцию, следующую за блоком `switch`.

С помощью `if-then` и `if-then-else` можно проверять любые условия, но с помощью `switch` можно проверять только значения выражений типа `byte`, `short`, `char`, `int`, `enum` (перечисления будут описаны позднее), `String` (начиная с Java SE 7), а также классы `java.lang.Byte`, `java.lang.Short`, `java.lang.Character`, `java.lang.Integer`.

Проверяемые значения в `case` обязательно должны быть константными литералами. Если значение выражения в `switch` равно `null`, то возникает исключение `java.lang.NullPointerException`. Нагляднее всего `switch` выглядит именно с перечислениями.

Ключевое слово `break` не обязательно. В случае его отсутствия по завершении выполнения блока операторов внутри одного `case` выполняются операторы следующего за ним `case`. Это позволяет использовать один блок операторов для нескольких значений `case`:

```java
switch (mode) {
    case -1:
        System.out.println("mode -1");
        break;
    case 0:
        System.out.println("mode 0");
    case 1:
    case 2:
        System.out.println("mode 0 or 1 or 2");
        break;
    case 3:
        System.out.println("mode 2");
        break;
    default:
        System.out.println("mode default");
        break;
}
```

Если `mode` равно 0, то код выше выведет в консоль:

```
mode 0
mode 0 or 1 or 2
```

Если `mode` равно 1, то код выше выведет в консоль:

```
mode 0 or 1 or 2
```

Если `mode` равно 2, то код выше выведет в консоль:

```
mode 0 or 1 or 2
```

Блок `default` не обязательно указывать в конце блока `switch`. Он может стоять и в начале, и в середине; но рекомендуется всегда писать его последним, так получается гораздо нагляднее, потому что он выполняется в том случае, если ни один из `case`-ов не подошел:

```java
switch (mode) {
    case 0:
        System.out.println("mode 0");
        break;
    default:
        System.out.println("mode default");
        break;
    case 1:
        System.out.println("mode 1");
        break;
    case 2:
        System.out.println("mode 2");
        break;
}
```

Можно даже вообще не указывать блок `default`:

```java
switch (mode) {
    case 0:
        System.out.println("mode 0");
        break;
    case 1:
        System.out.println("mode 1");
        break;
    case 2:
        System.out.println("mode 2");
        break;
}
```

В Java 14 появились switch expressions, позволяющие записывать switch более кратким способом, а также возвращать значения из switch.

```java
int moneyType = 3;
String moneyDescription;

// исходный switch:
switch (moneyType) {
    case 1:
    case 2:
        moneyDescription = "Gold";
        break;
    case 3:
        moneyDescription = "Aden";
        break;
    case 4:
    case 5:
        moneyDescription = "Dollar";
        break;
    default:
        moneyDescription = "Septim";
}
System.out.println("moneyDescription = " + moneyDescription);

// Идентичное ему switch expression:
switch (moneyType) {
    case 1, 2 -> moneyDescription = "Gold";
    case 3 -> moneyDescription = "Aden";
    case 4, 5 -> moneyDescription = "Dollar";
    default -> moneyDescription = "Septim";
};
System.out.println("moneyDescription = " + moneyDescription);
```

Обратите внимание: со switch expressions код стал гораздо короче, потому что теперь мы можем перечислять через запятую значения, для которых нужно выполнить одну и ту же ветку кода, а не писать отдельный case на новой строке. Также нам не нужно писать break, который по невнимательности можно было бы легко перепутать с обычным switch.

Кроме более компактного кода switch expressions позволяют возвращать значения из блока switch. Для этого используется ключевое слово yield:

```java
int moneyType = 3;
String moneyDescription = switch (moneyType) {
    case 1, 2:
        System.out.println("Some text");
        yield "Gold";
    case 3:
        yield "Aden";
    case 4, 5:
        yield "Dollar";
    default:
        yield "Septim";
};
```

### 4.4. Оператор while

Оператор `while` позволяет выполнить инструкцию или блок инструкций несколько раз.

Синтаксис оператора `while`:

```java
while (<условие>)
    <оператор1>;
```

И с блоком операторов/инструкций (в соответствии с соглашением по оформлению кода Java рекомендуется использовать вариант с блоком даже в случае одной инструкции):

```java
while (<условие>) {
    <оператор1>;
    <оператор2>;
    ...
    <оператор3>;
}
```

Оператор `while` вычисляет выражение `<условие>` и выполняет оператор или блок операторов, если результат выражения `<условие>` равен `true`. Затем он еще раз вычисляет и проверяет `<условие>` и, если оно вернуло `true`, то снова выполняет оператор или блок операторов. Так происходит до тех пор, пока `<условие>` не вернет `false`.

Следующий код выведет числа от 0 до 10:

```java
int n = 0;
while (n <= 10) {
    System.out.println(n);
    n++;
}
```

Выражение `<условие>` в `while` может быть любым, но оно обязательно должно возвращать тип `boolean`. Следующий код тоже корректен:

```java
// Бесконечный цикл
while (true) {
    // операторы
}
```

Это тоже работает:

```java
// Это тоже корректный код, но obj1 должен иметь
// метод someMethodReturnsBoolean(), возвращающий boolean.
boolean b;
while (b = obj1.someMethodReturnsBoolean()) {
    // операторы
}
System.out.println("moneyDescription = " + moneyDescription);
```

### 4.5. Оператор do-while

Оператор `do-while` похож на оператор `while`, но он сначала выполняет операторы, а лишь потом проверяет условие, таким образом, каждый оператор или блок операторов выполнятся хотя бы один раз.

Примеры:

```java
// вывод чисел от 0 до 10
int x = 0;
do {
    System.out.println(x);
    x++;
} while (x <= 10);

// Условие ложно изначально, но выведется 0, т. к. сначала
// будет выполняться блок операторов, а лишь затем —
// проверяться условие
x = 0;
do {
    System.out.println(x);
    x++;
} while (x < 0);
```

### 4.6. Оператор for

Оператор `for` представляет собой компактную форму перебора диапазона чисел.

Его синтаксис:

```java
for (<инициализация>; <условие>; <инкремент>)
    <оператор1>;
```

Или для блока операторов (в соответствии с соглашением по оформлению кода в Java рекомендуется использовать этот вариант даже для случая одного оператора):

```java
for (<инициализация>; <условие>; <инкремент>) {
    <оператор1>;
    <оператор2>;
    ...
    <операторN>;
}
```

Выражение `<инициализация>` выполняется только один раз перед началом итерации.

Переменные, объявленные в `<инициализация>`, действуют только внутри цикла `for`, включая `<инициализация>`, `<условие>` и `<инкремент>`.

Выражение `<условие>` выполняется перед каждым циклом итерации. Блок операторов или одиночный оператор выполняются только в тех случаях, когда `<условие>` вернуло `true`. Если `<условие>` возвращает `false`, то выполнение цикла `for` завершается.

Выражение `<инкремент>` выполняется после каждого цикла перед проверкой выражения `<условие>`. Его обычно используют для увеличения или уменьшения значения.

Любое из выражений `<инициализация>`, `<условие>`, `<инкремент>` можно опустить.

Можно даже сделать цикл `for` вообще без инициализации, условия, инкремента и оператора/блока операторов:

```java
// Бесконечный цикл
for (;;);
```

Пример использования цикла `for` для вывода значений от 0 до 10:

```java
for (int n = 0; n <= 10; n++) {
    System.out.println(n);
}
```

В `<инициализация>` и `<инкремент>` можно указывать несколько выражений инициализации и несколько инкрементов. В этом случае они указываются через запятую и вычисляются слева направо:

```java
for (int n = 0, m = 3; n <= 10; n++, m--) {
    System.out.println("n=" + n + "; m=" + m);
}
```

Существует еще специальная форма `for` для обхода по массивам и коллекциям:

```java
int[] myarray = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
for (int n : myarray) {
    System.out.println(n);
}
```

Выведет в консоль следующее:

```
0
1
2
3
4
5
6
7
8
9
10
```

### 4.7. Оператор break

Оператор `break` позволяет прервать текущее выполнение `switch` или цикла `for`, `while` и `do-while` и перейти к следующему оператору после него. Примеры:

```java
int n1 = 0;
while (true) {
    System.out.println(n1);
    if (n1 == 10) break;
    n1++;
}

int n2 = 0;
do {
    System.out.println(n2);
    if (n2 == 10) break;
    n2++;
} while (true);

for (int n3 = 0; ;) {
    System.out.println(n3);
    if (n3 == 10) break;
    n3++;
}
```

Все приведенные выше примеры выводят в консоль числа от 0 до 10.

В случае вложенных циклов оператор `break` прерывает выполнение самого глубокого из текущих вложенных циклов. Можно прервать внешний цикл, если указать для него метку:

```java
// метка для внешнего цикла.
outer_for:
for (int n = 0; n < 10; n++) {
    //...
    // метка для внутреннего цикла
    inner_for:
    for (int m = 0; m < 10; m++) {
        // прерываем внешний цикл для n == 2 и m ==4
        if ((n == 9) && (m == 4)) break outer_for;

        // прерываем внутренний цикл для n == 7 и m == 2
        if ((n == 7) && (m == 2)) break;

        // можно прервать внутренний цикл и по метке.
        if ((n == 9) && (m % 2 == 1)) break inner_for;

        System.out.println("n=" + n + "; m=" + m);
    }
}
```

ПРИМЕЧАНИЕ

В Java не принято использовать метки, а значит, и оператор `break` в варианте с меткой тоже использовать не принято.

### 4.8. Оператор continue

Оператор `continue` позволяет пропустить текущую итерацию и перейти сразу к следующей итерации цикла `for`, `while` или `do-while`. Он тоже бывает с меткой и без нее.

Пример без метки:

```java
for (int n = 0; n <= 10; n++) {
    if (n % 2 == 0) continue;
    System.out.println(n);
}
```

Выведет в консоль:

```
1
3
5
7
9
```

Пример с меткой:

```java
// ...
outer_label:
for (int n = 4; n <= 9; n++) {
    int m = 3;
    while (m <= 5) {
        // Если остаток от деления n на m равен 0,
        // то переходим к следующей итерации
        // цикла outer_label
        if (n % m == 0) continue outer_label;
        System.out.println("n=" + n + "; m=" + m);
        m++;
    }
}
```

Это выведет в консоль:

```
n=4; m=3
n=5; m=3
n=5; m=4
n=7; m=3
n=7; m=4
n=7; m=5
n=8; m=3
```

ПРИМЕЧАНИЕ

В Java не принято использовать метки, а соответственно, и оператор `continue` с метками.

### 4.9. Оператор return

Оператор `return` возвращает управление из текущего метода в тот, который вызвал текущий метод. Он имеет две формы: с возвращаемым значением и без.

С возвращаемым значением:

```java
return <выражение>;
```

Пример:

```java
return m + 3;
```

И без возвращаемого значения (для метода с `void`):

```java
return;
```

Оператор `return` используется как в статических методах, так и методах экземпляров, которые будут изучены в последующих главах.

