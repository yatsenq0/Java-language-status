## ГЛАВА 11. Перечисления

### 11.1. Теория

Тип `enum` (перечисление) — это специальный тип, который позволяет переменной иметь одно из предопределенных константных значений. Объявление перечислений похоже на объявления классов: модификатор доступа, ключевое слово `enum` (НЕ `class`!), имя типа, тело перечисления. Тело перечисления содержит имена предопределенных константных значений.

**Direction.java**

```java
public enum Direction {
    NORTH,
    SOUTH,
    EAST,
    WEST
}
```

Затем можно объявить переменную нашего созданного типа перечисления:

**DirectionTest.java**

```java
Direction direction = Direction.NORTH;
```

Глава 11. Перечисления 119 Используйте перечисления всегда, когда вам нужен набор предопределенных связанных между собой констант.

Пример использования:

**Coach.java**

```java
package ru.urvanov.javaindynamics2022.enums;

public class Coach {
    private int x;
    private int y;

    public void move(Direction direction) {
        switch (direction) {
            case NORTH:
                y--;
                break;
            case EAST:
                x++;
                break;
            case SOUTH:
                y++;
                break;
            case WEST:
                x--;
                break;
        }
    }
}
```

Перечисления в Java являются классами.

Все перечисления неявно наследуются от класса `java.lang.Enum`. Поскольку в Java нет множественного наследования, перечисление не может наследоваться от какого-либо другого класса дополнительно, но может реализовывать сколько угодно интерфейсов.

Из класса `java.lang.Enum` каждое перечисление наследует пару полезных методов:

*   `public final int ordinal()`
    Возвращает порядковый номер константы в перечислении. Нумерация начинается с нуля.
*   `public final String name()`
    Метод `name()` возвращает имя константы так, как оно было объявлено в перечислении. Например, `NORTH`.

Также все перечисления неявно становятся `final`, если у них нет ни одной константы с телом класса (описано ниже). Нельзя указывать перечисление в качестве расширяемого класса. Нельзя указывать модификаторы `final` и `abstract` для перечислений.

Для вложенных перечислений всегда подразумевается модификатор `static`. Нельзя явно указывать этот модификатор, иначе будет ошибка компиляции.

Так как вложенные перечисления являются статическими, отсюда вытекает, что анонимные классы, лямбда-выражения, внутренние классы, являющиеся нестатическими членами класса, и локальные классы НЕ могут содержать перечислений.

К каждому перечислению компилятор добавляет статический метод `values()`, который возвращает массив возможных значений для перечисления в том порядке, в котором они объявлены, и статический метод `valueOf(String name)`, который возвращает ссылку на константу перечисления по ее имени.

**DirectionTest.java**

```java
// Перебор всех значений перечисления
for (Direction dir : Direction.values()) {
    System.out.println("toString(): " + dir.toString());
    System.out.println("ordinal(): " + dir.ordinal());
    System.out.println("name() :" + dir.name());
}
```

Выведет:

```
toString(): NORTH
ordinal(): 0
name() :NORTH
toString(): EAST
ordinal(): 1
name() :EAST
toString(): SOUTH
ordinal(): 2
name() :SOUTH
toString(): WEST
ordinal(): 3
name() :WEST
```

Константные значения перечислений (`Direction.NORTH`, `Direction`, `EAST` и т. д.) являются экземплярами этого класса перечисления (`Direction`), но их можно сравнивать через `==`, т. к. для каждой из этих констант всегда будет существовать только один объект. Нельзя пытаться создать экземпляр перечисления вручную любым способом: будет ошибка компиляции. Java Reflection API, метод `clone()` и механизм сериализации/десериализации обрабатывают перечисления таким образом, что повторного создания экземпляров перечислений не происходит.

Для каждого константного значения в перечислении создается поле с модификаторами `public static final` с тем же именем, что и константное значение. Это поле Глава 11. Перечисления 121 имеет выражение инициализации этой константы и имеет те же аннотации, что и константное значение.

Объявление констант в перечислении позволяет указать параметры для конструктора перечисления:

**MagicCreature.java**

```java
package ru.urvanov.javaindynamics2022.enums;

enum MagicCreature {
    GOBLIN(100, 50),
    HOBGOBLIN(110, 30),
    GREMLIN(200, 10);

    private int health;
    private int magic;

    MagicCreature(int health, int magic) {
        this.health = health;
        this.magic = magic;
    }

    public int getHealth() {
        return this.health;
    }

    public int getMagic() {
        return this.magic;
    }

    public static void main(String[] args) {
        System.out.println("Goblin. Health: "
                + MagicCreature.GOBLIN.getHealth()
                + " magic: " + MagicCreature.GOBLIN.getMagic());
    }
}
```

Перечисление может иметь несколько конструкторов, тогда выбирается тот, который обладает наиболее подходящими параметрами. Перечисление не может содержать конструкторов с модификаторами доступа `public` или `protected`. Конструктор без модификатора доступа в перечислении становится приватным (`private`).

Если в перечислении нет ни одного объявления конструктора, то автоматически добавляется конструктор по умолчанию без параметров, с модификатором доступа `private` и без списка возможных исключений.

Если конструктор перечисления содержит ключевое слово `super`, то возникает ошибка компиляции.

122 Глава 11. Перечисления Нельзя обращаться к статическим полям перечисления, если они не являются константами (например, `public static int CONST1 = 200;`), из конструкторов, блоков инициализации экземпляров, выражений инициализации.

Константы перечисления могут содержать тело класса, тогда эти классы автоматически являются анонимными и наследуются от класса текущего перечисления. Перечисление может содержать абстрактные методы, но тогда все константы должны иметь тело класса, в котором обязательно должны реализовать все абстрактные методы:

**MagicBeast.java**

```java
package ru.urvanov.javaindynamics2022.enums;

enum MagicBeast {
    GOBLIN {
        void doSomething() {
            System.out.println("Do something.");
        }

        public void someEnumMethod() {
            // реализация 1.
        }
    },
    HOBGOBLIN(110, 30) {
        void doOtherThing() {
            System.out.println("Do other thing");
        }

        public void someEnumMethod() {
            // реализация 2.
        }
    },
    GREMLIN(200, 10) {
        public void someEnumMethod() {
            // реализация.
        }
    };

    private int health;
    private int magic;

    MagicBeast() {
    }

    MagicBeast(int health, int magic) {
        this.health = health;
        this.magic = magic;
    }

    // Абстрактный метод
    public abstract void someEnumMethod();
}
```

Перечисление не может содержать метод-финализатор `finalize()` (который все равно помечен как метод для удаления в Java 18), иначе возникнет ошибка компиляции.

